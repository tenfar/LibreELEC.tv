From 255b7df3a4f39d59893124e95b48fea36a0138c1 Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Tue, 6 Feb 2018 18:19:17 +0800
Subject: [PATCH] soc: rockchip: power-domain: ack the idle request

I think the request and ack should match in the idle function.

Change-Id: I2606f96ebd635ec5f63528197454cdc5113e8583
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 drivers/soc/rockchip/pm_domains.c | 9 ++++++---
 1 file changed, 6 insertions(+), 3 deletions(-)

diff --git a/drivers/soc/rockchip/pm_domains.c b/drivers/soc/rockchip/pm_domains.c
index c8878798bccb..10a9ffaab5d3 100644
--- a/drivers/soc/rockchip/pm_domains.c
+++ b/drivers/soc/rockchip/pm_domains.c
@@ -47,6 +47,7 @@ struct rockchip_pmu_info {
 	u32 req_offset;
 	u32 idle_offset;
 	u32 ack_offset;
+	bool ack_acknowledge;
 
 	u32 core_pwrcnt_offset;
 	u32 gpu_pwrcnt_offset;
@@ -187,9 +188,10 @@ static int rockchip_pmu_set_idle_request(struct rockchip_pm_domain *pd,
 				   pd_info->req_mask, idle ? -1U : 0);
 
 	dsb(sy);
-
-	/* Wait util idle_ack = 1 */
-	target_ack = idle ? pd_info->ack_mask : 0;
+	if (pmu->info->ack_acknowledge)
+		target_ack = pd_info->ack_mask;
+	else
+		target_ack = idle ? pd_info->ack_mask : 0;
 	ret = readx_poll_timeout_atomic(rockchip_pmu_read_ack, pmu, val,
 					(val & pd_info->ack_mask) == target_ack,
 					0, 10000);
@@ -1009,6 +1011,7 @@ static const struct rockchip_pmu_info rk3036_pmu = {
 	.req_offset = 0x148,
 	.idle_offset = 0x14c,
 	.ack_offset = 0x14c,
+	.ack_acknowledge = true,
 
 	.num_domains = ARRAY_SIZE(rk3036_pm_domains),
 	.domain_info = rk3036_pm_domains,

From 2095e669bf3f19aecbbb818bc5963324227420e0 Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Fri, 12 Jan 2018 15:39:40 +0800
Subject: [PATCH] [WIP]: iommu/rockchip: add support for of loading

The iommu detach won't work when there are two master devices
for the iommu.

Change-Id: Iab05a5914cdf3a7c18df9b3fff0a0a003c791aed
Signed-off-by: Simon Xue <xxm@rock-chips.com>
Signed-off-by: Randy Li <randy.li@rock-chips.com>
Signed-off-by: ayaka <ayaka@soulik.info>
---
 drivers/iommu/dma-iommu-ops.c  |  10 +-
 drivers/iommu/iommu.c          |  21 +++-
 drivers/iommu/rockchip-iommu.c | 255 +++++++++++++++++++++++++++++------------
 include/linux/iommu.h          |   1 +
 4 files changed, 206 insertions(+), 81 deletions(-)

diff --git a/drivers/iommu/dma-iommu-ops.c b/drivers/iommu/dma-iommu-ops.c
index 862d7823985e..e8e257663123 100644
--- a/drivers/iommu/dma-iommu-ops.c
+++ b/drivers/iommu/dma-iommu-ops.c
@@ -373,15 +373,16 @@ static int __iommu_attach_notifier(struct notifier_block *nb,
 {
 	struct iommu_dma_notifier_data *master, *tmp;
 
-	if (action != BUS_NOTIFY_ADD_DEVICE)
+	if (action != BUS_NOTIFY_BIND_DRIVER)
 		return 0;
 
 	mutex_lock(&iommu_dma_notifier_lock);
 	list_for_each_entry_safe(master, tmp, &iommu_dma_masters, list) {
-		if (do_iommu_attach(master->dev, master->ops,
-				master->dma_base, master->size)) {
+		if (data == master->dev && do_iommu_attach(master->dev,
+			master->ops, master->dma_base, master->size)) {
 			list_del(&master->list);
 			kfree(master);
+			break;
 		}
 	}
 	mutex_unlock(&iommu_dma_notifier_lock);
@@ -426,9 +427,6 @@ static int __init __iommu_dma_init(void)
 	if (!ret)
 		ret = register_iommu_dma_ops_notifier(&amba_bustype);
 
-	/* handle devices queued before this arch_initcall */
-	if (!ret)
-		__iommu_attach_notifier(NULL, BUS_NOTIFY_ADD_DEVICE, NULL);
 	return ret;
 }
 arch_initcall(__iommu_dma_init);
diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c
index a070fa39521a..cd202bd4c957 100644
--- a/drivers/iommu/iommu.c
+++ b/drivers/iommu/iommu.c
@@ -425,8 +425,10 @@ rename:
 
 	mutex_lock(&group->mutex);
 	list_add_tail(&device->list, &group->devices);
-	if (group->domain)
+	if (group->domain) {
+		if (!device_property_read_bool(dev, "deferred_attach"))
 		ret = __iommu_attach_device(group->domain, dev);
+	}
 	mutex_unlock(&group->mutex);
 	if (ret)
 		goto err_put_group;
@@ -551,6 +553,19 @@ int iommu_group_for_each_dev(struct iommu_group *group, void *data,
 }
 EXPORT_SYMBOL_GPL(iommu_group_for_each_dev);
 
+/**
+ * iommu_group_ref_get - Increment reference on a group
+ * @group: the group to use, must not be NULL
+ *
+ * This function is called by iommu drivers to take additional references on an
+ * existing group.  Returns the given group for convenience.
+ */
+struct iommu_group *iommu_group_ref_get(struct iommu_group *group)
+{
+	kobject_get(group->devices_kobj);
+	return group;
+}
+
 /**
  * iommu_group_get - Return the group for a device and increment reference
  * @dev: get the group that this device belongs to
@@ -924,10 +939,10 @@ static int iommu_bus_notifier(struct notifier_block *nb,
 	 * ADD/DEL call into iommu driver ops if provided, which may
 	 * result in ADD/DEL notifiers to group->notifier
 	 */
-	if (action == BUS_NOTIFY_ADD_DEVICE) {
+	if (action == BUS_NOTIFY_BIND_DRIVER) {
 		if (ops->add_device)
 			return ops->add_device(dev);
-	} else if (action == BUS_NOTIFY_REMOVED_DEVICE) {
+	} else if (action == BUS_NOTIFY_UNBOUND_DRIVER) {
 		if (ops->remove_device && dev->iommu_group) {
 			ops->remove_device(dev);
 			return 0;
diff --git a/drivers/iommu/rockchip-iommu.c b/drivers/iommu/rockchip-iommu.c
index 8faade084316..44e7256a43d6 100644
--- a/drivers/iommu/rockchip-iommu.c
+++ b/drivers/iommu/rockchip-iommu.c
@@ -23,6 +23,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <linux/of_iommu.h>
 
 /** MMU register offsets */
 #define RK_MMU_DTE_ADDR		0x00	/* Directory table address */
@@ -101,6 +102,7 @@ struct rk_iommu {
 	bool skip_read;	     /* rk3126/rk3128 can't read vop iommu registers */
 	struct list_head node; /* entry in rk_iommu_domain.iommus */
 	struct iommu_domain *domain; /* domain to which iommu is attached */
+	struct iommu_group *group; /* group to which master is attached */
 	struct clk *aclk; /* aclock belong to master */
 	struct clk *hclk; /* hclock belong to master */
 	struct list_head dev_node;
@@ -664,6 +666,11 @@ static void rk_iommu_zap_iova(struct rk_iommu_domain *rk_domain,
 		struct rk_iommu *iommu;
 		iommu = list_entry(pos, struct rk_iommu, node);
 		rk_iommu_zap_lines(iommu, iova, size);
+#if 0
+		if (pos->next != &rk_domain->iommus ||
+			pos->prev != &rk_domain->iommus)
+			break;
+#endif
 	}
 	mutex_unlock(&rk_domain->iommus_lock);
 }
@@ -946,6 +953,84 @@ static struct rk_iommu *rk_iommu_from_dev(struct device *dev)
 	return rk_iommu;
 }
 
+static struct rk_iommu *rk_iommu_get_from_dev(struct device *dev)
+{
+	struct device_node *np = dev->of_node;
+	struct platform_device *pd;
+	int ret;
+	struct of_phandle_args args;
+	struct rk_iommu *rk_iommu;
+
+	/*
+	 * An iommu master has an iommus property containing a list of phandles
+	 * to iommu nodes, each with an #iommu-cells property with value 0.
+	 */
+	ret = of_parse_phandle_with_args(np, "iommus", "#iommu-cells", 0,
+					 &args);
+	if (ret) {
+		dev_err(dev, "of_parse_phandle_with_args(%s) => %d\n",
+			np->full_name, ret);
+		return NULL;
+	}
+	if (args.args_count != 0) {
+		dev_err(dev, "incorrect number of iommu params found for %s (found %d, expected 0)\n",
+			args.np->full_name, args.args_count);
+		return NULL;
+	}
+
+	pd = of_find_device_by_node(args.np);
+	of_node_put(args.np);
+	if (!pd) {
+		dev_err(dev, "iommu %s not found\n", args.np->full_name);
+		return NULL;
+	}
+
+	rk_iommu = dev_get_drvdata(&pd->dev);
+
+	return rk_iommu;
+}
+static void rk_iommu_detach_device(struct iommu_domain *domain,
+				   struct device *dev)
+{
+	struct rk_iommu *iommu;
+	struct rk_iommu_domain *rk_domain = to_rk_domain(domain);
+	int i;
+
+	/* Allow 'virtual devices' (eg drm) to detach from domain */
+	iommu = rk_iommu_from_dev(dev);
+	if (!iommu) {
+		pr_info("%s, %d : %s return\n", __func__, __LINE__, dev_name(dev));
+		return;
+	}
+	//dump_stack();
+	mutex_lock(&rk_domain->iommus_lock);
+	list_del_init(&iommu->node);
+	mutex_unlock(&rk_domain->iommus_lock);
+
+	/* Ignore error while disabling, just keep going */
+	rk_iommu_enable_stall(iommu);
+	rk_iommu_disable_paging(iommu);
+	for (i = 0; i < iommu->num_mmu; i++) {
+		rk_iommu_write(iommu->bases[i], RK_MMU_INT_MASK, 0);
+		rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR, 0);
+	}
+	rk_iommu_disable_stall(iommu);
+
+	if (iommu->skip_read)
+		goto read_wa;
+
+	for (i = 0; i < iommu->num_irq; i++) {
+		devm_free_irq(iommu->dev, iommu->irq[i], iommu);
+	}
+
+read_wa:
+	iommu->domain = NULL;
+
+	rk_iommu_power_off(iommu);
+
+	dev_info(dev, "Detached from iommu domain : %p\n", domain);
+}
+
 static int rk_iommu_attach_device(struct iommu_domain *domain,
 				  struct device *dev)
 {
@@ -958,15 +1043,23 @@ static int rk_iommu_attach_device(struct iommu_domain *domain,
 	 * Such a device does not belong to an iommu group.
 	 */
 	iommu = rk_iommu_from_dev(dev);
-	if (!iommu)
+	if (!iommu) {
+		pr_info("%s, %d : %s return\n", __func__, __LINE__, dev_name(dev));
 		return 0;
+	}
+
+	//dump_stack();
+	if (iommu->domain)
+		rk_iommu_detach_device(iommu->domain, dev);
 
 	rk_iommu_power_on(iommu);
 
 	ret = rk_iommu_enable_stall(iommu);
-	if (ret)
+	if (ret) {
+		pr_info("%s, %d, attach to domain %p failed\n",
+			__func__, __LINE__, domain);
 		return ret;
-
+	}
 	ret = rk_iommu_force_reset(iommu);
 	if (ret)
 		return ret;
@@ -999,53 +1092,13 @@ skip_request_irq:
 	list_add_tail(&iommu->node, &rk_domain->iommus);
 	mutex_unlock(&rk_domain->iommus_lock);
 
-	dev_dbg(dev, "Attached to iommu domain\n");
+	dev_info(dev, "Attached to iommu domain : %p\n", domain);
 
 	rk_iommu_disable_stall(iommu);
 
 	return 0;
 }
 
-static void rk_iommu_detach_device(struct iommu_domain *domain,
-				   struct device *dev)
-{
-	struct rk_iommu *iommu;
-	struct rk_iommu_domain *rk_domain = to_rk_domain(domain);
-	int i;
-
-	/* Allow 'virtual devices' (eg drm) to detach from domain */
-	iommu = rk_iommu_from_dev(dev);
-	if (!iommu)
-		return;
-
-	mutex_lock(&rk_domain->iommus_lock);
-	list_del_init(&iommu->node);
-	mutex_unlock(&rk_domain->iommus_lock);
-
-	/* Ignore error while disabling, just keep going */
-	rk_iommu_enable_stall(iommu);
-	rk_iommu_disable_paging(iommu);
-	for (i = 0; i < iommu->num_mmu; i++) {
-		rk_iommu_write(iommu->bases[i], RK_MMU_INT_MASK, 0);
-		rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR, 0);
-	}
-	rk_iommu_disable_stall(iommu);
-
-	if (iommu->skip_read)
-		goto read_wa;
-
-	for (i = 0; i < iommu->num_irq; i++) {
-		devm_free_irq(iommu->dev, iommu->irq[i], iommu);
-	}
-
-read_wa:
-	iommu->domain = NULL;
-
-	rk_iommu_power_off(iommu);
-
-	dev_dbg(dev, "Detached from iommu domain\n");
-}
-
 static struct iommu_domain *rk_iommu_domain_alloc(unsigned type)
 {
 	struct rk_iommu_domain *rk_domain;
@@ -1060,9 +1113,24 @@ static struct iommu_domain *rk_iommu_domain_alloc(unsigned type)
 	 */
 	pdev = platform_device_register_simple("rk_iommu_domain",
 					       PLATFORM_DEVID_AUTO, NULL, 0);
-	if (IS_ERR(pdev))
+	if (IS_ERR(pdev)) {
+		pr_info("%s, %d\n", __func__, __LINE__);
 		return NULL;
+	}
+#if 0
+	iommu_dev = &pdev->dev;
+	iommu_dev->dma_parms = devm_kzalloc(iommu_dev,
+					    sizeof(*iommu_dev->dma_parms),
+					    GFP_KERNEL);
+	if (!iommu_dev->dma_parms)
+		goto err_unreg_pdev;
 
+	/* Set dma_ops for dev, otherwise it would be dummy_dma_ops */
+	arch_setup_dma_ops(iommu_dev, 0, DMA_BIT_MASK(32), NULL, false);
+
+	dma_set_max_seg_size(iommu_dev, DMA_BIT_MASK(32));
+	dma_coerce_mask_and_coherent(iommu_dev, DMA_BIT_MASK(32));
+#endif
 	rk_domain = devm_kzalloc(&pdev->dev, sizeof(*rk_domain), GFP_KERNEL);
 	if (!rk_domain)
 		goto err_unreg_pdev;
@@ -1100,6 +1168,7 @@ static struct iommu_domain *rk_iommu_domain_alloc(unsigned type)
 	rk_domain->domain.geometry.aperture_end   = DMA_BIT_MASK(32);
 	rk_domain->domain.geometry.force_aperture = true;
 
+	pr_info("%s, %d, domain : %p\n", __func__, __LINE__, &rk_domain->domain);
 	return &rk_domain->domain;
 
 err_free_dt:
@@ -1195,48 +1264,70 @@ static int rk_iommu_group_set_iommudata(struct iommu_group *group,
 static int rk_iommu_add_device(struct device *dev)
 {
 	struct iommu_group *group;
-	int ret;
 
 	if (!rk_iommu_is_dev_iommu_master(dev))
 		return -ENODEV;
 
-	group = iommu_group_get(dev);
+	group = iommu_group_get_for_dev(dev);
+	if (IS_ERR(group))
+		return PTR_ERR(group);
+
+	iommu_group_put(group);
+
+	return 0;
+}
+
+static void rk_iommu_remove_device(struct device *dev)
+{
+	if (!rk_iommu_is_dev_iommu_master(dev))
+		return;
+
+	iommu_group_remove_device(dev);
+}
+
+static struct iommu_group *rk_iommu_device_group(struct device *dev)
+{
+	struct iommu_group *group;
+	struct rk_iommu *rk_iommu;
+	int ret;
+
+	rk_iommu = rk_iommu_get_from_dev(dev);
+	if (!rk_iommu) {
+		pr_err("%s, %d, no rk iommu find from %s\n",
+			__func__, __LINE__, dev_name(dev));
+		ret = -ENODEV;
+		return ERR_PTR(ret);
+	}
+	group = rk_iommu->group;
+
 	if (!group) {
 		group = iommu_group_alloc();
-		if (IS_ERR(group)) {
-			dev_err(dev, "Failed to allocate IOMMU group\n");
-			return PTR_ERR(group);
-		}
+		if (IS_ERR(group))
+			return group;
+	} else {
+		iommu_group_ref_get(group);
 	}
 
-	ret = iommu_group_add_device(group, dev);
-	if (ret)
-		goto err_put_group;
-
 	ret = rk_iommu_group_set_iommudata(group, dev);
 	if (ret)
-		goto err_remove_device;
-
-	iommu_group_put(group);
+		goto err_put_group;
 
-	return 0;
+	rk_iommu->group = group;
+	return rk_iommu->group;
 
-err_remove_device:
-	iommu_group_remove_device(dev);
 err_put_group:
 	iommu_group_put(group);
-	return ret;
+	return ERR_PTR(ret);
 }
 
-static void rk_iommu_remove_device(struct device *dev)
+static int rk_iommu_of_xlate(struct device *dev,
+			     struct of_phandle_args *spec)
 {
-	if (!rk_iommu_is_dev_iommu_master(dev))
-		return;
-
-	iommu_group_remove_device(dev);
+	/* We don't have any phandle args, so just return 0. */
+	return 0;
 }
 
-static const struct iommu_ops rk_iommu_ops = {
+static struct iommu_ops rk_iommu_ops = {
 	.domain_alloc = rk_iommu_domain_alloc,
 	.domain_free = rk_iommu_domain_free,
 	.attach_dev = rk_iommu_attach_device,
@@ -1247,7 +1338,9 @@ static const struct iommu_ops rk_iommu_ops = {
 	.add_device = rk_iommu_add_device,
 	.remove_device = rk_iommu_remove_device,
 	.iova_to_phys = rk_iommu_iova_to_phys,
+	.device_group = rk_iommu_device_group,
 	.pgsize_bitmap = RK_IOMMU_PGSIZE_BITMAP,
+	.of_xlate = rk_iommu_of_xlate,
 };
 
 static int rk_iommu_domain_probe(struct platform_device *pdev)
@@ -1282,6 +1375,7 @@ static int rk_iommu_probe(struct platform_device *pdev)
 	int num_res = pdev->num_resources;
 	int i;
 
+	pr_info("%s, %d, dev name : %s\n", __func__, __LINE__, dev_name(dev));
 	iommu = devm_kzalloc(dev, sizeof(*iommu), GFP_KERNEL);
 	if (!iommu)
 		return -ENOMEM;
@@ -1403,10 +1497,6 @@ static int __init rk_iommu_init(void)
 
 	of_node_put(np);
 
-	ret = bus_set_iommu(&platform_bus_type, &rk_iommu_ops);
-	if (ret)
-		return ret;
-
 	ret = platform_driver_register(&rk_iommu_domain_driver);
 	if (ret)
 		return ret;
@@ -1414,6 +1504,7 @@ static int __init rk_iommu_init(void)
 	ret = platform_driver_register(&rk_iommu_driver);
 	if (ret)
 		platform_driver_unregister(&rk_iommu_domain_driver);
+
 	return ret;
 }
 static void __exit rk_iommu_exit(void)
@@ -1425,6 +1516,26 @@ static void __exit rk_iommu_exit(void)
 subsys_initcall(rk_iommu_init);
 module_exit(rk_iommu_exit);
 
+static int __init rk_iommu_of_setup(struct device_node *np)
+{
+	struct platform_device *pdev;
+
+	if (!platform_bus_type.iommu_ops)
+		bus_set_iommu(&platform_bus_type, &rk_iommu_ops);
+
+	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);
+	if (IS_ERR(pdev)) {
+		pr_err("Failed to create platform device for IOMMU %s\n",
+		       of_node_full_name(np));
+		return PTR_ERR(pdev);
+	}
+
+	of_iommu_set_ops(np, &rk_iommu_ops);
+
+	return 0;
+}
+IOMMU_OF_DECLARE(rk_iommu_of, "rockchip,iommu", rk_iommu_of_setup);
+
 MODULE_DESCRIPTION("IOMMU API for Rockchip");
 MODULE_AUTHOR("Simon Xue <xxm@rock-chips.com> and Daniel Kurtz <djkurtz@chromium.org>");
 MODULE_ALIAS("platform:rockchip-iommu");
diff --git a/include/linux/iommu.h b/include/linux/iommu.h
index f28dff313b07..c1562f95083e 100644
--- a/include/linux/iommu.h
+++ b/include/linux/iommu.h
@@ -244,6 +244,7 @@ extern void iommu_group_remove_device(struct device *dev);
 extern int iommu_group_for_each_dev(struct iommu_group *group, void *data,
 				    int (*fn)(struct device *, void *));
 extern struct iommu_group *iommu_group_get(struct device *dev);
+extern struct iommu_group *iommu_group_ref_get(struct iommu_group *group);
 extern void iommu_group_put(struct iommu_group *group);
 extern int iommu_group_register_notifier(struct iommu_group *group,
 					 struct notifier_block *nb);

From a9f5008ba109d3ae5cc7d6afd107695228541792 Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Sun, 19 Nov 2017 22:56:55 +0800
Subject: [PATCH] [WIP]: iommu/rockchip: move the clock control to power domain

The runtime power domain management framework can drive the
clocks of device rely the power state. With help of PM framework,
we can clock the power more easily.

Change-Id: Ifac5f7b0fc4f53ab4b1b90090b32cee4299dd650
Signed-off-by: ayaka <ayaka@soulik.info>
---
 drivers/iommu/rockchip-iommu.c | 104 ++++++++++++++---------------------------
 1 file changed, 36 insertions(+), 68 deletions(-)

diff --git a/drivers/iommu/rockchip-iommu.c b/drivers/iommu/rockchip-iommu.c
index 44e7256a43d6..f07a82827303 100644
--- a/drivers/iommu/rockchip-iommu.c
+++ b/drivers/iommu/rockchip-iommu.c
@@ -103,8 +103,6 @@ struct rk_iommu {
 	struct list_head node; /* entry in rk_iommu_domain.iommus */
 	struct iommu_domain *domain; /* domain to which iommu is attached */
 	struct iommu_group *group; /* group to which master is attached */
-	struct clk *aclk; /* aclock belong to master */
-	struct clk *hclk; /* hclock belong to master */
 	struct list_head dev_node;
 };
 
@@ -269,26 +267,6 @@ static u32 rk_mk_pte_invalid(u32 pte)
 #define RK_IOVA_PAGE_MASK   0x00000fff
 #define RK_IOVA_PAGE_SHIFT  0
 
-static void rk_iommu_power_on(struct rk_iommu *iommu)
-{
-	if (iommu->aclk && iommu->hclk) {
-		clk_enable(iommu->aclk);
-		clk_enable(iommu->hclk);
-	}
-
-	pm_runtime_get_sync(iommu->dev);
-}
-
-static void rk_iommu_power_off(struct rk_iommu *iommu)
-{
-	pm_runtime_put_sync(iommu->dev);
-
-	if (iommu->aclk && iommu->hclk) {
-		clk_disable(iommu->aclk);
-		clk_disable(iommu->hclk);
-	}
-}
-
 static u32 rk_iova_dte_index(dma_addr_t iova)
 {
 	return (u32)(iova & RK_IOVA_DTE_MASK) >> RK_IOVA_DTE_SHIFT;
@@ -336,16 +314,14 @@ static void rk_iommu_zap_lines(struct rk_iommu *iommu, dma_addr_t iova_start,
 	 * entire iotlb rather than iterate over individual iovas.
 	 */
 
-	rk_iommu_power_on(iommu);
-
+	pm_runtime_get_sync(iommu->dev);
 	for (i = 0; i < iommu->num_mmu; i++) {
 		dma_addr_t iova;
 
 		for (iova = iova_start; iova < iova_end; iova += SPAGE_SIZE)
 			rk_iommu_write(iommu->bases[i], RK_MMU_ZAP_ONE_LINE, iova);
 	}
-
-	rk_iommu_power_off(iommu);
+	pm_runtime_put_sync(iommu->dev);
 }
 
 static bool rk_iommu_is_stall_active(struct rk_iommu *iommu)
@@ -877,13 +853,13 @@ static void rk_iommu_zap_tlb(struct iommu_domain *domain)
 		struct rk_iommu *iommu;
 
 		iommu = list_entry(pos, struct rk_iommu, node);
-		rk_iommu_power_on(iommu);
+		pm_runtime_get_sync(iommu->dev);
 		for (i = 0; i < iommu->num_mmu; i++) {
 			rk_iommu_write(iommu->bases[i],
 				       RK_MMU_COMMAND,
 				       RK_MMU_CMD_ZAP_CACHE);
 		}
-		rk_iommu_power_off(iommu);
+		pm_runtime_put_sync(iommu->dev);
 	}
 	mutex_unlock(&rk_domain->iommus_lock);
 }
@@ -989,6 +965,7 @@ static struct rk_iommu *rk_iommu_get_from_dev(struct device *dev)
 
 	return rk_iommu;
 }
+
 static void rk_iommu_detach_device(struct iommu_domain *domain,
 				   struct device *dev)
 {
@@ -1026,11 +1003,29 @@ static void rk_iommu_detach_device(struct iommu_domain *domain,
 read_wa:
 	iommu->domain = NULL;
 
-	rk_iommu_power_off(iommu);
-
 	dev_info(dev, "Detached from iommu domain : %p\n", domain);
 }
 
+static int rk_iommu_configure_device(struct rk_iommu *iommu)
+{
+	struct rk_iommu_domain *rk_domain = to_rk_domain(iommu->domain);
+	int ret;
+	int i;
+
+	for (i = 0; i < iommu->num_mmu; i++) {
+		rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR,
+			       rk_domain->dt_dma);
+		rk_iommu_base_command(iommu->bases[i], RK_MMU_CMD_ZAP_CACHE);
+		rk_iommu_write(iommu->bases[i], RK_MMU_INT_MASK, RK_MMU_IRQ_MASK);
+	}
+
+	ret = rk_iommu_enable_paging(iommu);
+	if (ret)
+		return ret;
+
+	return rk_iommu_disable_stall(iommu);
+}
+
 static int rk_iommu_attach_device(struct iommu_domain *domain,
 				  struct device *dev)
 {
@@ -1048,12 +1043,10 @@ static int rk_iommu_attach_device(struct iommu_domain *domain,
 		return 0;
 	}
 
-	//dump_stack();
+	pm_runtime_get_sync(iommu->dev);
 	if (iommu->domain)
 		rk_iommu_detach_device(iommu->domain, dev);
 
-	rk_iommu_power_on(iommu);
-
 	ret = rk_iommu_enable_stall(iommu);
 	if (ret) {
 		pr_info("%s, %d, attach to domain %p failed\n",
@@ -1077,25 +1070,17 @@ static int rk_iommu_attach_device(struct iommu_domain *domain,
 	}
 
 skip_request_irq:
-	for (i = 0; i < iommu->num_mmu; i++) {
-		rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR,
-			       rk_domain->dt_dma);
-		rk_iommu_base_command(iommu->bases[i], RK_MMU_CMD_ZAP_CACHE);
-		rk_iommu_write(iommu->bases[i], RK_MMU_INT_MASK, RK_MMU_IRQ_MASK);
-	}
-
-	ret = rk_iommu_enable_paging(iommu);
+	ret = rk_iommu_configure_device(iommu);
 	if (ret)
 		return ret;
 
+	pm_runtime_put(iommu->dev);
 	mutex_lock(&rk_domain->iommus_lock);
 	list_add_tail(&iommu->node, &rk_domain->iommus);
 	mutex_unlock(&rk_domain->iommus_lock);
 
 	dev_info(dev, "Attached to iommu domain : %p\n", domain);
 
-	rk_iommu_disable_stall(iommu);
-
 	return 0;
 }
 
@@ -1427,25 +1412,7 @@ static int rk_iommu_probe(struct platform_device *pdev)
 	iommu->skip_read = device_property_read_bool(dev,
 				"rockchip,skip-mmu-read");
 
-	iommu->aclk = devm_clk_get(dev, "aclk");
-	if (IS_ERR(iommu->aclk)) {
-		dev_info(dev, "can't get aclk\n");
-		iommu->aclk = NULL;
-	}
-
-	iommu->hclk = devm_clk_get(dev, "hclk");
-	if (IS_ERR(iommu->hclk)) {
-		dev_info(dev, "can't get hclk\n");
-		iommu->hclk = NULL;
-	}
-
-	if (iommu->aclk && iommu->hclk) {
-		clk_prepare(iommu->aclk);
-		clk_prepare(iommu->hclk);
-	}
-
 	pm_runtime_enable(iommu->dev);
-	pm_runtime_get_sync(iommu->dev);
 	list_add(&iommu->dev_node, &iommu_dev_list);
 
 	return 0;
@@ -1460,16 +1427,16 @@ static int rk_iommu_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static int __init rk_iommu_runtime_put(void)
+static int rk_iommu_resume(struct device *dev)
 {
-	struct rk_iommu *iommu;
-
-	list_for_each_entry(iommu, &iommu_dev_list, dev_node)
-		pm_runtime_put_sync(iommu->dev);
+	struct rk_iommu *iommu = dev_get_drvdata(dev);
 
-	return 0;
+	if (!iommu->domain)
+		return 0;
+	return rk_iommu_configure_device(iommu);
 }
-late_initcall_sync(rk_iommu_runtime_put);
+
+static UNIVERSAL_DEV_PM_OPS(rk_iommu_pm_ops, NULL, rk_iommu_resume, NULL);
 
 static const struct of_device_id rk_iommu_dt_ids[] = {
 	{ .compatible = "rockchip,iommu" },
@@ -1483,6 +1450,7 @@ static struct platform_driver rk_iommu_driver = {
 	.driver = {
 		   .name = "rk_iommu",
 		   .of_match_table = rk_iommu_dt_ids,
+		   .pm = &rk_iommu_pm_ops,
 	},
 };
 

From 0b95ee97789ee5fe3c9aa02d8d1ee5b2da84b153 Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Tue, 24 Apr 2018 18:14:27 +0800
Subject: [PATCH] dt-bindings: Update documentation for rockchip media

Change-Id: Iad2ac92108cfa95e0e8ff9b410a548e8dbf85633
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 .../devicetree/bindings/video/rockchip_dec.txt     | 46 +++++++++++++++++
 .../devicetree/bindings/video/rockchip_enc.txt     | 54 +++++++++++++-------
 .../bindings/video/rockchip_video_service.txt      | 13 +++++
 .../devicetree/bindings/video/rockchip_vpu.txt     | 59 ++++++++++++++++++++++
 4 files changed, 154 insertions(+), 18 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/video/rockchip_dec.txt
 create mode 100644 Documentation/devicetree/bindings/video/rockchip_video_service.txt
 create mode 100644 Documentation/devicetree/bindings/video/rockchip_vpu.txt

diff --git a/Documentation/devicetree/bindings/video/rockchip_dec.txt b/Documentation/devicetree/bindings/video/rockchip_dec.txt
new file mode 100644
index 000000000000..2cda88f7bba7
--- /dev/null
+++ b/Documentation/devicetree/bindings/video/rockchip_dec.txt
@@ -0,0 +1,46 @@
+Device-Tree bindings for Rockchip Decoder.
+
+Required properties:
+- compatible: There are several encoder IP inside rockchip chips. The value
+	should be one of "rockchip,video-decoder-v1", "rockchip,hevc-decoder-v1"
+
+- reg: physical base address of the controller and length
+
+- clocks: must include clock specifiers corresponding to entries in the
+        clock-names property.
+
+- clock-names: from common clock binding:
+	       Required elements: "aclk_vcodec", "hclk_vcodec", "clk_cabac",
+		"clk_core".
+
+- resets : a list of phandle + reset specifier pairs
+
+- reset-names : string reset name, must be:
+		"video_a", "video_h", "niu_a", "niu_h", "video_cabac",
+		"video_core".
+
+- power-domains : power-domain property defined with a phandle
+		  to respective power domain.
+
+Example:
+
+DT entry:
+	rkvdec: rkvdec@ff36000 {
+		compatible = "rockchip,video-decoder-v1";
+		reg = <0x0 0xff360000 0x0 0x400>;
+		interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_dec";
+		clocks = <&cru ACLK_RKVDEC>, <&cru HCLK_RKVDEC>,
+			<&cru SCLK_VDEC_CABAC>, <&cru SCLK_VDEC_CORE>;
+		clock-names = "aclk_vcodec", "hclk_vcodec", "clk_cabac",
+			"clk_core";
+		resets = <&cru SRST_VDEC_A>, <&cru SRST_VDEC_H>,
+			<&cru SRST_VDEC_NIU_A>, <&cru SRST_VDEC_NIU_H>,
+			<&cru SRST_VDEC_CABAC>, <&cru SRST_VDEC_CORE>;
+		reset-names = "video_a", "video_h", "niu_a", "niu_h",
+			"video_cabac", "video_core";
+		iommus = <&rkvdec_mmu>;
+		power-domains = <&power RK3328_PD_VIDEO>;
+		rockchip,srv = <&rkvdec_srv>;
+		status = "disabled";
+	};
diff --git a/Documentation/devicetree/bindings/video/rockchip_enc.txt b/Documentation/devicetree/bindings/video/rockchip_enc.txt
index 476139b4c5a7..f8bcf6798751 100644
--- a/Documentation/devicetree/bindings/video/rockchip_enc.txt
+++ b/Documentation/devicetree/bindings/video/rockchip_enc.txt
@@ -2,27 +2,45 @@ Device-Tree bindings for Rockchip Encoder.
 
 Required properties:
 - compatible: There are several encoder IP inside rockchip chips. The value
-	should be one of "rockchip,rkvenc", "rockchip,vepu", "rockchip,h265e"
+	should be one of "rockchip,video-encoder-v1", "rockchip,hevc-encoder-v1"
+
+- reg: physical base address of the controller and length
+
+- clocks: must include clock specifiers corresponding to entries in the
+        clock-names property.
+
+- clock-names: from common clock binding:
+	       Required elements: "aclk_vcodec", "hclk_vcodec", "clk_cabac",
+		"clk_core".
+
+- resets : a list of phandle + reset specifier pairs
+
+- reset-names : string reset name, must be:
+		"video_a", "video_h", "niu_a", "niu_h", "video_cabac",
+		"video_core".
+
+- power-domains : power-domain property defined with a phandle
+		  to respective power domain.
 
 Example:
 
 DT entry:
-	vepu: vepu@ff340000 {
-		compatible = "rockchip,rk3328-vepu", "rockchip,vepu";
-		rockchip,grf = <&grf>;
-		iommu_enabled = <1>;
-		iommus = <&vepu_mmu>;
-		reg = <0x0 0xff340000 0x0 0x400>;
-		interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
-		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
-		clock-names = "aclk_vcodec", "hclk_vcodec";
-		resets = <&cru SRST_RKVENC_H264_H>,
-			<&cru SRST_RKVENC_H264_A>;
-		reset-names = "video_h", "video_a";
-		rockchip,srv = <&venc_srv>;
-		mode_bit = <11>;
-		mode_ctrl = <0x40c>;
-		name = "vepu";
-		allocator = <1>;
+	rkvenc: rkvdec@ff36000 {
+		compatible = "rockchip,video-encoder-v1";
+		reg = <0xff360000 0x400>;
+		interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_dec";
+		clocks = <&cru ACLK_RKVDEC>, <&cru HCLK_RKVDEC>,
+			<&cru SCLK_VDEC_CABAC>, <&cru SCLK_VDEC_CORE>;
+		clock-names = "aclk_vcodec", "hclk_vcodec", "clk_cabac",
+			"clk_core";
+		resets = <&cru SRST_VDEC_A>, <&cru SRST_VDEC_H>,
+			<&cru SRST_VDEC_NIU_A>, <&cru SRST_VDEC_NIU_H>,
+			<&cru SRST_VDEC_CABAC>, <&cru SRST_VDEC_CORE>;
+		reset-names = "video_a", "video_h", "niu_a", "niu_h",
+			"video_cabac", "video_core";
+		iommus = <&rkenc_mmu>;
+		power-domains = <&power RK1108_PD_VIDEO>;
+		rockchip,srv = <&rkvenc_srv>;
 		status = "disabled";
 	};
diff --git a/Documentation/devicetree/bindings/video/rockchip_video_service.txt b/Documentation/devicetree/bindings/video/rockchip_video_service.txt
new file mode 100644
index 000000000000..e3d27054d932
--- /dev/null
+++ b/Documentation/devicetree/bindings/video/rockchip_video_service.txt
@@ -0,0 +1,13 @@
+Device-Tree bindings for Rockchip virtual media service.
+================================
+
+Required properties:
+- compatible: must be "rockchip,mpp-service"
+
+Example:
+
+DT entry:
+	rkvdec_srv: rkvdec-srv {
+		compatible = "rockchip,mpp-service";
+		status = "disabled";
+	};
diff --git a/Documentation/devicetree/bindings/video/rockchip_vpu.txt b/Documentation/devicetree/bindings/video/rockchip_vpu.txt
new file mode 100644
index 000000000000..3e92d8efdb2b
--- /dev/null
+++ b/Documentation/devicetree/bindings/video/rockchip_vpu.txt
@@ -0,0 +1,59 @@
+Device-Tree bindings for Rockchip VPU Encoder/Decoder.
+
+Required properties:
+- compatible: There are several encoder/decoder IP inside rockchip chips.
+	The value should be one of "rockchip,vpu-decoder-v1",
+	"rockchip,vpu-decoder-v2", "rockchip,vpu-decoder-pp-v1",
+	"rockchip,avs-decoder-v1", "rockchip,vpu-encoder-v1",
+	"rockchip,vpu-encoder-v2".
+
+- reg: physical base address of the controller and length
+
+- clocks: must include clock specifiers corresponding to entries in the
+        clock-names property.
+
+- clock-names: from common clock binding:
+	       Required elements: "aclk_vcodec", "hclk_vcodec",	"clk_core".
+
+- resets : a list of phandle + reset specifier pairs
+
+- reset-names : string reset name, must be:
+		"video_a", "video_h", "video_core".
+
+- power-domains : power-domain property defined with a phandle
+		  to respective power domain.
+
+Example:
+
+DT entry:
+	vepu: video-encoder@ff9a0000 {
+		compatible = "rockchip,vpu-encoder-v1";
+		reg = <0x0 0xff9a0000 0x0 0x400>;
+		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_enc";
+		clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		power-domains = <&power RK3288_PD_VIDEO>;
+		resets = <&cru SRST_VCODEC_AXI>, <&cru SRST_VCODEC_AHB>;
+		reset-names = "video_a", "video_h";
+		rockchip,srv = <&vpu_service>;
+		iommus = <&vpu_mmu>;
+		status = "disabled";
+	};
+
+	vdpu: video-decoder@ff9a0400 {
+		compatible = "rockchip,vpu-decoder-pp-v1";
+		reg = <0x0 0xff9a0400 0x0 0x400>;
+		interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_dec";
+		clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		assigned-clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
+		assigned-clock-rates = <300000000>, <75000000>;
+		power-domains = <&power RK3288_PD_VIDEO>;
+		resets = <&cru SRST_VCODEC_AXI>, <&cru SRST_VCODEC_AHB>;
+		reset-names = "video_a", "video_h";
+		rockchip,srv = <&vpu_service>;
+		iommus = <&vpu_mmu>;
+		status = "disabled";
+	};

From cc41aafc148fca8eee0eeb29a71821e32711188f Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Tue, 31 Oct 2017 17:09:00 +0800
Subject: [PATCH] video: rockchip/mpp_device: new common device design

--------------    ---------------    ------------------
|            |    |             |    | mpp device     |
| mpp device |<-->| mpp service |<-->|  implementation|
|    top     |    |             |    |  and buttom    |
--------------    ---------------    ------------------

The mpp common device will do the top part, but still allow
the mpp device implementation change the default behaviour.

The mpp device implementation will register itself to the mpp
device framework. But the mpp common device is the base
class not the top class. The  mpp common device framework
also in charge of the communication with mpp service.

The clocks and power are all moved into the runtime power
domain management, we don't need to assign the clocks
in the driver but leaves those work to the rockchip power
domain and common driver, we just need to configure the clocks
in our device node.

The link mode will be regard as a bundle of tasks.

The functions with rockchip_mpp_* prefix are used
internal for the task operation.

This device mode is not just suitable for the video IP but
also IEP I think.

I now make the mpp common device become a module and
a different mpp device implementation will be module as well.

The iommu and video acceleration can work independently.

Change-Id: I97dd4eaf20a925f820133a6cb2d954fb97367cb3
Signed-off-by: Randy Li <randy.li@rock-chips.com>
Signed-off-by: ayaka <ayaka@soulik.info>
---
 drivers/video/rockchip/vpu/Kconfig                |    5 +-
 drivers/video/rockchip/vpu/Makefile               |    9 +-
 drivers/video/rockchip/vpu/mpp_debug.h            |   87 +
 drivers/video/rockchip/vpu/mpp_dev_common.c       | 1419 +++++++-------
 drivers/video/rockchip/vpu/mpp_dev_common.h       |  358 ++--
 drivers/video/rockchip/vpu/mpp_dev_h265e.c        | 2148 ---------------------
 drivers/video/rockchip/vpu/mpp_dev_h265e.h        |  155 --
 drivers/video/rockchip/vpu/mpp_dev_h265e_define.h |  759 --------
 drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h    |  235 ---
 drivers/video/rockchip/vpu/mpp_dev_rkvenc.c       |  813 --------
 drivers/video/rockchip/vpu/mpp_dev_rkvenc.h       |  177 --
 drivers/video/rockchip/vpu/mpp_iommu_dma.c        |  297 +++
 drivers/video/rockchip/vpu/mpp_iommu_dma.h        |   37 +
 drivers/video/rockchip/vpu/mpp_service.h          |    1 +
 drivers/video/rockchip/vpu/vpu_iommu_drm.c        |  936 ---------
 drivers/video/rockchip/vpu/vpu_iommu_ion.c        |  410 ----
 drivers/video/rockchip/vpu/vpu_iommu_ops.c        |  291 ---
 drivers/video/rockchip/vpu/vpu_iommu_ops.h        |  139 --
 18 files changed, 1213 insertions(+), 7063 deletions(-)
 create mode 100644 drivers/video/rockchip/vpu/mpp_debug.h
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_h265e.c
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_h265e.h
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_h265e_define.h
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_rkvenc.c
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_rkvenc.h
 create mode 100644 drivers/video/rockchip/vpu/mpp_iommu_dma.c
 create mode 100644 drivers/video/rockchip/vpu/mpp_iommu_dma.h
 delete mode 100644 drivers/video/rockchip/vpu/vpu_iommu_drm.c
 delete mode 100644 drivers/video/rockchip/vpu/vpu_iommu_ion.c
 delete mode 100644 drivers/video/rockchip/vpu/vpu_iommu_ops.c
 delete mode 100644 drivers/video/rockchip/vpu/vpu_iommu_ops.h

diff --git a/drivers/video/rockchip/vpu/Kconfig b/drivers/video/rockchip/vpu/Kconfig
index 8a0c459c9f3c..d1ceffdeac61 100644
--- a/drivers/video/rockchip/vpu/Kconfig
+++ b/drivers/video/rockchip/vpu/Kconfig
@@ -3,16 +3,15 @@ menu "ROCKCHIP_MPP"
 	depends on ARCH_ROCKCHIP
 
 config ROCKCHIP_MPP_SERVICE
-	tristate "ROCKCHIP MPP SERVICE driver"
+	tristate "mpp service scheduler"
 	default n
 	help
 	  rockchip mpp service.
 
 config ROCKCHIP_MPP_DEVICE
-	tristate "ROCKCHIP MPP DEVICE driver"
+	tristate "mpp device framework"
 	depends on ROCKCHIP_MPP_SERVICE
 	default n
 	help
 	  rockchip mpp module.
-
 endmenu
diff --git a/drivers/video/rockchip/vpu/Makefile b/drivers/video/rockchip/vpu/Makefile
index 40a0a0df083e..d6b3b3956b16 100644
--- a/drivers/video/rockchip/vpu/Makefile
+++ b/drivers/video/rockchip/vpu/Makefile
@@ -1,5 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += mpp_service.o
-obj-$(CONFIG_ROCKCHIP_MPP_DEVICE) += mpp_dev_rkvenc.o mpp_dev_vepu.o \
-	mpp_dev_h265e.o mpp_dev_common.o vpu_iommu_drm.o vpu_iommu_ion.o \
-	vpu_iommu_ops.o
+rk-mpp-service-objs := mpp_service.o
+rk-mpp-device-objs := mpp_dev_common.o mpp_iommu_dma.o
+
+obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += rk-mpp-service.o
+obj-$(CONFIG_ROCKCHIP_MPP_DEVICE) += rk-mpp-device.o
diff --git a/drivers/video/rockchip/vpu/mpp_debug.h b/drivers/video/rockchip/vpu/mpp_debug.h
new file mode 100644
index 000000000000..bd6c0e594da3
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_debug.h
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2016 - 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _ROCKCHIP_MPP_DEBUG_H_
+#define _ROCKCHIP_MPP_DEBUG_H_
+
+#include <linux/types.h>
+
+/*
+ * debug flag usage:
+ * +------+-------------------+
+ * | 8bit |      24bit        |
+ * +------+-------------------+
+ *  0~23 bit is for different information type
+ * 24~31 bit is for information print format
+ */
+
+#define DEBUG_POWER				0x00000001
+#define DEBUG_CLOCK				0x00000002
+#define DEBUG_IRQ_STATUS			0x00000004
+#define DEBUG_IOMMU				0x00000008
+#define DEBUG_IOCTL				0x00000010
+#define DEBUG_FUNCTION				0x00000020
+#define DEBUG_REGISTER				0x00000040
+#define DEBUG_EXTRA_INFO			0x00000080
+#define DEBUG_TIMING				0x00000100
+#define DEBUG_TASK_INFO				0x00000200
+#define DEBUG_DUMP_ERR_REG			0x00000400
+#define DEBUG_LINK_TABLE			0x00000800
+
+#define DEBUG_SET_REG				0x00001000
+#define DEBUG_GET_REG				0x00002000
+#define DEBUG_PPS_FILL				0x00004000
+#define DEBUG_IRQ_CHECK				0x00008000
+#define DEBUG_CACHE_32B				0x00010000
+
+#define DEBUG_RESET				0x00020000
+
+#define PRINT_FUNCTION				0x80000000
+#define PRINT_LINE				0x40000000
+
+#define mpp_debug_func(type, fmt, args...)			\
+	do {							\
+		if (unlikely(debug & type)) {			\
+			pr_info("%s:%d: " fmt,			\
+				 __func__, __LINE__, ##args);	\
+		}						\
+	} while (0)
+#define mpp_debug(type, fmt, args...)				\
+	do {							\
+		if (unlikely(debug & type)) {			\
+			pr_info(fmt, ##args);			\
+		}						\
+	} while (0)
+
+#define mpp_debug_enter()					\
+	do {							\
+		if (unlikely(debug & DEBUG_FUNCTION)) {		\
+			pr_info("%s:%d: enter\n",		\
+				 __func__, __LINE__);		\
+		}						\
+	} while (0)
+
+#define mpp_debug_leave()					\
+	do {							\
+		if (unlikely(debug & DEBUG_FUNCTION)) {		\
+			pr_info("%s:%d: leave\n",		\
+				 __func__, __LINE__);		\
+		}						\
+	} while (0)
+
+#define mpp_err(fmt, args...)					\
+		pr_err("%s:%d: " fmt, __func__, __LINE__, ##args)
+
+#endif
diff --git a/drivers/video/rockchip/vpu/mpp_dev_common.c b/drivers/video/rockchip/vpu/mpp_dev_common.c
index 2dfdb1a17aec..6d4180217cfa 100644
--- a/drivers/video/rockchip/vpu/mpp_dev_common.c
+++ b/drivers/video/rockchip/vpu/mpp_dev_common.c
@@ -1,7 +1,7 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: chenhengming chm@rock-chips.com
- *	   Alpha Lin, alpha.lin@rock-chips.com
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 - 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *		Randy Li, <ayaka@soulik.info>
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -14,651 +14,633 @@
  *
  */
 
-#include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
 #include <linux/of_irq.h>
+#include <linux/pm_runtime.h>
+#include <linux/poll.h>
 #include <linux/regmap.h>
-#include <linux/reset.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
+#include <video/rk_vpu_service.h>
 
-#include "vpu_iommu_ops.h"
+#include "mpp_debug.h"
 #include "mpp_dev_common.h"
+#include "mpp_iommu_dma.h"
 #include "mpp_service.h"
 
-int mpp_dev_debug;
-module_param(mpp_dev_debug, int, 0644);
-MODULE_PARM_DESC(mpp_dev_debug, "bit switch for mpp_dev debug information");
+#define MPP_TIMEOUT_DELAY		(2000)
 
-static int mpp_bufid_to_iova(struct rockchip_mpp_dev *mpp, const u8 *tbl,
-			     int size, u32 *reg, struct mpp_ctx *ctx)
-{
-	int hdl;
-	int ret = 0;
-	struct mpp_mem_region *mem_region, *n;
-	int i;
-	int offset = 0;
-	int retval = 0;
+#define MPP_SESSION_MAX_DONE_TASK	(20)
 
-	if (!tbl || size <= 0) {
-		mpp_err("input arguments invalidate, table %p, size %d\n",
-			tbl, size);
-		return -1;
-	}
-
-	for (i = 0; i < size; i++) {
-		int usr_fd = reg[tbl[i]] & 0x3FF;
+#ifdef CONFIG_COMPAT
+struct compat_mpp_request {
+	compat_uptr_t req;
+	u32 size;
+};
+#endif
 
-		mpp_debug(DEBUG_IOMMU, "reg[%03d] fd = %d\n", tbl[i], usr_fd);
+static struct class *mpp_device_class;
 
-		/* if userspace do not set the fd at this register, skip */
-		if (usr_fd == 0)
-			continue;
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "bit switch for mpp device debug information");
 
-		offset = reg[tbl[i]] >> 10;
+static void *mpp_fd_to_mem_region(struct rockchip_mpp_dev *mpp_dev,
+				  struct mpp_dma_session *dma, int fd)
+{
+	struct mpp_mem_region *mem_region = NULL;
+	dma_addr_t iova;
 
-		mpp_debug(DEBUG_IOMMU, "pos %3d fd %3d offset %10d\n",
-			  tbl[i], usr_fd, offset);
+	if (fd <= 0 || !dma || !mpp_dev)
+		return ERR_PTR(-EINVAL);
 
-		hdl = vpu_iommu_import(mpp->iommu_info, ctx->session, usr_fd);
-		if (hdl < 0) {
-			mpp_err("import dma-buf from fd %d failed, reg[%d]\n",
-				usr_fd, tbl[i]);
-			retval = hdl;
-			goto fail;
-		}
+	read_lock(&mpp_dev->resource_rwlock);
+	iova = mpp_dma_import_fd(dma, fd);
+	read_unlock(&mpp_dev->resource_rwlock);
+	if (IS_ERR_VALUE(iova)) {
+		mpp_err("can't access dma-buf %d\n", fd);
+		return ERR_PTR(-EINVAL);
+	}
 
-		mem_region = kzalloc(sizeof(*mem_region), GFP_KERNEL);
+	mem_region = kzalloc(sizeof(*mem_region), GFP_KERNEL);
+	if (!mem_region) {
+		read_lock(&mpp_dev->resource_rwlock);
+		mpp_dma_release_fd(dma, fd);
+		read_unlock(&mpp_dev->resource_rwlock);
+		return ERR_PTR(-ENOMEM);
+	}
 
-		if (!mem_region) {
-			vpu_iommu_free(mpp->iommu_info, ctx->session, hdl);
-			retval = -1;
-			goto fail;
-		}
+	mem_region->hdl = (void *)(long)fd;
+	mem_region->iova = iova;
 
-		mem_region->hdl = hdl;
-		mem_region->reg_idx = tbl[i];
+	return mem_region;
+}
 
-		ret = vpu_iommu_map_iommu(mpp->iommu_info, ctx->session,
-					  hdl, (void *)&mem_region->iova,
-					  &mem_region->len);
-
-		if (ret < 0) {
-			mpp_err("reg %d fd %d ion map iommu failed\n",
-				tbl[i], usr_fd);
-			kfree(mem_region);
-			vpu_iommu_free(mpp->iommu_info, ctx->session, hdl);
-			retval = -1;
-			goto fail;
-		}
+static void mpp_session_push_pending(struct mpp_session *session,
+				     struct mpp_task *task)
+{
+	mutex_lock(&session->lock);
+	list_add_tail(&task->session_link, &session->pending);
+	mutex_unlock(&session->lock);
+}
 
-		reg[tbl[i]] = mem_region->iova + offset;
-		INIT_LIST_HEAD(&mem_region->reg_lnk);
-		list_add_tail(&mem_region->reg_lnk, &ctx->mem_region_list);
-	}
+static void mpp_session_push_done(struct mpp_task *task)
+{
+	struct mpp_session *session = NULL;
 
-	return 0;
+	session = task->session;
 
-fail:
-	list_for_each_entry_safe(mem_region, n,
-				 &ctx->mem_region_list, reg_lnk) {
-		vpu_iommu_free(mpp->iommu_info, ctx->session, mem_region->hdl);
-		list_del_init(&mem_region->reg_lnk);
-		kfree(mem_region);
-	}
+	mutex_lock(&session->lock);
+	list_del_init(&task->session_link);
+	mutex_unlock(&session->lock);
 
-	return retval;
+	kfifo_in(&session->done_fifo, &task, 1);
+	wake_up(&session->wait);
 }
 
-int mpp_reg_address_translate(struct rockchip_mpp_dev *mpp,
-			      u32 *reg,
-			      struct mpp_ctx *ctx,
-			      int idx)
+static struct mpp_task *mpp_session_pull_done(struct mpp_session *session)
 {
-	struct mpp_trans_info *trans_info = mpp->variant->trans_info;
-	const u8 *tbl = trans_info[idx].table;
-	int size = trans_info[idx].count;
+	struct mpp_task *task = NULL;
 
-	return mpp_bufid_to_iova(mpp, tbl, size, reg, ctx);
+	if (kfifo_out(&session->done_fifo, &task, 1))
+		return task;
+	return NULL;
 }
 
-void mpp_translate_extra_info(struct mpp_ctx *ctx,
-			      struct extra_info_for_iommu *ext_inf,
-			      u32 *reg)
+static void mpp_dev_sched_irq(struct work_struct *work)
 {
-	if (ext_inf) {
-		int i;
+	struct mpp_task *task = container_of(work, struct mpp_task, work);
+	struct rockchip_mpp_dev *mpp_dev = NULL;
 
-		for (i = 0; i < ext_inf->cnt; i++) {
-			mpp_debug(DEBUG_IOMMU, "reg[%d] + offset %d\n",
-				  ext_inf->elem[i].index,
-				  ext_inf->elem[i].offset);
-			reg[ext_inf->elem[i].index] += ext_inf->elem[i].offset;
-		}
-	}
-}
+	mpp_dev = task->session->mpp;
 
-void mpp_dump_reg(void __iomem *regs, int count)
-{
-	int i;
+	mpp_debug_time_diff(task);
 
-	pr_info("dumping registers:");
+	if (mpp_dev->ops->finish)
+		mpp_dev->ops->finish(mpp_dev, task);
 
-	for (i = 0; i < count; i++)
-		pr_info("reg[%02d]: %08x\n", i, readl_relaxed(regs + i * 4));
+	atomic_dec(&task->session->task_running);
+	/*
+	 * TODO: unlock the reader locker of the device resource locker
+	 * here
+	 */
+	mpp_srv_done(mpp_dev->srv, task);
+	/* Wake up the GET thread */
+	mpp_session_push_done(task);
 }
 
-void mpp_dump_reg_mem(u32 *regs, int count)
+static void *mpp_dev_alloc_task(struct rockchip_mpp_dev *mpp_dev,
+				struct mpp_session *session, void __user *src,
+				u32 size)
 {
-	int i;
-
-	pr_info("Dumping mpp_service registers:\n");
-
-	for (i = 0; i < count; i++)
-		pr_info("reg[%03d]: %08x\n", i, regs[i]);
+	if (mpp_dev->ops->alloc_task)
+		return mpp_dev->ops->alloc_task(session, src, size);
+	return NULL;
 }
 
-int mpp_dev_common_ctx_init(struct rockchip_mpp_dev *mpp, struct mpp_ctx *cfg)
+static int mpp_dev_free_task(struct mpp_session *session, struct mpp_task *task)
 {
-	INIT_LIST_HEAD(&cfg->session_link);
-	INIT_LIST_HEAD(&cfg->status_link);
-	INIT_LIST_HEAD(&cfg->mem_region_list);
+	struct rockchip_mpp_dev *mpp_dev = session->mpp;
 
+	if (mpp_dev->ops->free_task)
+		mpp_dev->ops->free_task(session, task);
 	return 0;
 }
 
-struct mpp_request {
-	u32 *req;
-	u32 size;
-};
+struct mpp_mem_region *mpp_dev_task_attach_fd(struct mpp_task *task, int fd)
+{
+	struct mpp_mem_region *mem_region = NULL;
 
-#ifdef CONFIG_COMPAT
-struct compat_mpp_request {
-	compat_uptr_t req;
-	u32 size;
-};
-#endif
+	mem_region = mpp_fd_to_mem_region(task->session->mpp,
+					  task->session->dma, fd);
+	if (IS_ERR(mem_region))
+		return mem_region;
 
-#define MPP_TIMEOUT_DELAY		(2 * HZ)
-#define MPP_POWER_OFF_DELAY		(4 * HZ)
+	INIT_LIST_HEAD(&mem_region->reg_lnk);
+	list_add_tail(&mem_region->reg_lnk, &task->mem_region_list);
 
-static void mpp_dev_session_clear(struct rockchip_mpp_dev *mpp,
-				  struct mpp_session *session)
+	return mem_region;
+}
+EXPORT_SYMBOL(mpp_dev_task_attach_fd);
+
+int mpp_reg_address_translate(struct rockchip_mpp_dev *mpp,
+			      struct mpp_task *task, int fmt, u32 *reg)
 {
-	struct mpp_ctx *ctx, *n;
+	struct mpp_trans_info *trans_info = mpp->variant->trans_info;
+	const u8 *tbl = trans_info[fmt].table;
+	int size = trans_info[fmt].count;
+	int i;
 
-	list_for_each_entry_safe(ctx, n, &session->done, session_link) {
-		mpp_dev_common_ctx_deinit(mpp, ctx);
+	mpp_debug_enter();
+	for (i = 0; i < size; i++) {
+		struct mpp_mem_region *mem_region = NULL;
+		int usr_fd = reg[tbl[i]] & 0x3FF;
+		int offset = reg[tbl[i]] >> 10;
+
+		if (usr_fd == 0)
+			continue;
+
+		mem_region = mpp_dev_task_attach_fd(task, usr_fd);
+		if (IS_ERR(mem_region)) {
+			mpp_debug(DEBUG_IOMMU, "reg[%3d]: %08x failed\n",
+				  tbl[i], reg[tbl[i]]);
+			return PTR_ERR(mem_region);
+		}
+
+		mem_region->reg_idx = tbl[i];
+		mpp_debug(DEBUG_IOMMU, "reg[%3d]: %3d => %pad + offset %10d\n",
+			  tbl[i], usr_fd, &mem_region->iova, offset);
+		reg[tbl[i]] = mem_region->iova + offset;
 	}
+
+	mpp_debug_leave();
+
+	return 0;
 }
+EXPORT_SYMBOL(mpp_reg_address_translate);
 
-static struct mpp_ctx *ctx_init(struct rockchip_mpp_dev *mpp,
-				struct mpp_session *session,
-				void __user *src, u32 size)
+void mpp_translate_extra_info(struct mpp_task *task,
+			      struct extra_info_for_iommu *ext_inf,
+			      u32 *reg)
 {
-	struct mpp_ctx *ctx;
-
 	mpp_debug_enter();
+	if (ext_inf) {
+		int i;
 
-	if (mpp->ops->init)
-		ctx = mpp->ops->init(mpp, session, src, size);
-	else
-		ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+		if (ext_inf->magic != EXTRA_INFO_MAGIC)
+			return;
 
-	if (!ctx)
-		return NULL;
+		for (i = 0; i < ext_inf->cnt; i++) {
+			mpp_debug(DEBUG_IOMMU, "reg[%d] + offset %d\n",
+				  ext_inf->elem[i].index,
+				  ext_inf->elem[i].offset);
+			reg[ext_inf->elem[i].index] += ext_inf->elem[i].offset;
+		}
+	}
+	mpp_debug_leave();
+}
+EXPORT_SYMBOL(mpp_translate_extra_info);
 
-	ctx->session = session;
-	ctx->mpp = mpp;
+int mpp_dev_task_init(struct mpp_session *session, struct mpp_task *task)
+{
+	INIT_LIST_HEAD(&task->session_link);
+	INIT_LIST_HEAD(&task->service_link);
+	INIT_LIST_HEAD(&task->mem_region_list);
+	INIT_WORK(&task->work, mpp_dev_sched_irq);
 
-	mpp_srv_pending_locked(mpp->srv, ctx);
+	task->session = session;
 
-	mpp_debug_leave();
+	return 0;
+}
+EXPORT_SYMBOL(mpp_dev_task_init);
+
+void mpp_dev_task_finish(struct mpp_session *session, struct mpp_task *task)
+{
+	struct rockchip_mpp_dev *mpp_dev = NULL;
 
-	return ctx;
+	mpp_dev = session->mpp;
+	queue_work(mpp_dev->irq_workq, &task->work);
 }
+EXPORT_SYMBOL(mpp_dev_task_finish);
 
-void mpp_dev_common_ctx_deinit(struct rockchip_mpp_dev *mpp,
-			       struct mpp_ctx *ctx)
+void mpp_dev_task_finalize(struct mpp_session *session, struct mpp_task *task)
 {
+	struct rockchip_mpp_dev *mpp_dev = NULL;
 	struct mpp_mem_region *mem_region = NULL, *n;
 
-	list_del_init(&ctx->session_link);
-	list_del_init(&ctx->status_link);
-
+	mpp_dev = session->mpp;
 	/* release memory region attach to this registers table. */
 	list_for_each_entry_safe(mem_region, n,
-				 &ctx->mem_region_list, reg_lnk) {
-		vpu_iommu_unmap_iommu(mpp->iommu_info, ctx->session,
-				      mem_region->hdl);
-		vpu_iommu_free(mpp->iommu_info, ctx->session, mem_region->hdl);
+				 &task->mem_region_list, reg_lnk) {
+		read_lock(&mpp_dev->resource_rwlock);
+		mpp_dma_release_fd(session->dma, (long)mem_region->hdl);
+		read_unlock(&mpp_dev->resource_rwlock);
 		list_del_init(&mem_region->reg_lnk);
 		kfree(mem_region);
 	}
-
-	kfree(ctx);
-}
-
-static inline void mpp_queue_power_off_work(struct rockchip_mpp_dev *mpp)
-{
-	queue_delayed_work(system_wq, &mpp->power_off_work,
-			   MPP_POWER_OFF_DELAY);
 }
+EXPORT_SYMBOL(mpp_dev_task_finalize);
 
-static void mpp_power_off_work(struct work_struct *work_s)
+static void mpp_dev_session_clear(struct rockchip_mpp_dev *mpp,
+				  struct mpp_session *session)
 {
-	struct delayed_work *dlwork = container_of(work_s,
-						   struct delayed_work, work);
-	struct rockchip_mpp_dev *mpp =
-				       container_of(dlwork,
-						    struct rockchip_mpp_dev,
-						    power_off_work);
+	struct mpp_task *task, *n;
 
-	if (mutex_trylock(&mpp->srv->lock)) {
-		mpp_dev_power_off(mpp);
-		mutex_unlock(&mpp->srv->lock);
-	} else {
-		/* Come back later if the device is busy... */
-		mpp_queue_power_off_work(mpp);
+	list_for_each_entry_safe(task, n, &session->pending, session_link) {
+		list_del(&task->session_link);
+		mpp_dev_free_task(session, task);
 	}
+	while (kfifo_out(&session->done_fifo, &task, 1))
+		mpp_dev_free_task(session, task);
 }
 
-static void mpp_dev_reset(struct rockchip_mpp_dev *mpp)
+static void mpp_dev_reset(struct rockchip_mpp_dev *mpp_dev)
 {
 	mpp_debug_enter();
 
-	atomic_set(&mpp->reset_request, 0);
-
-	mpp->variant->reset(mpp);
+	/* FIXME lock resource lock of the other devices in combo */
+	write_lock(&mpp_dev->resource_rwlock);
+	atomic_set(&mpp_dev->reset_request, 0);
 
-	if (!mpp->iommu_enable)
-		return;
-
-	if (test_bit(MMU_ACTIVATED, &mpp->state)) {
-		if (atomic_read(&mpp->enabled))
-			vpu_iommu_detach(mpp->iommu_info);
-		else
-			WARN_ON(!atomic_read(&mpp->enabled));
-
-		vpu_iommu_attach(mpp->iommu_info);
-	}
+	mpp_iommu_detach(mpp_dev->iommu_info);
+	mpp_dev->ops->reset(mpp_dev);
+	mpp_iommu_attach(mpp_dev->iommu_info);
 
+	write_unlock(&mpp_dev->resource_rwlock);
 	mpp_debug_leave();
 }
 
-void mpp_dev_power_on(struct rockchip_mpp_dev *mpp)
+static void mpp_dev_abort(struct rockchip_mpp_dev *mpp_dev)
 {
-	int ret;
-	ktime_t now = ktime_get();
-
-	if (ktime_to_ns(ktime_sub(now, mpp->last)) > NSEC_PER_SEC) {
-		cancel_delayed_work_sync(&mpp->power_off_work);
-		mpp_queue_power_off_work(mpp);
-		mpp->last = now;
-	}
-	ret = atomic_add_unless(&mpp->enabled, 1, 1);
-	if (!ret)
-		return;
+	int ret = 0;
 
-	pr_info("%s: power on\n", dev_name(mpp->dev));
+	mpp_debug_enter();
 
-	mpp->variant->power_on(mpp);
-	if (mpp->iommu_enable) {
-		set_bit(MMU_ACTIVATED, &mpp->state);
-		vpu_iommu_attach(mpp->iommu_info);
-	}
-	atomic_add(1, &mpp->power_on_cnt);
-	wake_lock(&mpp->wake_lock);
-}
+	/* destroy the current task after hardware reset */
+	ret = mpp_srv_is_running(mpp_dev->srv);
 
-void mpp_dev_power_off(struct rockchip_mpp_dev *mpp)
-{
-	int total_running;
-	int ret = atomic_add_unless(&mpp->enabled, -1, 0);
-
-	if (!ret)
-		return;
-
-	total_running = atomic_read(&mpp->total_running);
-	if (total_running) {
-		pr_alert("alert: power off when %d task running!!\n",
-			 total_running);
-		mdelay(50);
-		pr_alert("alert: delay 50 ms for running task\n");
-	}
-
-	pr_info("%s: power off...", dev_name(mpp->dev));
+	mpp_dev_reset(mpp_dev);
 
-	if (mpp->iommu_enable) {
-		clear_bit(MMU_ACTIVATED, &mpp->state);
-		vpu_iommu_detach(mpp->iommu_info);
+	if (ret) {
+		struct mpp_task *task = NULL;
+
+		task = mpp_srv_get_cur_task(mpp_dev->srv);
+		cancel_work_sync(&task->work);
+		list_del(&task->session_link);
+		mpp_srv_abort(mpp_dev->srv, task);
+		mpp_dev_free_task(task->session, task);
+		atomic_dec(&task->session->task_running);
+	} else {
+		mpp_srv_abort(mpp_dev->srv, NULL);
 	}
-	mpp->variant->power_off(mpp);
 
-	atomic_add(1, &mpp->power_off_cnt);
-	wake_unlock(&mpp->wake_lock);
-	pr_info("done\n");
+	mpp_debug_leave();
 }
 
-bool mpp_dev_is_power_on(struct rockchip_mpp_dev *mpp)
+void mpp_dev_power_on(struct rockchip_mpp_dev *mpp_dev)
 {
-	return !!atomic_read(&mpp->enabled);
+	pm_runtime_get_sync(mpp_dev->dev);
+	pm_stay_awake(mpp_dev->dev);
 }
 
-static void rockchip_mpp_run(struct rockchip_mpp_dev *mpp)
+void mpp_dev_power_off(struct rockchip_mpp_dev *mpp_dev)
 {
-	struct mpp_ctx *ctx;
+	pm_runtime_put_sync(mpp_dev->dev);
+	pm_relax(mpp_dev->dev);
+}
 
+static void rockchip_mpp_run(struct rockchip_mpp_dev *mpp_dev,
+			     struct mpp_task *task)
+{
 	mpp_debug_enter();
+	/*
+	 * As I got the global lock from the mpp service here,
+	 * I am the very task to be run, the device is ready
+	 * for me. Wait a gap in the other is operating with the IOMMU.
+	 */
+	if (atomic_read(&mpp_dev->reset_request))
+		mpp_dev_reset(mpp_dev);
 
-	mpp_srv_run(mpp->srv);
-
-	ctx = mpp_srv_get_last_running_ctx(mpp->srv);
-	mpp_time_record(ctx);
-
-	mpp_dev_power_on(mpp);
+	mpp_debug_time_record(task);
 
 	mpp_debug(DEBUG_TASK_INFO, "pid %d, start hw %s\n",
-		  ctx->session->pid, dev_name(mpp->dev));
-
-	if (atomic_read(&mpp->reset_request))
-		mpp_dev_reset(mpp);
+		  task->session->pid, dev_name(mpp_dev->dev));
 
-	if (unlikely(mpp_dev_debug & DEBUG_REGISTER))
-		mpp_dump_reg(mpp->reg_base, mpp->variant->reg_len);
+	if (unlikely(debug & DEBUG_REGISTER))
+		mpp_debug_dump_reg(mpp_dev->reg_base,
+				   mpp_dev->variant->reg_len);
 
-	atomic_add(1, &mpp->total_running);
-	if (mpp->ops->run)
-		mpp->ops->run(mpp);
+	/*
+	 * TODO: Lock the reader locker of the device resource lock here,
+	 * release at the finish operation
+	 */
+	if (mpp_dev->ops->run)
+		mpp_dev->ops->run(mpp_dev, task);
 
 	mpp_debug_leave();
 }
 
-static void rockchip_mpp_try_run(struct rockchip_mpp_dev *mpp)
+static void rockchip_mpp_try_run(struct rockchip_mpp_dev *mpp_dev)
 {
 	int ret = 0;
-	struct rockchip_mpp_dev *pending;
-	struct mpp_ctx *ctx;
+	struct mpp_task *task;
 
 	mpp_debug_enter();
 
-	if (!mpp_srv_pending_is_empty(mpp->srv)) {
-		/*
-		 * if prepare func in hw driver define, state will be determined
-		 * by hw driver prepare func, or state will be determined by
-		 * service. ret = 0, run ready ctx.
-		 */
-		ctx = mpp_srv_get_pending_ctx(mpp->srv);
-		pending = ctx->mpp;
-		if (mpp->ops->prepare)
-			ret = mpp->ops->prepare(pending);
-		else if (mpp_srv_is_running(mpp->srv))
-			ret = -1;
-
-		if (ret == 0)
-			rockchip_mpp_run(pending);
-	}
+	task = mpp_srv_get_pending_task(mpp_dev->srv);
+	/*
+	 * In the link table mode, the prepare function of the device
+	 * will check whether I can insert a new task into device.
+	 * If the device supports the task status query(like the HEVC
+	 * encoder), it can report whether the device is busy.
+	 * If the device doesn't support multiple task or task status
+	 * query, leave this job to mpp service.
+	 */
+	if (mpp_dev->ops->prepare)
+		ret = mpp_dev->ops->prepare(mpp_dev, task);
+	if (ret == -EINVAL)
+		mpp_srv_wait_to_run(mpp_dev->srv, task);
+	/*
+	 * FIXME if the hardware supports task query, but we still need to lock
+	 * the running list and lock the mpp service in the current state.
+	 */
+	/* Push a pending task to running queue */
+	rockchip_mpp_run(mpp_dev, task);
 
 	mpp_debug_leave();
 }
 
-static int rockchip_mpp_result(struct rockchip_mpp_dev *mpp,
-			       struct mpp_ctx *ctx, u32 __user *dst)
+static int rockchip_mpp_result(struct rockchip_mpp_dev *mpp_dev,
+			       struct mpp_task *task, u32 __user *dst, u32 size)
 {
 	mpp_debug_enter();
 
-	if (mpp->ops->result)
-		mpp->ops->result(mpp, ctx, dst);
+	if (!mpp_dev || !task)
+		return -EINVAL;
 
-	mpp_dev_common_ctx_deinit(mpp, ctx);
+	if (mpp_dev->ops->result)
+		mpp_dev->ops->result(mpp_dev, task, dst, size);
+
+	mpp_dev_free_task(task->session, task);
 
 	mpp_debug_leave();
 	return 0;
 }
 
-static int mpp_dev_wait_result(struct mpp_session *session,
-			       struct rockchip_mpp_dev *mpp,
-			       u32 __user *req)
+static int rockchip_mpp_wait_result(struct mpp_session *session,
+				    struct rockchip_mpp_dev *mpp,
+				    struct vpu_request req)
 {
-	struct mpp_ctx *ctx;
+	struct mpp_task *task;
 	int ret;
 
 	ret = wait_event_timeout(session->wait,
-				 !list_empty(&session->done),
-				 MPP_TIMEOUT_DELAY);
-
-	if (!list_empty(&session->done)) {
-		if (ret < 0)
-			mpp_err("warning: pid %d wait task error ret %d\n",
-				session->pid, ret);
-		ret = 0;
-	} else {
-		if (unlikely(ret < 0)) {
-			mpp_err("error: pid %d wait task ret %d\n",
-				session->pid, ret);
-		} else if (ret == 0) {
-			mpp_err("error: pid %d wait %d task done timeout\n",
-				session->pid,
-				atomic_read(&session->task_running));
-			ret = -ETIMEDOUT;
-
-			mpp_dump_reg(mpp->reg_base, mpp->variant->reg_len);
-		}
-	}
-
-	if (ret < 0) {
-		mpp_srv_lock(mpp->srv);
-		atomic_sub(1, &mpp->total_running);
+				 !kfifo_is_empty(&session->done_fifo),
+				 msecs_to_jiffies(MPP_TIMEOUT_DELAY));
+	if (ret == 0) {
+		mpp_err("error: pid %d wait %d task done timeout\n",
+			session->pid, atomic_read(&session->task_running));
+		ret = -ETIMEDOUT;
+
+		if (unlikely(debug & DEBUG_REGISTER))
+			mpp_debug_dump_reg(mpp->reg_base,
+					   mpp->variant->reg_len);
+		mpp_dev_abort(mpp);
 
-		if (mpp->variant->reset)
-			mpp->variant->reset(mpp);
-		mpp_srv_unlock(mpp->srv);
 		return ret;
 	}
 
-	mpp_srv_lock(mpp->srv);
-	ctx = mpp_srv_get_done_ctx(session);
-	rockchip_mpp_result(mpp, ctx, req);
-	mpp_srv_unlock(mpp->srv);
+	task = mpp_session_pull_done(session);
+	rockchip_mpp_result(mpp, task, req.req, req.size);
 
 	return 0;
 }
 
-static long mpp_dev_ioctl(struct file *filp, unsigned int cmd,
-			  unsigned long arg)
+long mpp_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
 {
-	struct rockchip_mpp_dev *mpp =
-			container_of(filp->f_path.dentry->d_inode->i_cdev,
-				     struct rockchip_mpp_dev,
-				     cdev);
 	struct mpp_session *session = (struct mpp_session *)filp->private_data;
+	struct rockchip_mpp_dev *mpp = NULL;
 
 	mpp_debug_enter();
 	if (!session)
 		return -EINVAL;
 
+	mpp = session->mpp;
+
 	switch (cmd) {
-	case MPP_IOC_SET_CLIENT_TYPE:
+	case VPU_IOC_SET_CLIENT_TYPE:
 		break;
-	case MPP_IOC_SET_REG:
-		{
-			struct mpp_request req;
-			struct mpp_ctx *ctx;
-
-			mpp_debug(DEBUG_IOCTL, "pid %d set reg\n",
-				  session->pid);
-			if (copy_from_user(&req, (void __user *)arg,
-					   sizeof(struct mpp_request))) {
-				mpp_err("error: set reg copy_from_user failed\n");
-				return -EFAULT;
-			}
-			ctx = ctx_init(mpp, session, (void __user *)req.req,
-				       req.size);
-			if (!ctx)
-				return -EFAULT;
-
-			mpp_srv_lock(mpp->srv);
-			rockchip_mpp_try_run(mpp);
-			mpp_srv_unlock(mpp->srv);
+	case VPU_IOC_SET_REG: {
+		struct vpu_request req;
+		struct mpp_task *task;
+
+		mpp_debug(DEBUG_IOCTL, "pid %d set reg\n",
+			  session->pid);
+		if (copy_from_user(&req, (void __user *)arg,
+				   sizeof(struct vpu_request))) {
+			mpp_err("error: set reg copy_from_user failed\n");
+			return -EFAULT;
 		}
-		break;
-	case MPP_IOC_GET_REG:
-		{
-			struct mpp_request req;
-
-			mpp_debug(DEBUG_IOCTL, "pid %d get reg\n",
-				  session->pid);
-			if (copy_from_user(&req, (void __user *)arg,
-					   sizeof(struct mpp_request))) {
-				mpp_err("error: get reg copy_from_user failed\n");
-				return -EFAULT;
-			}
-
-			return mpp_dev_wait_result(session, mpp, req.req);
+		task = mpp_dev_alloc_task(mpp, session, (void __user *)req.req,
+					  req.size);
+		if (IS_ERR_OR_NULL(task))
+			return -EFAULT;
+		mpp_srv_push_pending(mpp->srv, task);
+		mpp_session_push_pending(session, task);
+		atomic_inc(&session->task_running);
+
+		/* TODO: processing the current task */
+		rockchip_mpp_try_run(mpp);
+	} break;
+	case VPU_IOC_GET_REG: {
+		struct vpu_request req;
+
+		mpp_debug(DEBUG_IOCTL, "pid %d get reg\n",
+			  session->pid);
+		if (copy_from_user(&req, (void __user *)arg,
+				   sizeof(struct vpu_request))) {
+			mpp_err("error: get reg copy_from_user failed\n");
+			return -EFAULT;
 		}
-		break;
-	case MPP_IOC_PROBE_IOMMU_STATUS:
-		{
-			int iommu_enable = 1;
 
-			mpp_debug(DEBUG_IOCTL, "VPU_IOC_PROBE_IOMMU_STATUS\n");
+		return rockchip_mpp_wait_result(session, mpp, req);
+	} break;
+	case VPU_IOC_PROBE_IOMMU_STATUS: {
+		int iommu_enable = 1;
 
-			if (copy_to_user((void __user *)arg,
-					 &iommu_enable, sizeof(int))) {
-				mpp_err("error: iommu status copy_to_user failed\n");
-				return -EFAULT;
-			}
-		}
-		break;
-	default:
-		{
-			if (mpp->ops->ioctl)
-				return mpp->ops->ioctl(session, cmd, arg);
+		mpp_debug(DEBUG_IOCTL, "VPU_IOC_PROBE_IOMMU_STATUS\n");
 
-			mpp_err("unknown mpp ioctl cmd %x\n", cmd);
+		if (put_user(iommu_enable, ((u32 __user *)arg))) {
+			mpp_err("error: iommu status copy_to_user failed\n");
+			return -EFAULT;
 		}
 		break;
 	}
+	default: {
+		dev_err(mpp->dev, "unknown mpp ioctl cmd %x\n", cmd);
+		return -ENOIOCTLCMD;
+	} break;
+	}
 
 	mpp_debug_leave();
 	return 0;
 }
+EXPORT_SYMBOL(mpp_dev_ioctl);
 
-#ifdef CONFIG_COMPAT
-static long compat_mpp_dev_ioctl(struct file *filp, unsigned int cmd,
-				 unsigned long arg)
+static unsigned int mpp_dev_poll(struct file *filp, poll_table *wait)
 {
-	struct rockchip_mpp_dev *mpp =
-			container_of(filp->f_path.dentry->d_inode->i_cdev,
-				     struct rockchip_mpp_dev, cdev);
 	struct mpp_session *session = (struct mpp_session *)filp->private_data;
+	unsigned int mask = 0;
 
-	mpp_debug_enter();
+	poll_wait(filp, &session->wait, wait);
+	if (kfifo_len(&session->done_fifo))
+		mask |= POLLIN | POLLRDNORM;
 
-	if (!session)
-		return -EINVAL;
+	return mask;
+}
+
+#ifdef CONFIG_COMPAT
+
+#define VPU_IOC_SET_CLIENT_TYPE32          _IOW(VPU_IOC_MAGIC, 1, u32)
+#define VPU_IOC_GET_HW_FUSE_STATUS32       _IOW(VPU_IOC_MAGIC, 2, \
+						compat_ulong_t)
+#define VPU_IOC_SET_REG32                  _IOW(VPU_IOC_MAGIC, 3, \
+						compat_ulong_t)
+#define VPU_IOC_GET_REG32                  _IOW(VPU_IOC_MAGIC, 4, \
+						compat_ulong_t)
+#define VPU_IOC_PROBE_IOMMU_STATUS32       _IOR(VPU_IOC_MAGIC, 5, u32)
 
+static long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long ret = -ENOIOCTLCMD;
+
+	if (file->f_op->unlocked_ioctl)
+		ret = file->f_op->unlocked_ioctl(file, cmd, arg);
+
+	return ret;
+}
+
+long mpp_dev_compat_ioctl(struct file *file, unsigned int cmd,
+			  unsigned long arg)
+{
+	struct vpu_request req;
+	void __user *up = compat_ptr(arg);
+	int compatible_arg = 1;
+	long err = 0;
+
+	mpp_debug_enter();
+	mpp_debug(DEBUG_IOCTL, "cmd %x, VPU_IOC_SET_CLIENT_TYPE32 %x\n", cmd,
+		  (u32)VPU_IOC_SET_CLIENT_TYPE32);
+	/* First, convert the command. */
 	switch (cmd) {
-	case MPP_IOC_SET_CLIENT_TYPE:
+	case VPU_IOC_SET_CLIENT_TYPE32:
+		cmd = VPU_IOC_SET_CLIENT_TYPE;
 		break;
-	case MPP_IOC_SET_REG:
-		{
-			struct compat_mpp_request req;
-			struct mpp_ctx *ctx;
-
-			mpp_debug(DEBUG_IOCTL, "compat set reg\n");
-			if (copy_from_user(&req, compat_ptr((compat_uptr_t)arg),
-					   sizeof(struct compat_mpp_request))) {
-				mpp_err("compat set_reg copy_from_user failed\n");
-				return -EFAULT;
-			}
-			ctx = ctx_init(mpp, session,
-				       compat_ptr((compat_uptr_t)req.req),
-				       req.size);
-			if (!ctx)
-				return -EFAULT;
-
-			mpp_srv_lock(mpp->srv);
-			rockchip_mpp_try_run(mpp);
-			mpp_srv_unlock(mpp->srv);
-		}
+	case VPU_IOC_GET_HW_FUSE_STATUS32:
+		cmd = VPU_IOC_GET_HW_FUSE_STATUS;
 		break;
-	case MPP_IOC_GET_REG:
-		{
-			struct compat_mpp_request req;
-
-			mpp_debug(DEBUG_IOCTL, "compat get reg\n");
-			if (copy_from_user(&req, compat_ptr((compat_uptr_t)arg),
-					   sizeof(struct compat_mpp_request))) {
-				mpp_err("compat get reg copy_from_user failed\n");
-				return -EFAULT;
-			}
-
-			return mpp_dev_wait_result(session,
-						   mpp,
-						   compat_ptr((compat_uptr_t)req.req));
-		}
+	case VPU_IOC_SET_REG32:
+		cmd = VPU_IOC_SET_REG;
 		break;
-	case MPP_IOC_PROBE_IOMMU_STATUS:
-		{
-			int iommu_enable = 1;
-
-			mpp_debug(DEBUG_IOCTL, "COMPAT_VPU_IOC_PROBE_IOMMU_STATUS\n");
-
-			if (copy_to_user(compat_ptr((compat_uptr_t)arg),
-					 &iommu_enable, sizeof(int))) {
-				mpp_err("error: VPU_IOC_PROBE_IOMMU_STATUS failed\n");
-				return -EFAULT;
-			}
-		}
+	case VPU_IOC_GET_REG32:
+		cmd = VPU_IOC_GET_REG;
 		break;
-	default:
-		{
-			if (mpp->ops->ioctl)
-				return mpp->ops->ioctl(session, cmd, arg);
-
-			mpp_err("unknown mpp ioctl cmd %x\n", cmd);
-		}
+	case VPU_IOC_PROBE_IOMMU_STATUS32:
+		cmd = VPU_IOC_PROBE_IOMMU_STATUS;
 		break;
 	}
+	switch (cmd) {
+	case VPU_IOC_SET_REG:
+	case VPU_IOC_GET_REG:
+	case VPU_IOC_GET_HW_FUSE_STATUS: {
+		compat_uptr_t req_ptr;
+		struct compat_mpp_request __user *req32 = NULL;
+
+		req32 = (struct compat_mpp_request __user *)up;
+		memset(&req, 0, sizeof(req));
+
+		if (get_user(req_ptr, &req32->req) ||
+		    get_user(req.size, &req32->size)) {
+			mpp_err("error: compat get hw status copy_from_user failed\n");
+			return -EFAULT;
+		}
+		req.req = compat_ptr(req_ptr);
+		compatible_arg = 0;
+	} break;
+	}
+
+	if (compatible_arg) {
+		err = native_ioctl(file, cmd, (unsigned long)up);
+	} else {
+		mm_segment_t old_fs = get_fs();
+
+		set_fs(KERNEL_DS);
+		err = native_ioctl(file, cmd, (unsigned long)&req);
+		set_fs(old_fs);
+	}
+
 	mpp_debug_leave();
-	return 0;
+	return err;
 }
+EXPORT_SYMBOL(mpp_dev_compat_ioctl);
 #endif
 
 static int mpp_dev_open(struct inode *inode, struct file *filp)
 {
-	struct rockchip_mpp_dev *mpp =
-				       container_of(inode->i_cdev,
+	struct rockchip_mpp_dev *mpp = container_of(inode->i_cdev,
 						    struct rockchip_mpp_dev,
-						    cdev);
-	struct mpp_session *session;
+						    mpp_cdev);
+	struct mpp_session *session = NULL;
+	int error = 0;
 
 	mpp_debug_enter();
 
-	if (mpp->ops->open)
-		session = mpp->ops->open(mpp);
-	else
-		session = kzalloc(sizeof(*session), GFP_KERNEL);
-
+	session = kzalloc(sizeof(*session), GFP_KERNEL);
 	if (!session)
 		return -ENOMEM;
 
 	session->pid = current->pid;
 	session->mpp = mpp;
-	INIT_LIST_HEAD(&session->done);
-	INIT_LIST_HEAD(&session->list_session);
+	mutex_init(&session->lock);
+	INIT_LIST_HEAD(&session->pending);
 	init_waitqueue_head(&session->wait);
+	error = kfifo_alloc(&session->done_fifo, MPP_SESSION_MAX_DONE_TASK,
+			    GFP_KERNEL);
+	if (error < 0) {
+		kfree(session);
+		return -ENOMEM;
+	}
+
 	atomic_set(&session->task_running, 0);
-	mpp_srv_lock(mpp->srv);
-	list_add_tail(&session->list_session, &mpp->srv->session);
+	session->dma = mpp_dma_session_create(mpp->dev);
+	INIT_LIST_HEAD(&session->list_session);
 	filp->private_data = (void *)session;
-	mpp_srv_unlock(mpp->srv);
 
+	mpp_dev_power_on(mpp);
 	mpp_debug_leave();
 
 	return nonseekable_open(inode, filp);
@@ -666,10 +648,9 @@ static int mpp_dev_open(struct inode *inode, struct file *filp)
 
 static int mpp_dev_release(struct inode *inode, struct file *filp)
 {
-	struct rockchip_mpp_dev *mpp = container_of(
-						    inode->i_cdev,
+	struct rockchip_mpp_dev *mpp = container_of(inode->i_cdev,
 						    struct rockchip_mpp_dev,
-						    cdev);
+						    mpp_cdev);
 	int task_running;
 	struct mpp_session *session = filp->private_data;
 
@@ -685,403 +666,305 @@ static int mpp_dev_release(struct inode *inode, struct file *filp)
 	}
 	wake_up(&session->wait);
 
-	if (mpp->ops->release)
-		mpp->ops->release(session);
-	mpp_srv_lock(mpp->srv);
 	/* remove this filp from the asynchronusly notified filp's */
-	list_del_init(&session->list_session);
 	mpp_dev_session_clear(mpp, session);
-	vpu_iommu_clear(mpp->iommu_info, session);
+
+	read_lock(&session->mpp->resource_rwlock);
+	mpp_dma_destroy_session(session->dma);
+	read_unlock(&session->mpp->resource_rwlock);
+	kfifo_free(&session->done_fifo);
 	filp->private_data = NULL;
-	mpp_srv_unlock(mpp->srv);
-	if (mpp->ops->free)
-		mpp->ops->free(session);
-	else
-		kfree(session);
 
-	pr_debug("dev closed\n");
+	mpp_dev_power_off(mpp);
+	kfree(session);
+
+	dev_dbg(mpp->dev, "closed\n");
 	mpp_debug_leave();
 	return 0;
 }
 
-static const struct file_operations mpp_dev_fops = {
+static const struct file_operations mpp_dev_default_fops = {
 	.unlocked_ioctl = mpp_dev_ioctl,
 	.open		= mpp_dev_open,
 	.release	= mpp_dev_release,
+	.poll		= mpp_dev_poll,
 #ifdef CONFIG_COMPAT
-	.compat_ioctl   = compat_mpp_dev_ioctl,
+	.compat_ioctl   = mpp_dev_compat_ioctl,
 #endif
 };
 
-static irqreturn_t mpp_irq(int irq, void *dev_id)
+static struct mpp_service_node *mpp_dev_load_srv(struct platform_device *p)
 {
-	struct rockchip_mpp_dev *mpp = dev_id;
-
-	int ret = -1;
+	struct mpp_service *srv = NULL;
+	struct device_node *np = NULL;
+	struct platform_device *pdev = NULL;
+	struct mpp_service_node *client = NULL;
 
-	if (mpp->ops->irq)
-		ret = mpp->ops->irq(mpp);
-
-	if (ret < 0)
-		return IRQ_NONE;
-	else
-		return IRQ_WAKE_THREAD;
-}
-
-static irqreturn_t mpp_isr(int irq, void *dev_id)
-{
-	struct rockchip_mpp_dev *mpp = dev_id;
-	struct mpp_ctx *ctx;
-	int ret = 0;
-
-	ctx = mpp_srv_get_current_ctx(mpp->srv);
-	if (IS_ERR_OR_NULL(ctx)) {
-		mpp_err("no current context present\n");
-		return IRQ_HANDLED;
+	np = of_parse_phandle(p->dev.of_node, "rockchip,srv", 0);
+	if (!np || !of_device_is_available(np)) {
+		dev_err(&p->dev,
+			"failed to get the mpp service node\n");
+		return NULL;
 	}
 
-	mpp_time_diff(ctx);
-	mpp_srv_lock(mpp->srv);
-
-	if (mpp->ops->done)
-		ret = mpp->ops->done(mpp);
+	pdev = of_find_device_by_node(np);
+	if (!pdev) {
+		of_node_put(np);
+		dev_err(&p->dev,
+			"failed to get mpp service from node\n");
+		return ERR_PTR(-ENODEV);
+	}
 
-	if (ret == 0)
-		mpp_srv_done(mpp->srv);
+	device_lock(&pdev->dev);
 
-	atomic_sub(1, &mpp->total_running);
-	rockchip_mpp_try_run(mpp);
+	srv = platform_get_drvdata(pdev);
+	if (srv) {
+		client = mpp_srv_attach(srv, NULL);
+	} else {
+		dev_info(&pdev->dev, "defer probe\n");
+		client = ERR_PTR(-EPROBE_DEFER);
+	}
+	device_unlock(&pdev->dev);
 
-	mpp_srv_unlock(mpp->srv);
+	put_device(&pdev->dev);
+	of_node_put(np);
 
-	return IRQ_HANDLED;
+	return client;
 }
 
-#ifdef CONFIG_IOMMU_API
-static inline void platform_set_sysmmu(struct device *iommu,
-				       struct device *dev)
-{
-	dev->archdata.iommu = iommu;
-}
-#else
-static inline void platform_set_sysmmu(struct device *iommu,
-				       struct device *dev)
+/* The device will do more probing work after this */
+int mpp_dev_common_probe(struct rockchip_mpp_dev *mpp_dev,
+			 struct platform_device *pdev,
+			 struct mpp_dev_ops *ops)
 {
-}
-#endif
+	struct device *dev = NULL;
+	struct resource *res = NULL;
+	int err;
 
-static int mpp_sysmmu_fault_hdl(struct device *dev,
-				enum rk_iommu_inttype itype,
-				unsigned long pgtable_base,
-				unsigned long fault_addr, unsigned int status)
-{
-	struct platform_device *pdev;
-	struct rockchip_mpp_dev *mpp;
-	struct mpp_ctx *ctx;
+	/* Get and register to MPP service */
+	mpp_dev->srv = mpp_dev_load_srv(pdev);
+	if (IS_ERR_OR_NULL(mpp_dev->srv))
+		return PTR_ERR(mpp_dev->srv);
 
-	mpp_debug_enter();
+	dev = &pdev->dev;
+	mpp_dev->dev = dev;
+	mpp_dev->ops = ops;
 
-	if (!dev) {
-		mpp_err("invalid NULL dev\n");
-		return 0;
-	}
+	rwlock_init(&mpp_dev->resource_rwlock);
 
-	pdev = container_of(dev, struct platform_device, dev);
-	if (!pdev) {
-		mpp_err("invalid NULL platform_device\n");
-		return 0;
-	}
+	device_init_wakeup(mpp_dev->dev, true);
+	pm_runtime_enable(dev);
 
-	mpp = platform_get_drvdata(pdev);
-	if (!mpp || !mpp->srv) {
-		mpp_err("invalid mpp_dev or mpp_srv\n");
-		return 0;
+	mpp_dev->irq_workq = alloc_ordered_workqueue("%s_irq_wq",
+						     WQ_MEM_RECLAIM
+						     | WQ_FREEZABLE,
+						     dev_name(mpp_dev->dev));
+	if (!mpp_dev->irq_workq) {
+		dev_err(dev, "failed to create irq workqueue\n");
+		err = -EINVAL;
+		goto failed_irq_workq;
 	}
 
-	ctx = mpp_srv_get_current_ctx(mpp->srv);
-	if (ctx) {
-		struct mpp_mem_region *mem, *n;
-		int i = 0;
-
-		mpp_err("mpp, fault addr 0x%08lx\n", fault_addr);
-		if (!list_empty(&ctx->mem_region_list)) {
-			list_for_each_entry_safe(mem, n, &ctx->mem_region_list,
-						 reg_lnk) {
-				mpp_err("mpp, reg[%02u] mem[%02d] 0x%lx %lx\n",
-					mem->reg_idx, i, mem->iova, mem->len);
-				i++;
-			}
-		} else {
-			mpp_err("no memory region mapped\n");
-		}
-
-		if (ctx->mpp) {
-			struct rockchip_mpp_dev *mpp = ctx->mpp;
+	mpp_dev->irq = platform_get_irq(pdev, 0);
+	if (mpp_dev->irq < 0) {
+		dev_err(dev, "No interrupt resource found\n");
+		err = -ENODEV;
+		goto failed;
+	}
 
-			mpp_err("current errror register set:\n");
-			mpp_dump_reg(mpp->reg_base, mpp->variant->reg_len);
-		}
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "no memory resource defined\n");
+		err = -ENODEV;
+		goto failed;
+	}
+	mpp_dev->reg_base = devm_ioremap_resource(dev, res);
+	if (IS_ERR(mpp_dev->reg_base)) {
+		err = PTR_ERR(mpp_dev->reg_base);
+		goto failed;
+	}
 
-		if (mpp->variant->reset)
-			mpp->variant->reset(mpp);
+	pm_runtime_get_sync(dev);
+	/*
+	 * TODO: here or at the device itself, some device doesn't
+	 * have the iommu, maybe in the device is better.
+	 */
+	mpp_dev->iommu_info = mpp_iommu_probe(dev);
+	if (IS_ERR(mpp_dev->iommu_info)) {
+		dev_err(dev, "failed to attach iommu: %ld\n",
+			PTR_ERR(mpp_dev->iommu_info));
 	}
 
-	mpp_debug_leave();
+	pm_runtime_put(dev);
 
 	return 0;
+
+failed_irq_workq:
+	destroy_workqueue(mpp_dev->irq_workq);
+failed:
+	pm_runtime_disable(dev);
+	return err;
 }
+EXPORT_SYMBOL(mpp_dev_common_probe);
 
-static struct device *rockchip_get_sysmmu_dev(const char *compt)
+/* Remember to set the platform data after this */
+int mpp_dev_register_node(struct rockchip_mpp_dev *mpp_dev,
+			  const char *node_name, const void *fops)
 {
-	struct device_node *dn = NULL;
-	struct platform_device *pd = NULL;
-	struct device *ret = NULL;
+	struct device *dev = mpp_dev->dev;
+	int ret = 0;
 
-	dn = of_find_compatible_node(NULL, NULL, compt);
-	if (!dn) {
-		pr_err("can't find device node %s \r\n", compt);
-		return NULL;
+	/* create a device node */
+	ret = alloc_chrdev_region(&mpp_dev->dev_id, 0, 1, node_name);
+	if (ret) {
+		dev_err(dev, "alloc dev_t failed\n");
+		return ret;
 	}
 
-	pd = of_find_device_by_node(dn);
-	if (!pd) {
-		pr_err("can't find platform device in device node %s\n", compt);
-		return  NULL;
+	if (fops)
+		cdev_init(&mpp_dev->mpp_cdev, fops);
+	else
+		cdev_init(&mpp_dev->mpp_cdev, &mpp_dev_default_fops);
+	mpp_dev->mpp_cdev.owner = THIS_MODULE;
+
+	ret = cdev_add(&mpp_dev->mpp_cdev, mpp_dev->dev_id, 1);
+	if (ret) {
+		unregister_chrdev_region(mpp_dev->dev_id, 1);
+		dev_err(dev, "add device node failed\n");
+		return ret;
 	}
-	ret = &pd->dev;
 
-	return ret;
-}
+	device_create(mpp_device_class, dev, mpp_dev->dev_id, NULL, "%s",
+		      node_name);
 
-#if defined(CONFIG_OF)
-static const struct of_device_id mpp_dev_dt_ids[] = {
-	{ .compatible = "rockchip,rkvenc", .data = &rkvenc_variant, },
-	{ .compatible = "rockchip,vepu", .data = &vepu_variant, },
-	{ .compatible = "rockchip,h265e", .data = &h265e_variant, },
-	{ },
-};
-#endif
+	return 0;
+}
+EXPORT_SYMBOL(mpp_dev_register_node);
 
-static int mpp_dev_probe(struct platform_device *pdev)
+int mpp_dev_common_remove(struct rockchip_mpp_dev *mpp_dev)
 {
-	int ret = 0;
-	struct device *dev = &pdev->dev;
-	char *name = (char *)dev_name(dev);
-	struct device_node *np = pdev->dev.of_node;
-	struct rockchip_mpp_dev *mpp = NULL;
-	const struct of_device_id *match;
-	const struct rockchip_mpp_dev_variant *variant;
-	struct device_node *srv_np, *mmu_np;
-	struct platform_device *srv_pdev;
-	struct resource *res = NULL;
-	struct mpp_session *session;
-	int allocator_type;
-
-	pr_info("probe device %s\n", dev_name(dev));
+	destroy_workqueue(mpp_dev->irq_workq);
 
-	match = of_match_node(mpp_dev_dt_ids, dev->of_node);
-	variant = match->data;
+	device_destroy(mpp_device_class, mpp_dev->dev_id);
+	cdev_del(&mpp_dev->mpp_cdev);
+	unregister_chrdev_region(mpp_dev->dev_id, 1);
 
-	mpp = devm_kzalloc(dev, variant->data_len, GFP_KERNEL);
+	mpp_srv_detach(mpp_dev->srv);
 
-	/* Get service */
-	srv_np = of_parse_phandle(np, "rockchip,srv", 0);
-	srv_pdev = of_find_device_by_node(srv_np);
+	mpp_dev_power_off(mpp_dev);
 
-	mpp->srv = platform_get_drvdata(srv_pdev);
+	device_init_wakeup(mpp_dev->dev, false);
+	pm_runtime_disable(mpp_dev->dev);
 
-	mpp->dev = dev;
-	mpp->state = 0;
-	mpp->variant = variant;
+	return 0;
+}
+EXPORT_SYMBOL(mpp_dev_common_remove);
 
-	wake_lock_init(&mpp->wake_lock, WAKE_LOCK_SUSPEND, "mpp");
-	atomic_set(&mpp->enabled, 0);
-	atomic_set(&mpp->power_on_cnt, 0);
-	atomic_set(&mpp->power_off_cnt, 0);
-	atomic_set(&mpp->total_running, 0);
-	atomic_set(&mpp->reset_request, 0);
+void mpp_debug_dump_reg(void __iomem *regs, int count)
+{
+	int i;
 
-	INIT_DELAYED_WORK(&mpp->power_off_work, mpp_power_off_work);
-	mpp->last.tv64 = 0;
+	pr_info("dumping registers: %p\n", regs);
 
-	of_property_read_string(np, "name", (const char **)&name);
-	of_property_read_u32(np, "iommu_enabled", &mpp->iommu_enable);
+	for (i = 0; i < count; i++)
+		pr_info("reg[%02d]: %08x\n", i, readl_relaxed(regs + i * 4));
+}
+EXPORT_SYMBOL(mpp_debug_dump_reg);
 
-	if (mpp->srv->reg_base == 0) {
-		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-		mpp->reg_base = devm_ioremap_resource(dev, res);
-		if (IS_ERR(mpp->reg_base)) {
-			ret = PTR_ERR(mpp->reg_base);
-			goto err;
-		}
-	} else {
-		mpp->reg_base = mpp->srv->reg_base;
-	}
+void mpp_debug_dump_reg_mem(u32 *regs, int count)
+{
+	int i;
 
-	mpp->irq = platform_get_irq(pdev, 0);
-	if (mpp->irq > 0) {
-		ret = devm_request_threaded_irq(dev, mpp->irq,
-						mpp_irq, mpp_isr,
-						IRQF_SHARED, dev_name(dev),
-						(void *)mpp);
-		if (ret) {
-			dev_err(dev, "error: can't request vepu irq %d\n",
-				mpp->irq);
-			goto err;
-		}
-	} else {
-		dev_info(dev, "No interrupt resource found\n");
-	}
+	pr_info("Dumping registers: %p\n", regs);
 
-	mmu_np = of_parse_phandle(np, "iommus", 0);
-	if (mmu_np) {
-		struct platform_device *pd = NULL;
+	for (i = 0; i < count; i++)
+		pr_info("reg[%03d]: %08x\n", i, regs[i]);
+}
+EXPORT_SYMBOL(mpp_debug_dump_reg_mem);
 
-		pd = of_find_device_by_node(mmu_np);
-		mpp->mmu_dev = &pd->dev;
-		if (!mpp->mmu_dev) {
-			mpp->iommu_enable = false;
-			dev_err(dev, "get iommu dev failed");
-		}
-	} else {
-		mpp->mmu_dev =
-			rockchip_get_sysmmu_dev(mpp->variant->mmu_dev_dts_name);
-		if (mpp->mmu_dev) {
-			platform_set_sysmmu(mpp->mmu_dev, dev);
-			rockchip_iovmm_set_fault_handler(dev,
-							 mpp_sysmmu_fault_hdl);
-		} else {
-			dev_err(dev,
-				"get iommu dev %s failed, set iommu_enable to false\n",
-				mpp->variant->mmu_dev_dts_name);
-			mpp->iommu_enable = false;
-		}
-	}
+void mpp_dev_write_seq(struct rockchip_mpp_dev *mpp_dev, unsigned long offset,
+		       void *buffer, unsigned long count)
+{
+	int i;
 
-	dev_info(dev, "try to get iommu dev %p\n",
-		 mpp->mmu_dev);
+	for (i = 0; i < count; i++) {
+		u32 *cur = (u32 *)buffer;
+		u32 pos = offset + i * 4;
+		u32 j = i + (u32)(offset / 4);
 
-	of_property_read_u32(np, "allocator", &allocator_type);
-	mpp->iommu_info = vpu_iommu_info_create(dev, mpp->mmu_dev,
-						allocator_type);
-	if (IS_ERR(mpp->iommu_info)) {
-		dev_err(dev, "failed to create ion client for mpp ret %ld\n",
-			PTR_ERR(mpp->iommu_info));
+		cur += i;
+		mpp_debug(DEBUG_SET_REG, "write reg[%03d]: %08x\n", j, *cur);
+		iowrite32(*cur, mpp_dev->reg_base + pos);
 	}
+}
+EXPORT_SYMBOL(mpp_dev_write_seq);
 
-	/*
-	 * this session is global session, each dev
-	 * only has one global session, and will be
-	 * release when dev remove
-	 */
-	session = devm_kzalloc(dev, sizeof(*session), GFP_KERNEL);
-
-	if (!session)
-		return -ENOMEM;
-
-	session->mpp = mpp;
-	INIT_LIST_HEAD(&session->done);
-	INIT_LIST_HEAD(&session->list_session);
-	init_waitqueue_head(&session->wait);
-	atomic_set(&session->task_running, 0);
-	/* this first session of each dev is global session */
-	list_add_tail(&session->list_session, &mpp->srv->session);
-
-	ret = mpp->variant->hw_probe(mpp);
-	if (ret)
-		goto err;
-
-	dev_info(dev, "resource ready, register device\n");
-	/* create device node */
-	ret = alloc_chrdev_region(&mpp->dev_t, 0, 1, name);
-	if (ret) {
-		dev_err(dev, "alloc dev_t failed\n");
-		goto err;
-	}
+void mpp_dev_write(struct rockchip_mpp_dev *mpp, u32 reg, u32 val)
+{
+	mpp_debug(DEBUG_SET_REG, "write reg[%03d]: %08x\n", reg / 4, val);
+	iowrite32(val, mpp->reg_base + reg);
+}
+EXPORT_SYMBOL(mpp_dev_write);
 
-	cdev_init(&mpp->cdev, &mpp_dev_fops);
+void mpp_dev_read_seq(struct rockchip_mpp_dev *mpp_dev,
+		      unsigned long offset, void *buffer,
+		      unsigned long count)
+{
+	int i = 0;
 
-	mpp->cdev.owner = THIS_MODULE;
-	mpp->cdev.ops = &mpp_dev_fops;
+	for (i = 0; i < count; i++) {
+		u32 *cur = (u32 *)buffer;
+		u32 pos = offset / 4 + i;
 
-	ret = cdev_add(&mpp->cdev, mpp->dev_t, 1);
-	if (ret) {
-		unregister_chrdev_region(mpp->dev_t, 1);
-		dev_err(dev, "add dev_t failed\n");
-		goto err;
+		cur += i;
+		*cur = ioread32(mpp_dev->reg_base + pos * 4);
+		mpp_debug(DEBUG_GET_REG, "get reg[%03d]: %08x\n", pos, *cur);
 	}
-
-	mpp->child_dev = device_create(mpp->srv->cls, dev,
-				       mpp->dev_t, NULL, name);
-
-	mpp_srv_attach(mpp->srv, &mpp->lnk_service);
-
-	platform_set_drvdata(pdev, mpp);
-
-	return 0;
-err:
-	wake_lock_destroy(&mpp->wake_lock);
-	return ret;
 }
+EXPORT_SYMBOL(mpp_dev_read_seq);
 
-static int mpp_dev_remove(struct platform_device *pdev)
+u32 mpp_dev_read(struct rockchip_mpp_dev *mpp, u32 reg)
 {
-	struct rockchip_mpp_dev *mpp = platform_get_drvdata(pdev);
-	struct mpp_session *session = list_first_entry(&mpp->srv->session,
-						       struct mpp_session,
-						       list_session);
+	u32 val = ioread32(mpp->reg_base + reg);
 
-	mpp->variant->hw_remove(mpp);
-
-	vpu_iommu_clear(mpp->iommu_info, session);
-	vpu_iommu_destroy(mpp->iommu_info);
-	kfree(session);
+	mpp_debug(DEBUG_GET_REG, "get reg[%03d] 0x%x: %08x\n", reg / 4,
+		  reg, val);
+	return val;
+}
+EXPORT_SYMBOL(mpp_dev_read);
 
-	mpp_srv_lock(mpp->srv);
-	cancel_delayed_work_sync(&mpp->power_off_work);
-	mpp_dev_power_off(mpp);
-	mpp_srv_detach(mpp->srv, &mpp->lnk_service);
-	mpp_srv_unlock(mpp->srv);
+void mpp_debug_time_record(struct mpp_task *task)
+{
+	if (unlikely(debug & DEBUG_TIMING) && task)
+		do_gettimeofday(&task->start);
+}
+EXPORT_SYMBOL(mpp_debug_time_record);
 
-	device_destroy(mpp->srv->cls, mpp->dev_t);
-	cdev_del(&mpp->cdev);
-	unregister_chrdev_region(mpp->dev_t, 1);
+void mpp_debug_time_diff(struct mpp_task *task)
+{
+	struct timeval end;
 
-	return 0;
+	do_gettimeofday(&end);
+	mpp_debug(DEBUG_TIMING, "time: %ld us\n",
+		  (end.tv_sec  - task->start.tv_sec)  * 1000000 +
+		  (end.tv_usec - task->start.tv_usec));
 }
+EXPORT_SYMBOL(mpp_debug_time_diff);
 
-static struct platform_driver mpp_dev_driver = {
-	.probe = mpp_dev_probe,
-	.remove = mpp_dev_remove,
-	.driver = {
-		.name = "mpp_dev",
-#if defined(CONFIG_OF)
-		.of_match_table = of_match_ptr(mpp_dev_dt_ids),
-#endif
-	},
-};
-
-static int __init mpp_dev_init(void)
+static int __init mpp_device_init(void)
 {
-	int ret = platform_driver_register(&mpp_dev_driver);
-
-	if (ret) {
-		mpp_err("Platform device register failed (%d).\n", ret);
-		return ret;
-	}
+	mpp_device_class = class_create(THIS_MODULE, "mpp_device");
+	if (PTR_ERR_OR_ZERO(mpp_device_class))
+		return PTR_ERR(mpp_device_class);
 
-	return ret;
+	return 0;
 }
 
-static void __exit mpp_dev_exit(void)
+static void __exit mpp_device_exit(void)
 {
-	platform_driver_unregister(&mpp_dev_driver);
+	class_destroy(mpp_device_class);
 }
 
-module_init(mpp_dev_init);
-module_exit(mpp_dev_exit);
-
+module_init(mpp_device_init);
+module_exit(mpp_device_exit);
 MODULE_LICENSE("GPL v2");
-MODULE_VERSION("1.0.build.201610121711");
-MODULE_AUTHOR("Alpha Lin alpha.lin@rock-chips.com");
-MODULE_DESCRIPTION("Rockchip mpp device driver");
diff --git a/drivers/video/rockchip/vpu/mpp_dev_common.h b/drivers/video/rockchip/vpu/mpp_dev_common.h
index d4d1897b7ac3..007200d8f781 100644
--- a/drivers/video/rockchip/vpu/mpp_dev_common.h
+++ b/drivers/video/rockchip/vpu/mpp_dev_common.h
@@ -1,7 +1,6 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: chenhengming chm@rock-chips.com
- *	   Alpha Lin, alpha.lin@rock-chips.com
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2016 - 2017 Fuzhou Rockchip Electronics Co., Ltd
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -14,297 +13,206 @@
  *
  */
 
-#ifndef __ROCKCHIP_MPP_DEV_COMMON_H
-#define __ROCKCHIP_MPP_DEV_COMMON_H
+#ifndef _ROCKCHIP_MPP_DEV_COMMON_H_
+#define _ROCKCHIP_MPP_DEV_COMMON_H_
 
 #include <linux/cdev.h>
 #include <linux/dma-buf.h>
-#include <linux/rockchip_ion.h>
-#include <linux/rockchip-iovmm.h>
+#include <linux/kfifo.h>
 #include <linux/types.h>
 #include <linux/workqueue.h>
-#include <linux/wakelock.h>
-
-extern int mpp_dev_debug;
-
-/*
- * Ioctl definitions
- */
-
-/* Use 'l' as magic number */
-#define MPP_IOC_MAGIC			'l'
+#include <linux/reset.h>
 
-#define MPP_IOC_SET_CLIENT_TYPE		_IOW(MPP_IOC_MAGIC, 1, u32)
-#define MPP_IOC_GET_HW_FUSE_STATUS	_IOW(MPP_IOC_MAGIC, 2, u32)
+#include "mpp_service.h"
 
-#define MPP_IOC_SET_REG			_IOW(MPP_IOC_MAGIC, 3, u32)
-#define MPP_IOC_GET_REG			_IOW(MPP_IOC_MAGIC, 4, u32)
-
-#define MPP_IOC_PROBE_IOMMU_STATUS	_IOR(MPP_IOC_MAGIC, 5, u32)
 #define MPP_IOC_CUSTOM_BASE			0x1000
 
-/*
- * debug flag usage:
- * +------+-------------------+
- * | 8bit |      24bit        |
- * +------+-------------------+
- *  0~23 bit is for different information type
- * 24~31 bit is for information print format
- */
-
-#define DEBUG_POWER				0x00000001
-#define DEBUG_CLOCK				0x00000002
-#define DEBUG_IRQ_STATUS			0x00000004
-#define DEBUG_IOMMU				0x00000008
-#define DEBUG_IOCTL				0x00000010
-#define DEBUG_FUNCTION				0x00000020
-#define DEBUG_REGISTER				0x00000040
-#define DEBUG_EXTRA_INFO			0x00000080
-#define DEBUG_TIMING				0x00000100
-#define DEBUG_TASK_INFO				0x00000200
-#define DEBUG_DUMP_ERR_REG			0x00000400
-
-#define DEBUG_SET_REG				0x00001000
-#define DEBUG_GET_REG				0x00002000
-#define DEBUG_PPS_FILL				0x00004000
-#define DEBUG_IRQ_CHECK				0x00008000
-#define DEBUG_CACHE_32B				0x00010000
-
-#define DEBUG_RESET				0x00020000
-
-#define PRINT_FUNCTION				0x80000000
-#define PRINT_LINE				0x40000000
-
-#define DEBUG
-#ifdef DEBUG
-#define mpp_debug_func(type, fmt, args...)			\
-	do {							\
-		if (unlikely(mpp_dev_debug & type)) {		\
-			pr_info("%s:%d: " fmt,			\
-				 __func__, __LINE__, ##args);	\
-		}						\
-	} while (0)
-#define mpp_debug(type, fmt, args...)				\
-	do {							\
-		if (unlikely(mpp_dev_debug & type)) {		\
-			pr_info(fmt, ##args);			\
-		}						\
-	} while (0)
-#else
-#define mpp_debug_func(level, fmt, args...)
-#define mpp_debug(level, fmt, args...)
-#endif
-
-#define mpp_debug_enter() mpp_debug_func(DEBUG_FUNCTION, "enter\n")
-#define mpp_debug_leave() mpp_debug_func(DEBUG_FUNCTION, "leave\n")
-
-#define mpp_err(fmt, args...)				\
-		pr_err("%s:%d: " fmt, __func__, __LINE__, ##args)
+#define EXTRA_INFO_MAGIC			(0x4C4A46)
+#define JPEG_IOC_EXTRA_SIZE			(48)
 
 struct mpp_trans_info {
 	const int count;
 	const char * const table;
 };
 
-enum RKVENC_MODE {
-	RKVENC_MODE_NONE,
-	RKVENC_MODE_ONEFRAME,
-	RKVENC_MODE_LINKTABLE_FIX,
-	RKVENC_MODE_LINKTABLE_UPDATE,
-	RKVENC_MODE_NUM
+struct extra_info_elem {
+	u32 index;
+	u32 offset;
 };
 
-struct rockchip_mpp_dev;
-struct mpp_service;
-struct mpp_ctx;
+struct extra_info_for_iommu {
+	u32 magic;
+	u32 cnt;
+	struct extra_info_elem elem[20];
+};
+
+struct mpp_dev_variant {
+	u32 reg_len;
+	struct mpp_trans_info *trans_info;
+	const char *node_name;
+};
 
 struct mpp_mem_region {
 	struct list_head srv_lnk;
 	struct list_head reg_lnk;
 	struct list_head session_lnk;
 	/* virtual address for iommu */
-	unsigned long iova;
+	dma_addr_t iova;
 	unsigned long len;
 	u32 reg_idx;
-	int hdl;
+	void *hdl;
 };
 
-/**
- * struct for process register set
- *
- * @author ChenHengming (2011-5-4)
- */
-struct mpp_ctx {
-	/* context belong to */
-	struct rockchip_mpp_dev *mpp;
-	struct mpp_session *session;
-
-	/* link to service session */
-	struct list_head session_link;
-	/* link to service list */
-	struct list_head status_link;
-
-	struct list_head mem_region_list;
-
-	/* record context running start time */
-	struct timeval start;
-};
+/* Definition in dma file */
+struct mpp_dma_session;
+/* Definition in mpp service file */
+struct mpp_service;
 
-enum vpu_ctx_state {
-	MMU_ACTIVATED	= BIT(0),
-};
+struct rockchip_mpp_dev {
+	struct device *dev;
 
-struct extra_info_elem {
-	u32 index;
-	u32 offset;
-};
+	const struct mpp_dev_variant *variant;
+	struct mpp_dev_ops *ops;
 
-#define EXTRA_INFO_MAGIC	0x4C4A46
+	void __iomem *reg_base;
+	int irq;
+	struct workqueue_struct *irq_workq;
 
-struct extra_info_for_iommu {
-	u32 magic;
-	u32 cnt;
-	struct extra_info_elem elem[20];
-};
+	struct mpp_iommu_info *iommu_info;
+	rwlock_t resource_rwlock;
+	atomic_t reset_request;
 
-struct rockchip_mpp_dev_variant {
-	u32 data_len;
-	u32 reg_len;
-	struct mpp_trans_info *trans_info;
-	char *mmu_dev_dts_name;
+	struct cdev mpp_cdev;
+	dev_t dev_id;
 
-	int (*hw_probe)(struct rockchip_mpp_dev *mpp);
-	void (*hw_remove)(struct rockchip_mpp_dev *mpp);
-	void (*power_on)(struct rockchip_mpp_dev *mpp);
-	void (*power_off)(struct rockchip_mpp_dev *mpp);
-	int (*reset)(struct rockchip_mpp_dev *mpp);
+	/* MPP Service */
+	struct mpp_service_node *srv;
 };
 
-struct rockchip_mpp_dev {
-	struct mpp_dev_ops *ops;
-
-	struct cdev cdev;
-	dev_t dev_t;
-	struct device *child_dev;
+struct mpp_task;
 
-	int irq;
-	struct mpp_service *srv;
+struct mpp_session {
+	/* the session related device private data */
+	struct rockchip_mpp_dev *mpp;
+	/* a linked list of data so we can access them for debugging */
+	struct list_head list_session;
+	struct mpp_dma_session *dma;
 
-	void __iomem *reg_base;
-	struct list_head lnk_service;
+	/* session tasks list lock */
+	struct mutex lock;
+	struct list_head pending;
 
-	struct device *dev;
+	DECLARE_KFIFO_PTR(done_fifo, struct mpp_task *);
 
-	unsigned long state;
-	struct vpu_iommu_info *iommu_info;
+	wait_queue_head_t wait;
+	pid_t pid;
+	atomic_t task_running;
+};
 
-	const struct rockchip_mpp_dev_variant *variant;
+/* The context for the a task */
+struct mpp_task {
+	/* context belong to */
+	struct mpp_session *session;
 
-	struct device *mmu_dev;
-	u32 iommu_enable;
+	/* link to service session */
+	struct list_head session_link;
+	/* link to service list */
+	struct list_head service_link;
+	/* The DMA buffer used in this task */
+	struct list_head mem_region_list;
+	struct work_struct work;
 
-	struct wake_lock wake_lock;
-	struct delayed_work power_off_work;
-	/* record previous power-on time */
-	ktime_t last;
-	atomic_t power_on_cnt;
-	atomic_t power_off_cnt;
-	atomic_t total_running;
-	atomic_t enabled;
-	atomic_t reset_request;
+	/* record context running start time */
+	struct timeval start;
 };
 
-/**
- * struct mpp_dev_ops - context specific operations for mpp_device
- *
- * @init	Prepare for registers file for specific hardware.
+/*
+ * struct mpp_dev_ops - context specific operations for a device
+ * The task part
+ * @alloc_task
  * @prepare	Check HW status for determining run next task or not.
  * @run		Start a single {en,de}coding run. Set registers to hardware.
- * @done	Read back processing results and additional data from hardware.
+ * @finish	Read back processing results and additional data from hardware.
  * @result	Read status to userspace.
- * @deinit	Release the resource allocate during init.
- * @ioctl	ioctl for special HW besides the common ioctl.
- * @irq		interrupt service for specific hardware.
- * @open	a specific instance open operation for hardware.
- * @release	a specific instance release operation for hardware.
+ * @free_task	Release the resource allocate during init.
+ * The device part
+ * @reset
  */
 struct mpp_dev_ops {
 	/* size: in bytes, data sent from userspace, length in bytes */
-	struct mpp_ctx *(*init)(struct rockchip_mpp_dev *mpp,
-				struct mpp_session *session,
-				void __user *src, u32 size);
-	int (*prepare)(struct rockchip_mpp_dev *mpp);
-	int (*run)(struct rockchip_mpp_dev *mpp);
-	int (*done)(struct rockchip_mpp_dev *mpp);
-	int (*irq)(struct rockchip_mpp_dev *mpp);
-	int (*result)(struct rockchip_mpp_dev *mpp, struct mpp_ctx *ctx,
-		      u32 __user *dst);
-	void (*deinit)(struct rockchip_mpp_dev *mpp);
-	long (*ioctl)(struct mpp_session *isession,
-		      unsigned int cmd, unsigned long arg);
-	struct mpp_session *(*open)(struct rockchip_mpp_dev *mpp);
-	void (*release)(struct mpp_session *session);
-	void (*free)(struct mpp_session *session);
+	void *(*alloc_task)(struct mpp_session *session,
+			    void __user *src, u32 size);
+	int (*prepare)(struct rockchip_mpp_dev *mpp_dev, struct mpp_task *task);
+	int (*run)(struct rockchip_mpp_dev *mpp_dev, struct mpp_task *task);
+	int (*finish)(struct rockchip_mpp_dev *mpp_dev, struct mpp_task *task);
+	int (*result)(struct rockchip_mpp_dev *mpp_dev, struct mpp_task *task,
+		      u32 __user *dst, u32 size);
+	int (*free_task)(struct mpp_session *session,
+			    struct mpp_task *task);
+	/* Hardware only operations */
+	int (*reset)(struct rockchip_mpp_dev *mpp_dev);
 };
 
-void mpp_dump_reg(void __iomem *regs, int count);
-void mpp_dump_reg_mem(u32 *regs, int count);
+struct mpp_mem_region *mpp_dev_task_attach_fd(struct mpp_task *task, int fd);
 int mpp_reg_address_translate(struct rockchip_mpp_dev *data,
-			      u32 *reg,
-			      struct mpp_ctx *ctx,
-			      int idx);
-void mpp_translate_extra_info(struct mpp_ctx *ctx,
+			      struct mpp_task *task, int fmt, u32 *reg);
+void mpp_translate_extra_info(struct mpp_task *task,
 			      struct extra_info_for_iommu *ext_inf,
 			      u32 *reg);
 
-int mpp_dev_common_ctx_init(struct rockchip_mpp_dev *mpp, struct mpp_ctx *cfg);
-void mpp_dev_common_ctx_deinit(struct rockchip_mpp_dev *mpp,
-			       struct mpp_ctx *ctx);
+int mpp_dev_task_init(struct mpp_session *session, struct mpp_task *task);
+void mpp_dev_task_finish(struct mpp_session *session, struct mpp_task *task);
+void mpp_dev_task_finalize(struct mpp_session *session, struct mpp_task *task);
+
 void mpp_dev_power_on(struct rockchip_mpp_dev *mpp);
 void mpp_dev_power_off(struct rockchip_mpp_dev *mpp);
 bool mpp_dev_is_power_on(struct rockchip_mpp_dev *mpp);
 
-static inline void mpp_write_relaxed(struct rockchip_mpp_dev *mpp,
-				     u32 val, u32 reg)
+void mpp_dump_reg(void __iomem *regs, int count);
+void mpp_dump_reg_mem(u32 *regs, int count);
+
+/* It can handle the default ioctl */
+long mpp_dev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg);
+#ifdef CONFIG_COMPAT
+long mpp_dev_compat_ioctl(struct file *filp, unsigned int cmd,
+			  unsigned long arg);
+#endif
+
+int mpp_dev_common_probe(struct rockchip_mpp_dev *mpp_dev,
+			 struct platform_device *pdev,
+			 struct mpp_dev_ops *ops);
+int mpp_dev_register_node(struct rockchip_mpp_dev *mpp_dev,
+			  const char *node_name, const void *fops);
+int mpp_dev_common_remove(struct rockchip_mpp_dev *mpp_dev);
+
+static inline void safe_reset(struct reset_control *rst)
 {
-	mpp_debug(DEBUG_SET_REG, "MARK: set reg[%03d]: %08x\n", reg / 4, val);
-	writel_relaxed(val, mpp->reg_base + reg);
+	if (rst)
+		reset_control_assert(rst);
 }
 
-static inline void mpp_write(struct rockchip_mpp_dev *mpp,
-			     u32 val, u32 reg)
+static inline void safe_unreset(struct reset_control *rst)
 {
-	mpp_debug(DEBUG_SET_REG, "MARK: set reg[%03d]: %08x\n", reg / 4, val);
-	writel(val, mpp->reg_base + reg);
+	if (rst)
+		reset_control_deassert(rst);
 }
 
-static inline u32 mpp_read(struct rockchip_mpp_dev *mpp, u32 reg)
-{
-	u32 val = readl(mpp->reg_base + reg);
+void mpp_dev_write_seq(struct rockchip_mpp_dev *mpp_dev,
+			      unsigned long offset, void *buffer,
+			      unsigned long count);
 
-	mpp_debug(DEBUG_GET_REG, "MARK: get reg[%03d] 0x%x: %08x\n", reg / 4,
-		  reg, val);
-	return val;
-}
+void mpp_dev_write(struct rockchip_mpp_dev *mpp, u32 val, u32 reg);
 
-static inline void mpp_time_record(struct mpp_ctx *ctx)
-{
-	if (unlikely(mpp_dev_debug & DEBUG_TIMING) && ctx)
-		do_gettimeofday(&ctx->start);
-}
+void mpp_dev_read_seq(struct rockchip_mpp_dev *mpp_dev,
+			     unsigned long offset, void *buffer,
+			     unsigned long count);
 
-static inline void mpp_time_diff(struct mpp_ctx *ctx)
-{
-	struct timeval end;
+u32 mpp_dev_read(struct rockchip_mpp_dev *mpp, u32 reg);
 
-	do_gettimeofday(&end);
-	mpp_debug(DEBUG_TIMING, "consume: %ld us\n",
-		  (end.tv_sec  - ctx->start.tv_sec)  * 1000000 +
-		  (end.tv_usec - ctx->start.tv_usec));
-}
+void mpp_debug_time_record(struct mpp_task *task);
+void mpp_debug_time_diff(struct mpp_task *task);
 
-extern const struct rockchip_mpp_dev_variant rkvenc_variant;
-extern const struct rockchip_mpp_dev_variant vepu_variant;
-extern const struct rockchip_mpp_dev_variant h265e_variant;
+void mpp_debug_dump_reg(void __iomem *regs, int count);
+void mpp_debug_dump_reg_mem(u32 *regs, int count);
 
 #endif
diff --git a/drivers/video/rockchip/vpu/mpp_dev_h265e.c b/drivers/video/rockchip/vpu/mpp_dev_h265e.c
deleted file mode 100644
index bebc9834188b..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e.c
+++ /dev/null
@@ -1,2148 +0,0 @@
-/*
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: hehua,hh@rock-chips.com
- * lixinhuang, buluess.li@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/clk.h>
-#include <linux/compiler.h>
-#include <linux/delay.h>
-#include <linux/firmware.h>
-#include <linux/mfd/syscon.h>
-#include <linux/regmap.h>
-#include <linux/reset.h>
-#include <linux/rk_fb.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/uaccess.h>
-
-#include "vpu_iommu_ops.h"
-#include "mpp_dev_common.h"
-#include "mpp_dev_h265e.h"
-#include "mpp_dev_h265e_define.h"
-#include "mpp_dev_h265e_reg.h"
-
-#define MPP_ALIGN_SIZE	0x1000
-
-#define H265E_FIRMWARE_NAME "monet.bin"
-#define PRINT_BS_DATA 0
-#if PRINT_BS_DATA
-#define H265E_BS_DATA_PATH "/h265e/bs_data"
-static char buff[1000000];
-static struct file *fp_bs[H265E_INSTANCE_NUM];
-static u32 w_bs_size;
-#endif
-
-#define H265E_WORK_BUFFER_SIZE			(128 * 1024)
-#define H265E_TEMP_BUFFER_SIZE			(1024 * 1024)
-#define H265E_CODE_BUFFER_SIZE			(1024 * 1024)
-#define H265E_SEC_AXI_BUF_SIZE			0x12800
-#define H265E_INT_CLOSE 0
-#define H265E_INT_OPEN  0x08
-#define H265E_REMAP_CODE_INDEX			0
-
-#define H265E_BUSY_CHECK_TIMEOUT		5000
-
-#define DEBUG_H265E_INFO				0x00100000
-#define DEBUG_H265E_ENCODE_ONE_FRAME	0x00200000
-#define H265E_POWER_SAVE 0
-#define H265E_CLK 1
-#ifdef CONFIG_MFD_SYSCON
-#define H265E_AXI_STATUS 1
-#endif
-static ktime_t h265e_now, h265e_last;
-
-static
-struct mpp_session *rockchip_mpp_h265e_open(struct rockchip_mpp_dev *mpp);
-static void rockchip_mpp_h265e_free(struct mpp_session *isession);
-static void rockchip_mpp_h265e_release(struct mpp_session *isession);
-static int rockchip_mpp_h265e_load_firmware(struct rockchip_mpp_dev *mpp,
-					    struct mpp_session *session);
-static int rockchip_mpp_h265e_encode_one_frame(struct rockchip_mpp_dev *mpp,
-					       struct h265e_ctx *ctx,
-					       int index);
-static int rockchip_mpp_h265e_get_encode_result(struct rockchip_mpp_dev *mpp,
-						struct h265e_ctx *result);
-static int rockchip_mpp_h265e_set_gop_parameter(struct rockchip_mpp_dev *mpp,
-						int index);
-static
-int rockchip_mpp_h265e_register_frame_buffer(struct rockchip_mpp_dev *mpp,
-					     int index);
-static void rockchip_mpp_h265e_enable_clk(struct rockchip_mpp_dev *mpp);
-static void rockchip_mpp_h265e_disable_clk(struct rockchip_mpp_dev *mpp);
-
-static void rockchip_mpp_h265e_dma_free(struct rockchip_mpp_dev *mpp,
-					struct mpp_session *session,
-					int hdl)
-{
-	if (hdl >= 0) {
-		vpu_iommu_unmap_iommu(mpp->iommu_info, session, hdl);
-		vpu_iommu_free(mpp->iommu_info, session, hdl);
-	}
-}
-
-static int rockchip_mpp_h265e_dma_alloc(struct rockchip_mpp_dev *mpp,
-					struct mpp_session *session,
-					size_t len,
-					size_t align,
-					unsigned long *addr)
-{
-	int ret = 0;
-	unsigned long tmp;
-	int tmp_hdl;
-
-	tmp_hdl = vpu_iommu_alloc(mpp->iommu_info, session, len, align);
-	if (tmp_hdl < 0) {
-		dev_err(mpp->dev, "error: ion_alloc fail\n");
-		return -1;
-	}
-
-	ret = vpu_iommu_map_iommu(mpp->iommu_info,
-				  session, tmp_hdl, addr, &tmp);
-	if (ret < 0) {
-		dev_err(mpp->dev, "get link table dma_addr failed\n");
-		goto FAIL;
-	}
-	return tmp_hdl;
-FAIL:
-	if (tmp_hdl)
-		vpu_iommu_free(mpp->iommu_info, session, tmp_hdl);
-	return -1;
-}
-
-static void rockchip_mpp_h265e_free_frame_buffer(struct rockchip_mpp_dev *mpp,
-						 struct rockchip_h265e_instance *instance)
-{
-	unsigned int i = 0;
-	struct mpp_h265e_buffer *buf = NULL;
-	struct mpp_h265e_frame_buffer *fb = NULL;
-	struct mpp_session *session = instance->session;
-
-	mpp_debug_enter();
-	buf = &instance->mv;
-	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
-	buf = &instance->fbc_luma;
-	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
-	buf = &instance->fbc_chroma;
-	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
-	buf = &instance->sub_sample;
-	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
-
-	for (i = 0; i < ARRAY_SIZE(instance->frame_buffer); i++) {
-		fb = &instance->frame_buffer[i];
-		buf = &fb->buffer;
-		rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
-		fb->y = 0;
-		fb->cb = 0;
-		fb->cr = 0;
-	}
-	mpp_debug_leave();
-}
-
-static void rockchip_mpp_h265e_free_instance(struct rockchip_mpp_dev *mpp,
-					     int index)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct rockchip_h265e_instance *instance = &enc->instance[index];
-	struct mpp_h265e_buffer *buf = &instance->work;
-	struct mpp_session *session = instance->session;
-
-	mpp_debug_enter();
-#if PRINT_BS_DATA
-	filp_close(fp_bs[index], NULL);
-#endif
-	if (!mpp || !instance)
-		return;
-	rockchip_mpp_h265e_dma_free(mpp, session, buf->hdl);
-	rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
-	atomic_set(&enc->instance[index].is_used, 0);
-	mpp_debug_leave();
-}
-
-static int rockchip_mpp_h265e_wait_busy(struct rockchip_mpp_dev *mpp)
-{
-	int reg_val = 0xFFFFFFFF, time_count = 0;
-
-	while (reg_val != 0x0) {
-		reg_val = mpp_read(mpp, H265E_VPU_BUSY_STATUS);
-		if (time_count++ > H265E_BUSY_CHECK_TIMEOUT)
-			return -1;
-	}
-	return 0;
-}
-
-static void rockchip_mpp_h265e_issue_command(struct rockchip_mpp_dev *mpp,
-					     u32 index, u32 cmd)
-{
-	u32 value = 0;
-
-	mpp_write(mpp, 1, H265E_VPU_BUSY_STATUS);
-	value = ((index & 0xffff) | (1 << 16));
-	mpp_write(mpp, value, H265E_INST_INDEX);
-	mpp_write(mpp, cmd, H265E_COMMAND);
-	if (cmd != H265E_CMD_INIT_VPU)
-		mpp_write(mpp, 1, H265E_VPU_HOST_INT_REQ);
-}
-
-#if PRINT_BS_DATA
-static int rockchip_mpp_h265e_write_encoder_file(struct rockchip_mpp_dev *mpp)
-{
-	struct h265e_ctx *ctx = container_of(mpp_srv_get_current_ctx(mpp->srv),
-					     struct h265e_ctx, ictx);
-	struct h265e_session *session =
-					container_of(ctx->ictx.session,
-						     struct h265e_session,
-						     isession);
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	int index = session->instance_index;
-	int nread = 0;
-	loff_t pos = 0;
-	mm_segment_t old_fs;
-	u32 value = 0;
-	u32 i = 0;
-	char file_name[30];
-
-	mutex_lock(&enc->lock);
-	mpp_debug_enter();
-	value = w_bs_size;
-	old_fs = get_fs();
-	set_fs(KERNEL_DS);
-	sprintf(file_name, "%s_%d.bin", H265E_BS_DATA_PATH, index);
-	fp_bs[index] = filp_open(file_name, O_RDWR | O_CREAT | O_APPEND, 0x777);
-	if (IS_ERR(fp_bs[index])) {
-		mpp_err("error: open yuv failed in load_yuv\n");
-		set_fs(old_fs);
-		mutex_unlock(&enc->lock);
-		return -1;
-	}
-	for (i = 0; i < (value * 3); i++) {
-		if (ctx->bs_data[i] < 0x10) {
-			sprintf(&buff[3 * i], "0");
-			sprintf(&buff[3 * i + 1], "%-2x", ctx->bs_data[i]);
-		} else {
-			sprintf(&buff[3 * i], "%-3x", ctx->bs_data[i]);
-		}
-	}
-	nread = (int)vfs_write(fp_bs[index], buff, value * 3, &pos);
-	set_fs(old_fs);
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-	return 0;
-}
-#endif
-
-static int rockchip_mpp_h265e_load_firmware(struct rockchip_mpp_dev *mpp,
-					    struct mpp_session *session)
-{
-	const struct firmware *firmware;
-	u32 size = 0;
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-
-	if (request_firmware(&firmware, H265E_FIRMWARE_NAME, mpp->dev) < 0) {
-		mpp_err("firmware request failed\n");
-		release_firmware(firmware);
-		return -1;
-	}
-	mpp_debug(DEBUG_H265E_INFO, "h265e firmware data %p size %zu\n",
-		  firmware->data, firmware->size);
-	size = ALIGN(firmware->size, H265E_CODE_BUFFER_SIZE);
-	enc->firmware.hdl =
-		rockchip_mpp_h265e_dma_alloc(mpp,
-					     session,
-					     size,
-					     MPP_ALIGN_SIZE,
-					     &enc->firmware.dma_addr);
-	if (enc->firmware.hdl < 0) {
-		mpp_err("error: alloc firmware buffer error\n");
-		goto FAIL;
-	}
-	enc->firmware.size = ALIGN(firmware->size, MPP_ALIGN_SIZE);
-	enc->firmware_cpu_addr = vpu_iommu_map_kernel(mpp->iommu_info,
-						      session,
-						      enc->firmware.hdl);
-	mpp_debug(DEBUG_H265E_INFO,
-		  "firmware_buffer_size = %d,firmware size = %zd,code_base = %x\n",
-		  size, firmware->size, (u32)enc->firmware.dma_addr);
-	memcpy(enc->firmware_cpu_addr, firmware->data, firmware->size);
-	release_firmware(firmware);
-	return 0;
-FAIL:
-	release_firmware(firmware);
-	if (enc->firmware.hdl >= 0) {
-		vpu_iommu_unmap_kernel(mpp->iommu_info, session,
-				       enc->firmware.hdl);
-		vpu_iommu_free(mpp->iommu_info, session, enc->firmware.hdl);
-	}
-	return -1;
-}
-
-static struct mpp_ctx *rockchip_mpp_h265e_ctx_init(struct rockchip_mpp_dev *mpp,
-						   struct mpp_session *session,
-						   void __user *src, u32 dwsize)
-{
-	struct h265e_ctx *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct mpp_mem_region *mem_bs_region = NULL;
-	struct mpp_mem_region *mem_src_region = NULL;
-	unsigned long size = 0;
-	int ret = 0;
-
-	mutex_lock(&enc->lock);
-	mpp_debug_enter();
-	if (!ctx) {
-		mutex_unlock(&enc->lock);
-		return NULL;
-	}
-	mpp_dev_common_ctx_init(mpp, &ctx->ictx);
-	ctx->ictx.session = session;
-	if (copy_from_user(&ctx->cfg, src, dwsize)) {
-		mpp_err("error: copy_from_user failed in reg_init\n");
-		kfree(ctx);
-		mutex_unlock(&enc->lock);
-		return NULL;
-	}
-#if H265E_POWER_SAVE
-	rockchip_mpp_h265e_enable_clk(mpp);
-#endif
-	ctx->bs.hdl = vpu_iommu_import(mpp->iommu_info, session,
-				       ctx->cfg.bs_fd);
-	if (ctx->bs.hdl < 0) {
-		mpp_err("import dma-buf from fd %d failed\n", ctx->cfg.bs_fd);
-		mutex_unlock(&enc->lock);
-		return NULL;
-	}
-
-	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
-				  ctx->bs.hdl, &ctx->bs.dma_addr, &size);
-	ctx->bs.size = (u32)size;
-#if PRINT_BS_DATA
-	ctx->bs_data = vpu_iommu_map_kernel(mpp->iommu_info, session,
-					    ctx->bs.hdl);
-#endif
-
-	if (ret < 0) {
-		mpp_err("bs fd %d ion map iommu failed\n", ctx->cfg.bs_fd);
-		goto FAIL;
-	}
-
-	ctx->src.hdl = vpu_iommu_import(mpp->iommu_info, session,
-					ctx->cfg.src_fd);
-	if (ctx->src.hdl < 0) {
-		mpp_err("import dma-buf from fd %d failed\n", ctx->cfg.src_fd);
-		goto FAIL;
-	}
-	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
-				  ctx->src.hdl, &ctx->src.dma_addr, &size);
-	ctx->src.size = (u32)size;
-
-	if (ret < 0) {
-		mpp_err("source fd %d ion map iommu failed\n", ctx->cfg.src_fd);
-		goto FAIL;
-	}
-
-	mem_bs_region = kzalloc(sizeof(*mem_bs_region), GFP_KERNEL);
-	if (!mem_bs_region)
-		goto FAIL;
-	mem_src_region = kzalloc(sizeof(*mem_src_region), GFP_KERNEL);
-	if (!mem_src_region)
-		goto FAIL;
-	mem_bs_region->hdl = ctx->bs.hdl;
-	INIT_LIST_HEAD(&mem_bs_region->reg_lnk);
-	list_add_tail(&mem_bs_region->reg_lnk, &ctx->ictx.mem_region_list);
-
-	mem_src_region->hdl = ctx->src.hdl;
-	INIT_LIST_HEAD(&mem_src_region->reg_lnk);
-	list_add_tail(&mem_src_region->reg_lnk, &ctx->ictx.mem_region_list);
-
-	ctx->mode = H265E_MODE_ONEFRAME;
-	mpp_debug_leave();
-	mutex_unlock(&enc->lock);
-
-	return &ctx->ictx;
-
-FAIL:
-	if (ctx->bs.hdl >= 0) {
-		vpu_iommu_unmap_kernel(mpp->iommu_info, session, ctx->bs.hdl);
-		vpu_iommu_free(mpp->iommu_info, session, ctx->bs.hdl);
-	}
-
-	if (ctx->src.hdl >= 0) {
-		vpu_iommu_unmap_kernel(mpp->iommu_info, session, ctx->src.hdl);
-		vpu_iommu_free(mpp->iommu_info, session, ctx->src.hdl);
-	}
-
-	if (!IS_ERR_OR_NULL(mem_bs_region)) {
-		kfree(mem_bs_region);
-		mem_bs_region = NULL;
-	}
-
-	if (!IS_ERR_OR_NULL(mem_src_region)) {
-		kfree(mem_src_region);
-		mem_src_region = NULL;
-	}
-
-	if (!IS_ERR_OR_NULL(ctx)) {
-		kfree(ctx);
-		ctx = NULL;
-	}
-	mutex_unlock(&enc->lock);
-	return NULL;
-}
-
-static int rockchip_mpp_h265e_run(struct rockchip_mpp_dev *mpp)
-{
-	struct h265e_ctx *ctx = container_of(mpp_srv_get_current_ctx(mpp->srv),
-					     struct h265e_ctx, ictx);
-	struct h265e_session *session =
-					container_of(ctx->ictx.session,
-						     struct h265e_session,
-						     isession);
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	int index = session->instance_index;
-
-	mpp_debug_enter();
-#ifdef CONFIG_MFD_SYSCON
-	if (enc->grf) {
-		u32 raw;
-		u32 bits = BIT(enc->mode_bit);
-
-		regmap_read(enc->grf, enc->mode_ctrl, &raw);
-		regmap_write(enc->grf, enc->mode_ctrl,
-			     (raw | bits) | (bits << 16));
-	}
-#endif
-	rockchip_mpp_h265e_encode_one_frame(mpp, ctx, index);
-	mpp_debug_leave();
-	return 0;
-}
-
-static int rockchip_mpp_h265e_done(struct rockchip_mpp_dev *mpp)
-{
-	struct mpp_ctx *ictx = mpp_srv_get_current_ctx(mpp->srv);
-	struct h265e_ctx *ctx = container_of(ictx, struct h265e_ctx, ictx);
-	int ret = 0;
-
-	mpp_debug_enter();
-	if (IS_ERR_OR_NULL(ictx)) {
-		mpp_err("Invaidate context to save result\n");
-		return -1;
-	}
-	ret = rockchip_mpp_h265e_get_encode_result(mpp, ctx);
-#if PRINT_BS_DATA
-	rockchip_mpp_h265e_write_encoder_file(mpp);
-#endif
-	mpp_debug_leave();
-
-	return ret;
-}
-
-static int rockchip_mpp_h265e_irq(struct rockchip_mpp_dev *mpp)
-{
-	int reason = -1;
-
-	reason = mpp_read(mpp, H265E_VPU_VINT_REASON_USR);
-	mpp_write(mpp, reason, H265E_VPU_VINT_REASON_CLR);
-	mpp_write(mpp, 1, H265E_VPU_VINT_CLEAR);
-	mpp_write(mpp, 0, H265E_VPU_VINT_REASON_USR);
-	if (reason & (1 << INT_BIT_BIT_BUF_FULL))
-		return -1;
-	else if (reason == 0x02)
-		return -1;
-
-	return 0;
-}
-
-static int rockchip_mpp_h265e_result(struct rockchip_mpp_dev *mpp,
-				     struct mpp_ctx *ictx, u32 __user *dst)
-{
-	struct h265e_ctx *ctx = container_of(ictx, struct h265e_ctx, ictx);
-
-	switch (ctx->mode) {
-	case H265E_MODE_ONEFRAME:
-		if (copy_to_user(dst, &ctx->result,
-				 sizeof(struct h265e_result))) {
-			mpp_err("copy result to user failed\n");
-			return -1;
-		}
-		break;
-	default:
-		mpp_err("invalid context mode %d\n", (int)ctx->mode);
-		return -1;
-	}
-
-	return 0;
-}
-
-#ifdef H265E_STREAM_HEADER
-static int rockchip_mpp_h265e_get_stream_header(struct rockchip_mpp_dev *mpp,
-						int index,
-						struct hal_h265e_header *head)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-
-	struct rockchip_h265e_instance *instance = NULL;
-	struct mpp_h265e_cfg *cfg = NULL;
-	u32 value = 0;
-	u32 address = 0;
-	int bs_hd;
-	unsigned long bs_address;
-	unsigned long bs_size;
-	int ret = 0;
-
-	if (index < 0 || index >= H265E_INSTANCE_NUM || !head) {
-		mpp_err("index = %d is invalid", index);
-		return -1;
-	}
-	mutex_lock(&enc->lock);
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_enable_clk(mpp);
-#endif
-	mpp_debug_enter();
-	head->size = 0;
-	instance = &enc->instance[index];
-	cfg = &instance->cfg;
-	address = head->buf;
-
-	bs_hd = vpu_iommu_import(mpp->iommu_info, instance->session, address);
-	if (bs_hd < 0) {
-		mpp_err("import dma-buf from fd %d failed\n", address);
-		mutex_unlock(&enc->lock);
-		return -1;
-	}
-	ret = vpu_iommu_map_iommu(mpp->iommu_info,
-				  instance->session, bs_hd, &bs_address,
-				  &bs_size);
-	if (ret < 0) {
-		mpp_err("bs fd %d ion map iommu failed\n", address);
-		goto FAIL;
-	}
-	mpp_write(mpp, (u32)bs_address, H265E_BS_START_ADDR);
-	mpp_write(mpp, (u32)bs_address, H265E_BS_SIZE);
-
-	mpp_write(mpp, (u32)bs_address, H265E_BS_RD_PTR);
-	mpp_write(mpp, (u32)bs_address, H265E_BS_WR_PTR);
-
-	value = (cfg->line_buf_int_en << 6) |
-		(cfg->slice_int_enable << 5) |
-		(cfg->ring_buffer_enable << 4) |
-		cfg->bs_endian;
-	mpp_write(mpp, value, H265E_BS_PARAM);
-	mpp_write(mpp, 0, H265E_BS_OPTION);
-
-	/* Set up work-buffer */
-	mpp_write(mpp, instance->work.dma_addr, H265E_ADDR_WORK_BASE);
-	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
-	mpp_write(mpp, 0, H265E_WORK_PARAM);
-
-	/* Set up temp-buffer */
-	mpp_write(mpp, enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
-	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
-	mpp_write(mpp, 0, H265E_TEMP_PARAM);
-
-	mpp_write(mpp, 0, H265E_ENC_SRC_PIC_IDX);
-	if (cfg->code_option.implicit_header_encode == 1) {
-		value = CODEOPT_ENC_HEADER_IMPLICIT |
-			CODEOPT_ENC_VCL |
-			(cfg->code_option.encode_aud << 5) |
-			(cfg->code_option.encode_eos << 6) |
-			(cfg->code_option.encode_eob << 7);
-	} else {
-		value = (cfg->code_option.implicit_header_encode << 0) |
-			(cfg->code_option.encode_vcl << 1) |
-			(cfg->code_option.encode_vps << 2) |
-			(cfg->code_option.encode_sps << 3) |
-			(cfg->code_option.encode_pps << 4) |
-			(cfg->code_option.encode_aud << 5) |
-			(cfg->code_option.encode_eos << 6) |
-			(cfg->code_option.encode_eob << 7) |
-			(cfg->code_option.encode_vui << 9);
-	}
-	mpp_write(mpp, value, H265E_CMD_ENC_CODE_OPTION);
-	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_ENC_PIC);
-	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-		mpp_err("read return register fail\n");
-		goto FAIL;
-	}
-	head->size = mpp_read(mpp, H265E_RET_ENC_PIC_BYTE);
-	mpp_debug(DEBUG_H265E_INFO, "%s %d head->size=%d\n",
-		  __func__, __LINE__, head->size);
-	if (bs_hd >= 0)
-		vpu_iommu_free(mpp->iommu_info, instance->session, bs_hd);
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_disable_clk(mpp);
-#endif
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-
-	return 0;
-FAIL:
-	if (bs_hd >= 0)
-		vpu_iommu_free(mpp->iommu_info, instance->session, bs_hd);
-	mutex_unlock(&enc->lock);
-	mpp_err("fail, index = %d\n", index);
-	return -1;
-}
-#endif
-
-/*
- * set/change common parameter
- * when first run this function ,the cfg_mask is 0xffffffff,
- * and to configure all parameter.
- * when dynamically changed in the encoding process,
- * the configure register according to cfg_mask
- */
-static int rockchip_mpp_h265e_set_common_parameter(struct rockchip_mpp_dev *mpp,
-						   int index)
-{
-	u32 value = 0;
-	struct mpp_h265e_cfg *cfg = NULL;
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct rockchip_h265e_instance *instance = NULL;
-
-	mpp_debug_enter();
-	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
-		mpp_err("param is invalid,index = %d", index);
-		return -1;
-	}
-
-	instance = &enc->instance[index];
-	cfg = &instance->cfg;
-
-	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
-	mpp_write(mpp, (cfg->line_buf_int_en << 6) |
-		  (cfg->slice_int_enable << 5) |
-		  (cfg->ring_buffer_enable << 4) |
-		  cfg->bs_endian, H265E_BS_PARAM);
-	mpp_debug(DEBUG_H265E_INFO, "%s %d W=%d,H=%d,index=%d\n",
-		  __func__, __LINE__,
-		  cfg->width, cfg->height, index);
-
-	/* Set up work-buffer */
-	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
-	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
-	mpp_write(mpp, 0, H265E_WORK_PARAM);
-
-	/* Set up temp-buffer */
-	mpp_write(mpp, (u32)enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
-	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
-	mpp_write(mpp, 0, H265E_TEMP_PARAM);
-	/* Secondary AXI */
-#if	H265E_AXI_STATUS
-	mpp_write(mpp, 0x0, H265E_ADDR_SEC_AXI_BASE);
-	mpp_write(mpp, H265E_SEC_AXI_BUF_SIZE, H265E_SEC_AXI_SIZE);
-	mpp_write(mpp, 0xffff, H265E_USE_SEC_AXI);
-#else
-	mpp_write(mpp, 0, H265E_USE_SEC_AXI);
-#endif
-
-	/* Set up BitstreamBuffer */
-	mpp_write(mpp, 0, H265E_BS_START_ADDR);
-	mpp_write(mpp, 0, H265E_BS_SIZE);
-	mpp_write(mpp, 0, H265E_BS_RD_PTR);
-	mpp_write(mpp, 0, H265E_BS_WR_PTR);
-
-	/* SET_PARAM + COMMON */
-	mpp_write(mpp, H265E_OPT_COMMON, H265E_ENC_SET_PARAM_OPTION);
-	mpp_write(mpp, (u32)cfg->cfg_mask, H265E_ENC_SET_PARAM_ENABLE);
-
-	if (cfg->cfg_mask & H265E_CFG_SEQ_SRC_SIZE_CHANGE) {
-		value = ((cfg->height << 16) | cfg->width);
-		mpp_write(mpp, value, H265E_ENC_SEQ_SRC_SIZE);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_SEQ_PARAM_CHANGE) {
-		/* set seq parameter*/
-		value = (cfg->profile << 0) |
-			(cfg->level << 3) |
-			(cfg->tier << 12) |
-			(cfg->bit_depth << 14) |
-			(cfg->chroma_idc << 18) |
-			(cfg->lossless_enable << 20) |
-			(cfg->const_intra_pred_flag << 21) |
-			((cfg->chroma_cb_qp_offset & 0x1f) << 22) |
-			((cfg->chroma_cr_qp_offset & 0x1f) << 27);
-		mpp_write(mpp, value, H265E_ENC_SEQ_PARAM);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_GOP_PARAM_CHANGE)
-		mpp_write(mpp, cfg->gop_idx, H265E_ENC_SEQ_GOP_PARAM);
-	if (cfg->cfg_mask & H265E_CFG_INTRA_PARAM_CHANGE) {
-		value = (cfg->decoding_refresh_type << 0) |
-			(cfg->intra_qp << 3) |
-			(cfg->intra_period << 16);
-		mpp_write(mpp, value, H265E_ENC_SEQ_INTRA_PARAM);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_CONF_WIN_TOP_BOT_CHANGE) {
-		value = (cfg->conf_win_bot << 16) | cfg->conf_win_top;
-		mpp_write(mpp, value, H265E_ENC_SEQ_CONF_WIN_TOP_BOT);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_CONF_WIN_LEFT_RIGHT_CHANGE) {
-		value = (cfg->conf_win_right << 16) | cfg->conf_win_left;
-		mpp_write(mpp, value, H265E_ENC_SEQ_CONF_WIN_LEFT_RIGHT);
-	}
-	if (cfg->cfg_mask & H265E_CFG_FRAME_RATE_CHANGE)
-		mpp_write(mpp, cfg->frame_rate, H265E_ENC_SEQ_FRAME_RATE);
-
-	if (cfg->cfg_mask & H265E_CFG_INDEPENDENT_SLICE_CHANGE) {
-		value = (cfg->independ_slice_mode_arg << 16) |
-			cfg->independ_slice_mode;
-		mpp_write(mpp, value, H265E_ENC_SEQ_INDEPENDENT_SLICE);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_DEPENDENT_SLICE_CHANGE) {
-		value = (cfg->depend_slice_mode_arg << 16) |
-			cfg->depend_slice_mode;
-		mpp_write(mpp, value, H265E_ENC_SEQ_DEPENDENT_SLICE);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_INTRA_REFRESH_CHANGE) {
-		value = (cfg->intra_refresh_arg << 16) |
-			cfg->intra_refresh_mode;
-		mpp_write(mpp, value, H265E_ENC_SEQ_INTRA_REFRESH);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_PARAM_CHANGE) {
-		value = (cfg->use_recommend_param) |
-			(cfg->ctu.ctu_qp_enable << 2) |
-			(cfg->scaling_list_enable << 3) |
-			(cfg->cu_size_mode << 4) |
-			(cfg->tmvp_enable << 7) |
-			(cfg->wpp_enable << 8) |
-			(cfg->max_num_merge << 9) |
-			(cfg->dynamic_merge_8x8_enable << 12) |
-			(cfg->dynamic_merge_16x16_enable << 13) |
-			(cfg->dynamic_merge_32x32_enable << 14) |
-			(cfg->disable_deblk << 15) |
-			(cfg->lf_cross_slice_boundary_enable << 16) |
-			((cfg->beta_offset_div2 & 0xF) << 17) |
-			((cfg->tc_offset_div2 & 0xF) << 21) |
-			(cfg->skip_intra_trans << 25) |
-			(cfg->sao_enable << 26) |
-			(cfg->intra_in_inter_slice_enable << 27) |
-			(cfg->intra_nxn_enable << 28);
-
-		mpp_write(mpp, value, H265E_ENC_PARAM);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_RC_PARAM_CHANGE) {
-		value = (cfg->rc_enable << 0) |
-			(cfg->cu_level_rc_enable << 1) |
-			(cfg->hvs_qp_enable << 2) |
-			(cfg->hvs_qp_scale_enable << 3) |
-			(cfg->hvs_qp_scale << 4) |
-			(cfg->bit_alloc_mode << 7) |
-			(cfg->init_buf_levelx8 << 9) |
-			(cfg->ctu.roi_enable << 13) |
-			(cfg->initial_rc_qp << 14) |
-			(cfg->initial_delay << 20);
-		mpp_write(mpp, value, H265E_ENC_RC_PARAM);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_RC_MIN_MAX_QP_CHANGE) {
-		value = (cfg->min_qp << 0) |
-			(cfg->max_qp << 6) |
-			(cfg->max_delta_qp << 12) |
-			((cfg->intra_qp_offset & 0xFFFF) << 18);
-		mpp_write(mpp, value, H265E_ENC_RC_MIN_MAX_QP);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_RC_TARGET_RATE_LAYER_0_3_CHANGE) {
-		value = (cfg->fixed_bit_ratio[0] << 0) |
-			(cfg->fixed_bit_ratio[1] << 8) |
-			(cfg->fixed_bit_ratio[2] << 16) |
-			(cfg->fixed_bit_ratio[3] << 24);
-		mpp_write(mpp, value, H265E_ENC_RC_BIT_RATIO_LAYER_0_3);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_RC_TARGET_RATE_LAYER_4_7_CHANGE) {
-		value = (cfg->fixed_bit_ratio[4] << 0) |
-			(cfg->fixed_bit_ratio[5] << 8) |
-			(cfg->fixed_bit_ratio[6] << 16) |
-			(cfg->fixed_bit_ratio[7] << 24);
-		mpp_write(mpp, value, H265E_ENC_RC_BIT_RATIO_LAYER_4_7);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_SET_NUM_UNITS_IN_TICK) {
-		mpp_write(mpp, cfg->num_units_in_tick,
-			  H265E_ENC_NUM_UNITS_IN_TICK);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_SET_TIME_SCALE) {
-		mpp_write(mpp, cfg->time_scale,
-			  H265E_ENC_TIME_SCALE);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_SET_NUM_TICKS_POC_DIFF_ONE) {
-		mpp_write(mpp, cfg->num_ticks_poc_diff_one,
-			  H265E_ENC_NUM_TICKS_POC_DIFF_ONE);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_NR_PARAM_CHANGE) {
-		value = (cfg->nr_y_enable << 0) |
-			(cfg->nr_cb_enable << 1) |
-			(cfg->nr_cr_enable << 2) |
-			(cfg->nr_noise_est_enable << 3) |
-			(cfg->nr_noise_sigma_y << 4) |
-			(cfg->nr_noise_sigma_cb << 12) |
-			(cfg->nr_noise_sigma_cr << 20);
-		mpp_write(mpp, value, H265E_ENC_NR_PARAM);
-	}
-
-	if (cfg->cfg_mask & H265E_CFG_NR_WEIGHT_CHANGE) {
-		value = (cfg->nr_intra_weight_y << 0) |
-			(cfg->nr_intra_weight_cb << 5) |
-			(cfg->nr_intra_weight_cr << 10) |
-			(cfg->nr_inter_weight_y << 15) |
-			(cfg->nr_inter_weight_cb << 20) |
-			(cfg->nr_inter_weight_cr << 25);
-		mpp_write(mpp, value, H265E_ENC_NR_WEIGHT);
-	}
-	if (cfg->cfg_mask & H265E_CFG_RC_TARGET_RATE_CHANGE)
-		mpp_write(mpp, cfg->bit_rate, H265E_ENC_RC_TARGET_RATE);
-	if (cfg->cfg_mask & H265E_CFG_RC_TRANS_RATE_CHANGE)
-		mpp_write(mpp, cfg->trans_rate, H265E_ENC_RC_TRANS_RATE);
-	if (cfg->cfg_mask & H265E_CFG_ROT_PARAM_CHANGE)
-		mpp_write(mpp, 0, H265E_ENC_ROT_PARAM);
-	if (cfg->cfg_mask == H265E_CFG_CHANGE_SET_PARAM_ALL) {
-		value = (cfg->intra_max_qp << 6) | cfg->intra_min_qp;
-		mpp_write(mpp, value, H265E_ENC_RC_INTRA_MIN_MAX_QP);
-	}
-	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_SET_PARAM);
-	if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-		mpp_err("h265e_wait_busy timeout, index=%d\n", index);
-		goto FAIL;
-	}
-	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-		mpp_err("h265e set common parameter ret fail\n");
-		goto FAIL;
-	}
-	mpp_debug_leave();
-	return 0;
-FAIL:
-	mpp_err("fail,index = %d\n", index);
-	return -1;
-}
-
-static int rockchip_mpp_h265e_set_gop_parameter(struct rockchip_mpp_dev *mpp,
-						int index)
-{
-	u32 value = 0;
-	unsigned int i = 0, j = 0;
-	struct mpp_h265e_cfg *cfg = NULL;
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct rockchip_h265e_instance *instance = NULL;
-
-	mpp_debug_enter();
-
-	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
-		mpp_err("param is invalid,index = %d", index);
-		return -1;
-	}
-
-	instance = &enc->instance[index];
-	cfg = &instance->cfg;
-
-	/* Set up work-buffer */
-	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
-	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
-	mpp_write(mpp, 0, H265E_WORK_PARAM);
-
-	/* Set up temp-buffer */
-	mpp_write(mpp, (u32)enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
-	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
-	mpp_write(mpp, 0, H265E_TEMP_PARAM);
-	/* Secondary AXI */
-#if	H265E_AXI_STATUS
-	mpp_write(mpp, 0x0, H265E_ADDR_SEC_AXI_BASE);
-	mpp_write(mpp, H265E_SEC_AXI_BUF_SIZE, H265E_SEC_AXI_SIZE);
-	mpp_write(mpp, 0xffff, H265E_USE_SEC_AXI);
-#else
-	mpp_write(mpp, 0, H265E_USE_SEC_AXI);
-#endif
-
-	/*
-	 * SET_PARAM + CUSTOM_GOP
-	 * only when gop_size == custom_gop,
-	 * custom_gop related registers should be set
-	 */
-	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
-	if (cfg->gop_idx == PRESET_IDX_CUSTOM_GOP) {
-		mpp_write(mpp, H265E_OPT_CUSTOM_GOP,
-			  H265E_ENC_SET_PARAM_OPTION);
-		mpp_write(mpp, (u32)H265E_CFG_CHANGE_SET_PARAM_ALL,
-			  H265E_ENC_SET_CUSTOM_GOP_ENABLE);
-
-		value = (cfg->gop.custom_gop_size << 0) |
-			(cfg->gop.use_derive_lambda_weight << 4);
-		mpp_write(mpp, value, H265E_ENC_CUSTOM_GOP_PARAM);
-
-		for (i = 0; i < cfg->gop.custom_gop_size; i++) {
-			value = (cfg->gop.pic[i].type << 0) |
-				(cfg->gop.pic[i].offset << 2) |
-				(cfg->gop.pic[i].qp << 6) |
-				((cfg->gop.pic[i].ref_poc_l0 &
-				  0x1F) << 14) |
-				((cfg->gop.pic[i].ref_poc_l1 &
-				  0x1F) << 19) |
-				(cfg->gop.pic[i].temporal_id << 24);
-
-			mpp_write(mpp, value,
-				  H265E_ENC_CUSTOM_GOP_PIC_PARAM_0 + (i * 4));
-			mpp_write(mpp, cfg->gop.gop_pic_lambda[i],
-				  H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_0 + (i * 4));
-		}
-		for (j = i; j < H265E_MAX_GOP_NUM; j++) {
-			mpp_write(mpp, 0,
-				  H265E_ENC_CUSTOM_GOP_PIC_PARAM_0 + (j * 4));
-			mpp_write(mpp, 0,
-				  H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_0 + (j * 4));
-		}
-		rockchip_mpp_h265e_issue_command(mpp,
-						 index,
-						 H265E_CMD_SET_PARAM);
-		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-			mpp_err("h265e_wait_busy timeout, index=%d\n", index);
-			goto FAIL;
-		}
-		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-			mpp_err("h265e set gop ret fail\n");
-			goto FAIL;
-		}
-	}
-
-	value = mpp_read(mpp, H265E_RET_ENC_MIN_FB_NUM);
-	if (value > (u32)instance->min_frame_buffer_count)
-		instance->min_frame_buffer_count = value;
-
-	value = mpp_read(mpp, H265E_RET_ENC_MIN_SRC_BUF_NUM);
-	if (value > (u32)instance->min_src_frame_count)
-		instance->min_src_frame_count = value;
-	mpp_debug(DEBUG_H265E_INFO,
-		  "%s %d,min_frame_buffer_count = %d,min_src_frame_count=%d\n",
-		  __func__, __LINE__, instance->min_frame_buffer_count,
-		  instance->min_src_frame_count);
-	mpp_debug_leave();
-	return 0;
-
-FAIL:
-	mpp_err("fail,index = %d\n", index);
-	return -1;
-}
-
-static int rockchip_mpp_h265e_set_vui_parameter(struct rockchip_mpp_dev *mpp,
-						int index)
-{
-	struct mpp_h265e_cfg *cfg = NULL;
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct rockchip_h265e_instance *instance = NULL;
-	u32 value = 0;
-
-	mpp_debug_enter();
-	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
-		mpp_err("param is invalid,index = %d", index);
-		return -1;
-	}
-
-	instance = &enc->instance[index];
-	cfg = &instance->cfg;
-	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
-
-	/* Set up work-buffer */
-	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
-	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
-	mpp_write(mpp, 0, H265E_WORK_PARAM);
-
-	if (cfg->vui.flags || cfg->vui_rbsp ||
-	    cfg->hrd_rbsp_in_vps || cfg->hrd_rbsp_in_vui) {
-		/*** VUI encoding by host registers ***/
-		if (cfg->vui.flags) {
-			mpp_write(mpp, H265E_OPT_VUI,
-				  H265E_ENC_SET_PARAM_OPTION);
-			mpp_write(mpp, cfg->vui.flags,
-				  H265E_ENC_VUI_PARAM_FLAGS);
-			mpp_write(mpp, cfg->vui.aspect_ratio_idc,
-				  H265E_ENC_VUI_ASPECT_RATIO_IDC);
-			mpp_write(mpp, cfg->vui.sar_size,
-				  H265E_ENC_VUI_SAR_SIZE);
-			mpp_write(mpp, cfg->vui.over_scan_appropriate,
-				  H265E_ENC_VUI_OVERSCAN_APPROPRIATE);
-			mpp_write(mpp, cfg->vui.signal,
-				  H265E_ENC_VUI_VIDEO_SIGNAL);
-			mpp_write(mpp, cfg->vui.chroma_sample_loc,
-				  H265E_ENC_VUI_CHROMA_SAMPLE_LOC);
-			mpp_write(mpp, cfg->vui.disp_win_left_right,
-				  H265E_ENC_VUI_DISP_WIN_LEFT_RIGHT);
-			mpp_write(mpp, cfg->vui.disp_win_top_bottom,
-				  H265E_ENC_VUI_DISP_WIN_TOP_BOT);
-		} else {
-			mpp_write(mpp, 0, H265E_ENC_VUI_PARAM_FLAGS);
-		}
-		if (cfg->vui_rbsp ||
-		    cfg->hrd_rbsp_in_vps ||
-		    cfg->hrd_rbsp_in_vui) {
-			/*** VUI encoding by given rbsp data ***/
-			mpp_write(mpp, H265E_OPT_VUI,
-				  H265E_ENC_SET_PARAM_OPTION);
-			value = (cfg->hrd_rbsp_in_vps << 2) |
-				(cfg->hrd_rbsp_in_vui << 1) |
-				(cfg->vui_rbsp);
-			mpp_write(mpp, value,
-				  H265E_ENC_VUI_HRD_RBSP_PARAM_FLAG);
-			mpp_write(mpp, cfg->vui_rbsp_data_addr,
-				  H265E_ENC_VUI_RBSP_ADDR);
-			mpp_write(mpp, cfg->vui_rbsp_data_size,
-				  H265E_ENC_VUI_RBSP_SIZE);
-			mpp_write(mpp, cfg->hrd_rbsp_data_addr,
-				  H265E_ENC_HRD_RBSP_ADDR);
-			mpp_write(mpp, cfg->hrd_rbsp_data_size,
-				  H265E_ENC_HRD_RBSP_SIZE);
-		} else {
-			mpp_write(mpp, 0, H265E_ENC_VUI_HRD_RBSP_PARAM_FLAG);
-		}
-		rockchip_mpp_h265e_issue_command(mpp,
-						 index,
-						 H265E_CMD_SET_PARAM);
-		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-			mpp_err("h265e_wait_busy timeout, index=%d\n", index);
-			goto FAIL;
-		}
-		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-			mpp_err("h265e set vui ret fail\n");
-			goto FAIL;
-		}
-	}
-
-	mpp_debug_leave();
-	return 0;
-FAIL:
-	mpp_err("fail,index = %d\n", index);
-	return -1;
-}
-
-static int rockchip_mpp_h265e_set_parameter(struct rockchip_mpp_dev *mpp,
-					    int index)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct rockchip_h265e_instance *instance = &enc->instance[index];
-
-	mpp_debug_enter();
-	mutex_lock(&enc->lock);
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_enable_clk(mpp);
-#endif
-	mpp_dev_power_on(mpp);
-	if (instance->status != H265E_INSTANCE_STATUS_OPENED) {
-		mpp_err("error:status = %d\n", instance->status);
-		goto FAIL;
-	}
-	instance->cfg.cfg_mask = H265E_CFG_CHANGE_SET_PARAM_ALL;
-	if (rockchip_mpp_h265e_set_common_parameter(mpp, index) != 0)
-		goto FAIL;
-	if (rockchip_mpp_h265e_set_gop_parameter(mpp, index) != 0)
-		goto FAIL;
-	if (rockchip_mpp_h265e_set_vui_parameter(mpp, index) != 0)
-		goto FAIL;
-	if (rockchip_mpp_h265e_register_frame_buffer(mpp, index) != 0)
-		goto FAIL;
-	instance->status = H265E_INSTANCE_STATUS_SET_PARAMETER;
-	instance->cfg.cfg_mask = 0;
-	instance->cfg.cfg_option = 0;
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_disable_clk(mpp);
-#endif
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-	return 0;
-FAIL:
-	instance->status = H265E_INSTANCE_STATUS_ERROR;
-	mutex_unlock(&enc->lock);
-	mpp_err("fail,index = %d\n", index);
-	return -1;
-}
-
-static int rockchip_mpp_h265e_change_parameter(struct rockchip_mpp_dev *mpp,
-					       int index)
-{
-	struct rockchip_h265e_dev *enc =
-					container_of(mpp,
-						     struct rockchip_h265e_dev,
-						     dev);
-	struct rockchip_h265e_instance *instance = &enc->instance[index];
-	u32 enable = instance->cfg.cfg_option;
-
-	mpp_debug_enter();
-	mutex_lock(&enc->lock);
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_enable_clk(mpp);
-#endif
-	mpp_dev_power_on(mpp);
-	if (instance->status == H265E_INSTANCE_STATUS_ERROR ||
-	    instance->status == H265E_INSTANCE_STATUS_CLOSE) {
-		mpp_err("error:status = %d\n", instance->status);
-		goto FAIL;
-	}
-
-	instance->status = H265E_INSTANCE_STATUS_OPENED;
-	if (enable & H265E_PARAM_CHANEGED_COMMON) {
-		if (rockchip_mpp_h265e_set_common_parameter(mpp, index) != 0)
-			goto FAIL;
-	}
-	if (enable & H265E_PARAM_CHANEGED_CUSTOM_GOP) {
-		if (rockchip_mpp_h265e_set_gop_parameter(mpp, index) != 0)
-			goto FAIL;
-	}
-	if (enable & H265E_PARAM_CHANEGED_REGISTER_BUFFER) {
-		rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
-		if (rockchip_mpp_h265e_register_frame_buffer(mpp, index) != 0)
-			goto FAIL;
-	}
-	instance->status = H265E_INSTANCE_STATUS_SET_PARAMETER;
-	instance->cfg.cfg_mask = 0;
-	instance->cfg.cfg_option = 0;
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_disable_clk(mpp);
-#endif
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-	return 0;
-FAIL:
-	instance->status = H265E_INSTANCE_STATUS_ERROR;
-	mutex_unlock(&enc->lock);
-	mpp_err("fail,index = %d\n", index);
-	return -1;
-}
-
-static u32 rockchip_mpp_h265e_get_fb_luma_size(u32 map_type,
-					       u32 stride, u32 height)
-{
-	u32 size = stride * height;
-
-	if (map_type == LINEAR_FRAME_MAP)
-		size = stride * height;
-	else if (map_type == COMPRESSED_FRAME_MAP)
-		size = stride * height;
-	else if (map_type == TILED_SUB_CTU_MAP)
-		size = (ALIGN(stride, 32) * ALIGN(height, 32));
-	else
-		mpp_err("unsupport may_type = %d\n", map_type);
-
-	return size;
-}
-
-static u32 rockchip_mpp_h265e_get_fb_chroma_size(u32 map_type,
-						 u32 stride, u32 height)
-{
-	u32 size = 0;
-	u32 chroma_width = stride >> 1;
-	u32 chroma_height = height >> 1;
-
-	if (map_type == LINEAR_FRAME_MAP) {
-		size = chroma_width * chroma_height;
-	} else if (map_type == COMPRESSED_FRAME_MAP) {
-		chroma_width = ALIGN(chroma_width, 16);
-		size = chroma_width * chroma_height;
-	} else if (map_type == TILED_SUB_CTU_MAP) {
-		chroma_width = ALIGN(chroma_width, 16);
-		size = chroma_width * chroma_height / 2;
-	} else {
-		mpp_err("unsupport may_type = %d\n", map_type);
-	}
-
-	return size;
-}
-
-static
-int rockchip_mpp_h265e_register_frame_buffer(struct rockchip_mpp_dev *mpp,
-					     int index)
-{
-	struct mpp_h265e_cfg *cfg = NULL;
-	struct rockchip_h265e_dev *enc =
-				container_of(mpp,
-					     struct rockchip_h265e_dev,
-					     dev);
-	struct rockchip_h265e_instance *instance = NULL;
-	int buf_width = 0;
-	int buf_height = 0;
-	int luma_stride = 0;
-	int chroma_stride = 0;
-	int count = 0;
-	u32 value, mv_col_size = 0;
-	u32 fbc_y_table_size = 0, fbc_c_table_size = 0, sub_sampled_size = 0;
-	int q, j, i, remain, idx;
-	int start_no, end_no;
-	u32 addr_y, addr_cb, addr_cr;
-	int stride;
-	u32 axi_id = 0;
-	int	size_rec_luma, size_rec_chroma;
-	struct mpp_h265e_buffer *buffer = NULL;
-	int interlace = 0;
-	struct mpp_h265e_frame_buffer *frame_buffer = NULL;
-
-	mpp_debug_enter();
-	if (!mpp || index < 0 || index >= H265E_INSTANCE_NUM) {
-		mpp_err("parameter is invalid, index = %d\n", index);
-		return -1;
-	}
-	instance = &enc->instance[index];
-	cfg = &instance->cfg;
-	interlace = (cfg->src_format == H265E_SRC_YUV_420_NV12) ||
-		    (cfg->src_format == H265E_SRC_YUV_420_NV21);
-
-	stride = ALIGN(cfg->width, 32);
-
-	buf_width = ALIGN(cfg->width, 8);
-	buf_height = ALIGN(cfg->height, 8);
-
-	size_rec_luma =
-			rockchip_mpp_h265e_get_fb_luma_size(cfg->map_type,
-							    stride, buf_height);
-	size_rec_chroma =
-			  rockchip_mpp_h265e_get_fb_chroma_size(cfg->map_type,
-								stride,
-								buf_height);
-
-	count = instance->min_frame_buffer_count;
-	memset(&instance->mv, 0, sizeof(struct mpp_h265e_buffer));
-	memset(&instance->fbc_luma, 0, sizeof(struct mpp_h265e_buffer));
-	memset(&instance->fbc_chroma, 0, sizeof(struct mpp_h265e_buffer));
-	if (cfg->map_type == COMPRESSED_FRAME_MAP) {
-		mv_col_size = H265E_MVCOL_BUF_SIZE(buf_width, buf_height);
-		mv_col_size = ALIGN(mv_col_size, 16);
-
-		instance->mv.size = ALIGN(mv_col_size * count, 4096) + 4096;
-		instance->mv.hdl =
-			rockchip_mpp_h265e_dma_alloc(mpp,
-						     instance->session,
-						     instance->mv.size,
-						     MPP_ALIGN_SIZE,
-						     &instance->mv.dma_addr);
-		if (instance->mv.hdl < 0) {
-			mpp_err("alloc mv buffer fail,index = %d\n", index);
-			goto FAIL;
-		}
-
-		fbc_y_table_size =
-			H265E_FBC_LUMA_TABLE_SIZE(buf_width,
-						  buf_height);
-		fbc_y_table_size =
-			ALIGN(fbc_y_table_size, 16);
-		instance->fbc_luma.size =
-			ALIGN(fbc_y_table_size * count, 4096) + 4096;
-		instance->fbc_luma.hdl =
-			rockchip_mpp_h265e_dma_alloc(mpp,
-						     instance->session,
-						     instance->fbc_luma.size,
-						     MPP_ALIGN_SIZE,
-						     &instance->fbc_luma.dma_addr);
-		if (instance->fbc_luma.hdl < 0) {
-			mpp_err("alloc fbc y buffer fail,index = %d\n", index);
-			goto FAIL;
-		}
-
-		fbc_c_table_size =
-				H265E_FBC_CHROMA_TABLE_SIZE(buf_width,
-							    buf_height);
-		fbc_c_table_size = ALIGN(fbc_c_table_size, 16);
-		instance->fbc_chroma.size = ALIGN(fbc_c_table_size * count,
-						  4096) + 4096;
-		instance->fbc_chroma.hdl =
-			rockchip_mpp_h265e_dma_alloc(mpp,
-						     instance->session,
-						     instance->fbc_chroma.size,
-						     MPP_ALIGN_SIZE,
-						     &instance->fbc_chroma.dma_addr);
-		if (instance->fbc_chroma.hdl < 0) {
-			mpp_err("alloc fbc c buffer fail,index = %d\n", index);
-			goto FAIL;
-		}
-	}
-
-	sub_sampled_size = H265E_SUBSAMPLED_ONE_SIZE(buf_width, buf_height);
-	memset(&instance->sub_sample, 0, sizeof(struct mpp_h265e_buffer));
-	instance->sub_sample.size =
-		ALIGN(sub_sampled_size * count, 4096) + 4096;
-	instance->sub_sample.hdl =
-		rockchip_mpp_h265e_dma_alloc(mpp,
-					     instance->session,
-					     instance->sub_sample.size,
-					     MPP_ALIGN_SIZE,
-					     &instance->sub_sample.dma_addr);
-	if (instance->sub_sample.hdl < 0) {
-		mpp_err("alloc fbc c buffer fail,index = %d\n", index);
-		goto FAIL;
-	}
-	mpp_write(mpp, (u32)instance->sub_sample.dma_addr,
-		  H265E_ADDR_SUB_SAMPLED_FB_BASE);
-	mpp_write(mpp, sub_sampled_size, H265E_SUB_SAMPLED_ONE_FB_SIZE);
-
-	value = (buf_width << 16) | buf_height;
-	mpp_write(mpp, value, H265E_PIC_SIZE);
-
-	luma_stride = ALIGN(cfg->width, 16) * 4;
-	luma_stride = ALIGN(luma_stride, 32);
-	chroma_stride = ALIGN(cfg->width / 2, 16) * 4;
-	chroma_stride = ALIGN(chroma_stride, 32);
-	value = (luma_stride << 16) | chroma_stride;
-	mpp_write(mpp, value, H265E_FBC_STRIDE);
-
-	value = ((cfg->src_format == H265E_SRC_YUV_420_NV21) << 29) |
-		((cfg->map_type == LINEAR_FRAME_MAP) << 28) |
-		(axi_id << 24) |
-		(interlace << 16) |
-		stride;
-	mpp_write(mpp, value, H265E_COMMON_PIC_INFO);
-
-	memset(&instance->frame_buffer, -1, sizeof(instance->frame_buffer));
-	/* set frame buffer address*/
-	for (i = 0; i < count; i++) {
-		frame_buffer = &instance->frame_buffer[i];
-		buffer = &frame_buffer->buffer;
-		buffer->size = size_rec_luma + 2 * size_rec_chroma;
-		buffer->hdl = rockchip_mpp_h265e_dma_alloc(mpp,
-							   instance->session,
-							   buffer->size,
-							   MPP_ALIGN_SIZE,
-							   &buffer->dma_addr);
-		if (buffer->hdl < 0) {
-			mpp_err("alloc fbc y buffer fail,index = %d\n", index);
-			goto FAIL;
-		}
-
-		frame_buffer->y = (u32)buffer->dma_addr;
-		frame_buffer->cb = frame_buffer->y + size_rec_luma;
-		frame_buffer->cr = frame_buffer->cb + size_rec_chroma;
-	}
-
-	remain = count;
-	q      = (remain + 7) / 8;
-	idx    = 0;
-	for (j = 0; j < q; j++) {
-		value = (cfg->fb_endian << 16) |
-			((j == q - 1) << 4) |
-			((j == 0) << 3);
-		mpp_write(mpp, value, H265E_SFB_OPTION);
-		start_no = j * 8;
-		end_no   = start_no + (remain >= 8 ? 8 : remain) - 1;
-		value = (start_no << 8) | end_no;
-		mpp_write(mpp, value, H265E_SET_FB_NUM);
-		for (i = 0; i < 8 && i < remain; i++) {
-			frame_buffer = &instance->frame_buffer[i];
-			addr_y  = frame_buffer->y;
-			addr_cb = frame_buffer->cb;
-			addr_cr = frame_buffer->cr;
-			mpp_write(mpp, addr_y,
-				  H265E_ADDR_LUMA_BASE0 + (i << 4));
-			mpp_write(mpp, addr_cb,
-				  H265E_ADDR_CB_BASE0 + (i << 4));
-			if (cfg->map_type == COMPRESSED_FRAME_MAP) {
-				mpp_write(mpp,
-					  ((u32)instance->fbc_luma.dma_addr) +
-					  idx * fbc_y_table_size,
-					  H265E_ADDR_FBC_Y_OFFSET0 + (i << 4));
-				mpp_write(mpp,
-					  ((u32)instance->fbc_chroma.dma_addr) +
-					  idx * fbc_c_table_size,
-					  H265E_ADDR_FBC_C_OFFSET0 + (i << 4));
-				mpp_write(mpp, ((u32)instance->mv.dma_addr) +
-					  idx * mv_col_size,
-					  H265E_ADDR_MV_COL0 + (i << 2));
-			} else {
-				mpp_write(mpp, addr_cr,
-					  H265E_ADDR_CR_BASE0 + (i << 4));
-				mpp_write(mpp, 0,
-					  H265E_ADDR_FBC_C_OFFSET0 + (i << 4));
-				mpp_write(mpp, 0,
-					  H265E_ADDR_MV_COL0 + (i << 2));
-			}
-			idx++;
-		}
-		remain -= i;
-		mpp_write(mpp, (u32)instance->work.dma_addr,
-			  H265E_ADDR_WORK_BASE);
-		mpp_write(mpp, (u32)instance->work.size, H265E_WORK_SIZE);
-		mpp_write(mpp, 0, H265E_WORK_PARAM);
-		rockchip_mpp_h265e_issue_command(mpp,
-						 index,
-						 H265E_CMD_SET_FRAMEBUF);
-		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
-			goto FAIL;
-		}
-	}
-	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-		mpp_err("h265e register frame buffer ret fail\n");
-		goto FAIL;
-	}
-	mpp_debug_leave();
-	return 0;
-FAIL:
-	rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
-	mpp_err("fail,index = %d\n", index);
-	return -1;
-}
-
-static int rockchip_mpp_h265e_encode_one_frame(struct rockchip_mpp_dev *mpp,
-					       struct h265e_ctx *ctx,
-					       int index)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct mpp_h265e_encode_info *en_info = &ctx->cfg;
-	struct rockchip_h265e_instance *instance = &enc->instance[index];
-	struct mpp_h265e_cfg *cfg = &instance->cfg;
-	int luma_stride = 0;
-	int chroma_stride = 0;
-	int src_format = 0;
-	u32 value, src_y, src_cb, src_cr;
-	int interlace = 0;
-	u32 roi_enable = 0;
-	u32 ctu_qp_enable = 0;
-
-	mpp_debug_enter();
-	if (!cfg || !ctx)
-		return -1;
-
-	mutex_lock(&enc->lock);
-	h265e_last = ktime_get();
-#if H265E_POWER_SAVE
-	rockchip_mpp_h265e_enable_clk(mpp);
-#endif
-	mpp_dev_power_on(mpp);
-	if (instance->status != H265E_INSTANCE_STATUS_SET_PARAMETER) {
-		mutex_unlock(&enc->lock);
-		mpp_err("fail,status = %d,index = %d\n",
-			instance->status, index);
-		return -1;
-	}
-
-	luma_stride = cfg->width_stride;
-	interlace = (cfg->src_format == H265E_SRC_YUV_420_NV12) ||
-		    (cfg->src_format == H265E_SRC_YUV_420_NV21);
-	if (cfg->src_format == H265E_SRC_YUV_420_NV12)
-		src_format = 0x02;
-	else if (cfg->src_format == H265E_SRC_YUV_420_NV21)
-		src_format = 0x03;
-	if (cfg->map_type == TILED_SUB_CTU_MAP)
-		src_format = 0x1;
-	mpp_write(mpp, 0xfffffff2, H265E_PERF_LATENCY_CTRL0);
-	mpp_write(mpp, (u32)ctx->bs.dma_addr, H265E_BS_START_ADDR);
-	mpp_write(mpp, ctx->bs.size, H265E_BS_SIZE);
-	mpp_write(mpp, (u32)ctx->bs.dma_addr, H265E_BS_RD_PTR);
-	mpp_write(mpp, (u32)ctx->bs.dma_addr, H265E_BS_WR_PTR);
-
-	value = (cfg->line_buf_int_en << 6) |
-		(cfg->slice_int_enable << 5) |
-		(cfg->ring_buffer_enable << 4) |
-		cfg->bs_endian;
-	mpp_write(mpp, value, H265E_BS_PARAM);
-	mpp_write(mpp, 0, H265E_BS_OPTION);
-
-	mpp_write(mpp, instance->work.dma_addr, H265E_ADDR_WORK_BASE);
-	mpp_write(mpp, instance->work.size, H265E_WORK_SIZE);
-	mpp_write(mpp, 0, H265E_WORK_PARAM);
-
-	mpp_write(mpp, enc->temp.dma_addr, H265E_ADDR_TEMP_BASE);
-	mpp_write(mpp, enc->temp.size, H265E_TEMP_SIZE);
-	mpp_write(mpp, 0, H265E_TEMP_PARAM);
-
-#if	H265E_AXI_STATUS
-	mpp_write(mpp, 0x0, H265E_ADDR_SEC_AXI_BASE);
-	mpp_write(mpp, H265E_SEC_AXI_BUF_SIZE, H265E_SEC_AXI_SIZE);
-	mpp_write(mpp, 0xffff, H265E_USE_SEC_AXI);
-#else
-	mpp_write(mpp, 0, H265E_USE_SEC_AXI);
-#endif
-	if (cfg->code_option.implicit_header_encode == 1) {
-		value = CODEOPT_ENC_HEADER_IMPLICIT	|
-			CODEOPT_ENC_VCL	|
-			(cfg->code_option.encode_aud << 5) |
-			(cfg->code_option.encode_eos << 6) |
-			(cfg->code_option.encode_eob << 7);
-	} else {
-		value = (cfg->code_option.implicit_header_encode << 0) |
-			(cfg->code_option.encode_vcl << 1) |
-			(cfg->code_option.encode_vps << 2) |
-			(cfg->code_option.encode_sps << 3) |
-			(cfg->code_option.encode_pps << 4) |
-			(cfg->code_option.encode_aud << 5) |
-			(cfg->code_option.encode_eos << 6) |
-			(cfg->code_option.encode_eob << 7) |
-			(cfg->code_option.encode_vui << 9);
-	}
-
-	mpp_write(mpp, value, H265E_CMD_ENC_CODE_OPTION);
-
-	value = (en_info->skip_pic << 0) |
-		(en_info->force_qp_enable << 1) |
-		(en_info->force_qp_i << 2) |
-		(en_info->force_qp_p << 8) |
-		(0 << 14) |
-		(en_info->force_frame_type_enable << 20) |
-		(en_info->force_frame_type << 21);
-	mpp_write(mpp, value, H265E_CMD_ENC_PIC_PARAM);
-	if (en_info->stream_end == 1) {
-		mpp_debug(DEBUG_H265E_INFO,
-			  "%s %d instance %d en_info->stream_end\n",
-			  __func__, __LINE__, index);
-		mpp_write(mpp, 0xFFFFFFFE, H265E_CMD_ENC_SRC_PIC_IDX);
-	} else {
-		mpp_write(mpp, instance->src_idx, H265E_CMD_ENC_SRC_PIC_IDX);
-	}
-	instance->src_idx++;
-	instance->src_idx = instance->src_idx % instance->min_src_frame_count;
-	src_y = (u32)ctx->src.dma_addr;
-	src_cb = src_y + luma_stride * cfg->height_stride;
-	src_cr = src_cb + luma_stride * cfg->height_stride / 4;
-	mpp_write(mpp, src_y, H265E_CMD_ENC_SRC_ADDR_Y);
-	if (cfg->src_format == H265E_SRC_YUV_420_YV12) {
-		mpp_write(mpp, src_cb, H265E_CMD_ENC_SRC_ADDR_V);
-		mpp_write(mpp, src_cr, H265E_CMD_ENC_SRC_ADDR_U);
-	} else {
-		mpp_write(mpp, src_cb, H265E_CMD_ENC_SRC_ADDR_U);
-		mpp_write(mpp, src_cr, H265E_CMD_ENC_SRC_ADDR_V);
-	}
-	chroma_stride = (interlace == 1) ? luma_stride : (luma_stride >> 1);
-	if (cfg->map_type == TILED_SUB_CTU_MAP)
-		chroma_stride = luma_stride;
-	mpp_write(mpp, (luma_stride << 16) | chroma_stride,
-		  H265E_CMD_ENC_SRC_STRIDE);
-	value = (src_format << 0) | (cfg->src_endian << 6);
-	mpp_write(mpp, value, H265E_CMD_ENC_SRC_FORMAT);
-	value = 0;
-	if (cfg->sei.prefix_sei_nal_enable) {
-		mpp_write(mpp, cfg->sei.prefix_sei_nal_addr,
-			  H265E_CMD_ENC_PREFIX_SEI_NAL_ADDR);
-		value = cfg->sei.prefix_sei_data_size << 16 |
-			cfg->sei.prefix_sei_data_order << 1 |
-			cfg->sei.prefix_sei_nal_enable;
-	}
-	mpp_write(mpp, value, H265E_CMD_ENC_PREFIX_SEI_INFO);
-
-	value = 0;
-	if (cfg->sei.suffix_sei_nal_enable) {
-		mpp_write(mpp, cfg->sei.suffix_sei_nal_addr,
-			  H265E_CMD_ENC_SUFFIX_SEI_NAL_ADDR);
-		value = (cfg->sei.suffix_sei_data_size << 16) |
-			(cfg->sei.suffix_sei_data_enc_order << 1) |
-			cfg->sei.suffix_sei_nal_enable;
-	}
-	mpp_write(mpp, value, H265E_CMD_ENC_SUFFIX_SEI_INFO);
-
-	mpp_write(mpp, (u32)ctx->roi.dma_addr,
-		  H265E_CMD_ENC_ROI_ADDR_CTU_MAP);
-	mpp_write(mpp, (u32)ctx->ctu.dma_addr,
-		  H265E_CMD_ENC_CTU_QP_MAP_ADDR);
-
-	if (ctx->roi.dma_addr == 0 || ctx->roi.hdl < 0)
-		roi_enable = 0;
-	else
-		roi_enable = cfg->ctu.roi_enable;
-
-	if (ctx->ctu.dma_addr == 0 || ctx->ctu.hdl < 0)
-		ctu_qp_enable = 0;
-	else
-		ctu_qp_enable = cfg->ctu.ctu_qp_enable;
-	value = ((roi_enable) << 0) |
-			(cfg->ctu.roi_delta_qp << 1) |
-			(ctu_qp_enable << 9) |
-			(cfg->ctu.map_endian << 12) |
-			(cfg->ctu.map_stride << 16);
-
-	mpp_debug(DEBUG_H265E_INFO,
-		  "roi_enable = %d,roi_delta_qp = %d,ctu_qp_enable = %d\n",
-		  cfg->ctu.roi_enable, cfg->ctu.roi_delta_qp, ctu_qp_enable);
-	mpp_write(mpp, value,
-		  H265E_CMD_ENC_CTU_OPT_PARAM);
-
-	mpp_write(mpp, 0, H265E_CMD_ENC_SRC_TIMESTAMP_LOW);
-	mpp_write(mpp, 0, H265E_CMD_ENC_SRC_TIMESTAMP_HIGH);
-
-	value = (cfg->use_cur_as_longterm_pic << 0) |
-		(cfg->use_longterm_ref << 1);
-	mpp_write(mpp, value, H265E_CMD_ENC_LONGTERM_PIC);
-
-	mpp_write(mpp, 0, H265E_CMD_ENC_SUB_FRAME_SYNC_CONFIG);
-	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_ENC_PIC);
-	mpp_debug_leave();
-	return 0;
-}
-
-static int rockchip_mpp_h265e_get_encode_result(struct rockchip_mpp_dev *mpp,
-						struct h265e_ctx *ctx)
-{
-	u32 value, rd, wt;
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct h265e_result *result = NULL;
-	struct h265e_session *session = NULL;
-	int index;
-
-	mpp_debug_enter();
-	if (!mpp || !ctx) {
-		mpp_err("param is invalid");
-		return -1;
-	}
-	session = container_of(ctx->ictx.session,
-			       struct h265e_session,
-			       isession);
-	index = session->instance_index;
-	result = &ctx->result;
-	value = mpp_read(mpp, H265E_RET_SUCCESS);
-	if (value == 0) {
-		result->fail_reason = mpp_read(mpp, H265E_RET_FAIL_REASON);
-		mpp_err("fail reason = 0x%x", result->fail_reason);
-		mutex_unlock(&enc->lock);
-		mpp_debug_leave();
-		return -1;
-	}
-	result->fail_reason = 0;
-	result->enc_pic_cnt = mpp_read(mpp, H265E_RET_ENC_PIC_NUM);
-	value = mpp_read(mpp, H265E_RET_ENC_PIC_TYPE);
-	result->pic_type         = value & 0xFFFF;
-	result->recon_frame_index = mpp_read(mpp, H265E_RET_ENC_PIC_IDX);
-	result->num_of_slice     = mpp_read(mpp, H265E_RET_ENC_PIC_SLICE_NUM);
-	result->pick_skipped     = mpp_read(mpp, H265E_RET_ENC_PIC_SKIP);
-	result->num_intra        = mpp_read(mpp, H265E_RET_ENC_PIC_NUM_INTRA);
-	result->num_merge        = mpp_read(mpp, H265E_RET_ENC_PIC_NUM_MERGE);
-	result->num_skip_block   = mpp_read(mpp, H265E_RET_ENC_PIC_NUM_SKIP);
-	result->avg_ctu_qp       = mpp_read(mpp, H265E_RET_ENC_PIC_AVG_CU_QP);
-	result->bs_size          = mpp_read(mpp, H265E_RET_ENC_PIC_BYTE);
-	result->gop_idx    = mpp_read(mpp, H265E_RET_ENC_GOP_PIC_IDX);
-	result->poc       = mpp_read(mpp, H265E_RET_ENC_PIC_POC);
-	result->src_idx       = mpp_read(mpp, H265E_RET_ENC_USED_SRC_IDX);
-	rd = mpp_read(mpp, H265E_BS_RD_PTR);
-	wt = mpp_read(mpp, H265E_BS_WR_PTR);
-#if PRINT_BS_DATA
-	w_bs_size = result->bs_size;
-#endif
-	h265e_now = ktime_get();
-	mpp_debug(DEBUG_H265E_ENCODE_ONE_FRAME,
-		  "h265e encode time is:%d us\n",
-		  (int)ktime_to_us(ktime_sub(h265e_now, h265e_last)));
-	mpp_debug(DEBUG_H265E_ENCODE_ONE_FRAME,
-		  "RD_AXI_BYTE=%d,WR_AXI_BYTE=%d,WORK_CNT=%d\n",
-		  mpp_read(mpp, H265E_PERF_RD_AXI_TOTAL_BYTE),
-		  mpp_read(mpp, H265E_PERF_WR_AXI_TOTAL_BYTE),
-		  mpp_read(mpp, H265E_PERF_WORKING_CNT));
-	mpp_debug(DEBUG_H265E_ENCODE_ONE_FRAME,
-		  "index = %d, bs_size = %d,size = %d\n",
-		  index, result->bs_size, wt - rd);
-	if (result->recon_frame_index < 0)
-		result->bs_size   = 0;
-#if H265E_POWER_SAVE
-	rockchip_mpp_h265e_disable_clk(mpp);
-#endif
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-	return 0;
-}
-
-static long rockchip_mpp_h265e_ioctl(struct mpp_session *isession,
-				     unsigned int cmd,
-				     unsigned long arg)
-{
-	struct rockchip_mpp_dev *mpp = isession->mpp;
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-
-	struct rockchip_h265e_instance *instance = NULL;
-	struct h265e_session *session =
-					container_of(isession,
-						     struct h265e_session,
-						     isession);
-
-	int ret = 0;
-	int index = session->instance_index;
-
-	if (index < 0 || index >= H265E_INSTANCE_NUM) {
-		mpp_err("error: index = %d is invalid\n", index);
-		return -1;
-	}
-
-	instance = &enc->instance[index];
-	switch (cmd) {
-	case MPP_DEV_H265E_SET_COLOR_PALETTE:
-		break;
-	case MPP_DEV_H265E_SET_PARAMETER:
-		if (copy_from_user(&instance->cfg, (void __user *)arg,
-				   sizeof(struct mpp_h265e_cfg))) {
-			mpp_err("error: set reg copy_from_user failed\n");
-			return -EFAULT;
-		}
-		if (instance->status == H265E_INSTANCE_STATUS_OPENED)
-			ret = rockchip_mpp_h265e_set_parameter(mpp, index);
-		else
-			ret = rockchip_mpp_h265e_change_parameter(mpp, index);
-		break;
-	case MPP_DEV_H265E_GET_HEAD_PARAMETER:
-		{
-			struct hal_h265e_header head;
-
-			if (copy_from_user(&head,
-					   (void __user *)arg, sizeof(head))) {
-				mpp_err("error: set reg copy_from_user failed\n");
-				return -EFAULT;
-			}
-			head.size = 0;
-#ifdef	H265E_STREAM_HEADER
-			if (rockchip_mpp_h265e_get_stream_header(mpp,
-								 index, &head))
-				head.size = 0;
-#endif
-			if (copy_to_user((void __user *)arg,
-					 &head, sizeof(head))) {
-				mpp_err("copy result to user failed\n");
-				return -1;
-			}
-		}
-		break;
-	default:
-		break;
-	}
-	return ret;
-}
-
-struct mpp_dev_ops h265e_ops = {
-	.init = rockchip_mpp_h265e_ctx_init,
-	.prepare = NULL,
-	.run = rockchip_mpp_h265e_run,
-	.done = rockchip_mpp_h265e_done,
-	.irq = rockchip_mpp_h265e_irq,
-	.result = rockchip_mpp_h265e_result,
-	.ioctl = rockchip_mpp_h265e_ioctl,
-	.open = rockchip_mpp_h265e_open,
-	.release = rockchip_mpp_h265e_release,
-	.free = rockchip_mpp_h265e_free,
-};
-
-static void rockchip_mpp_h265e_enable_clk(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-
-	if (enc->aclk)
-		clk_prepare_enable(enc->aclk);
-	if (enc->pclk)
-		clk_prepare_enable(enc->pclk);
-	if (enc->core)
-		clk_prepare_enable(enc->core);
-	if (enc->dsp)
-		clk_prepare_enable(enc->dsp);
-#if H265E_AXI_STATUS
-	if (enc->aclk_axi2sram)
-		clk_prepare_enable(enc->aclk_axi2sram);
-#endif
-}
-
-static void rockchip_mpp_h265e_disable_clk(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-
-	if (enc->dsp)
-		clk_disable_unprepare(enc->dsp);
-	if (enc->core)
-		clk_disable_unprepare(enc->core);
-	if (enc->pclk)
-		clk_disable_unprepare(enc->pclk);
-	if (enc->aclk)
-		clk_disable_unprepare(enc->aclk);
-#if H265E_AXI_STATUS
-	if (enc->aclk_axi2sram)
-		clk_disable_unprepare(enc->aclk_axi2sram);
-#endif
-}
-
-static void rockchip_mpp_h265e_power_on(struct rockchip_mpp_dev *mpp)
-{
-	rockchip_mpp_h265e_enable_clk(mpp);
-}
-
-static void rockchip_mpp_h265e_power_off(struct rockchip_mpp_dev *mpp)
-{
-	rockchip_mpp_h265e_disable_clk(mpp);
-}
-
-static struct mpp_session *rockchip_mpp_h265e_open(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct h265e_session *session = kzalloc(sizeof(*session), GFP_KERNEL);
-	u32 code_base;
-	u32	i, reg_val = 0, remap_size = 0, ret;
-	struct rockchip_h265e_instance *instance = NULL;
-	int index = 0;
-
-	mpp_debug_enter();
-	mutex_lock(&enc->lock);
-	if (!session) {
-		mpp_err("failed to allocate h265e_session data");
-		goto NFREE_FAIL;
-	}
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_enable_clk(mpp);
-#endif
-	mpp_dev_power_on(mpp);
-
-	for (i = 0; i < H265E_INSTANCE_NUM; i++) {
-		instance = &enc->instance[i];
-		instance->session = &session->isession;
-		if (!atomic_read(&instance->is_used)) {
-			instance->work.size = H265E_WORK_BUFFER_SIZE;
-			instance->work.hdl =
-				rockchip_mpp_h265e_dma_alloc(mpp,
-							     instance->session,
-							     instance->work.size,
-							     MPP_ALIGN_SIZE,
-							     &instance->work.dma_addr);
-			instance->index = i;
-			atomic_set(&instance->is_used, 1);
-			break;
-		}
-	}
-	if (i == H265E_INSTANCE_NUM) {
-		mpp_err("error: the num of instance up to H265E_INSTANCE_NUM\n");
-		goto NFREE_FAIL;
-	}
-
-	if (!atomic_read(&enc->load_firmware)) {
-		ret = rockchip_mpp_h265e_load_firmware(mpp, instance->session);
-		if (ret)
-			goto FAIL;
-		atomic_inc(&enc->load_firmware);
-		enc->temp.size = H265E_TEMP_BUFFER_SIZE;
-		enc->temp.hdl =
-			rockchip_mpp_h265e_dma_alloc(mpp,
-						     instance->session,
-						     enc->temp.size,
-						     MPP_ALIGN_SIZE,
-						     &enc->temp.dma_addr);
-		if (enc->temp.hdl < 0) {
-			mpp_err("error: alloc temp buffer error\n");
-			goto FAIL;
-		}
-	}
-
-	index = instance->index;
-	instance->status = H265E_INSTANCE_STATUS_ERROR;
-	mpp_debug(DEBUG_H265E_INFO,
-		  "%s = %d\n", __func__, index);
-	session->instance_index = index;
-	code_base = (u32)enc->firmware.dma_addr;
-	mpp_debug(DEBUG_H265E_INFO, "h265e code_base = %x\n", code_base);
-	if (!atomic_read(&enc->is_init)) {
-		mpp_write(mpp, 0x0, H265E_PO_CONF);
-		mpp_write(mpp, 0x7ffffff, H265E_VPU_RESET_REQ);
-
-		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
-			mpp_write(mpp, 0, H265E_VPU_RESET_REQ);
-			goto FAIL;
-		}
-		mpp_write(mpp, 0, H265E_VPU_RESET_REQ);
-		for (i = H265E_COMMAND; i < H265E_CMD_REG_END; i += 4)
-			mpp_write(mpp, 0x00, i);
-		remap_size = 0x100;
-		reg_val = 0x80000000 | (0 << 16) |
-			  (H265E_REMAP_CODE_INDEX << 12) |
-			  (1 << 11) | remap_size;
-		mpp_write(mpp, reg_val, H265E_VPU_REMAP_CTRL);
-		mpp_write(mpp, 0x00000000, H265E_VPU_REMAP_VADDR);
-		mpp_write(mpp, code_base, H265E_VPU_REMAP_PADDR);
-		mpp_write(mpp, code_base, H265E_ADDR_CODE_BASE);
-		mpp_write(mpp, H265E_CODE_BUFFER_SIZE, H265E_CODE_SIZE);
-		mpp_write(mpp, 0, H265E_CODE_PARAM);
-		mpp_write(mpp, 0, H265E_HW_OPTION);
-		mpp_write(mpp, H265E_INT_OPEN, H265E_VPU_VINT_ENABLE);
-		mpp_write(mpp, 0xfffffff2, H265E_PERF_LATENCY_CTRL0);
-		mpp_write(mpp, 0x0, H265E_PERF_LATENCY_CTRL1);
-		mpp_write(mpp, 0x1, H265E_PERF_AXI_CTRL);
-		mpp_write(mpp, 0x01, H265E_VPU_BUSY_STATUS);
-		mpp_write(mpp, H265E_CMD_INIT_VPU, H265E_COMMAND);
-		mpp_write(mpp, 0x01, H265E_VPU_REMAP_CORE_START);
-		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
-			goto FAIL;
-		}
-		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-			mpp_err("h265e init ret fail\n");
-			goto FAIL;
-		}
-		/* start Init command*/
-		rockchip_mpp_h265e_issue_command(mpp,
-						 index,
-						 H265E_CMD_GET_FW_VERSION);
-		if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-			mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
-			goto FAIL;
-		}
-		if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-			mpp_err("h265e creat instance ret fail\n");
-			goto FAIL;
-		}
-		reg_val = mpp_read(mpp, H265E_RET_FW_VERSION);
-		mpp_debug(DEBUG_H265E_INFO,
-			  "get_firmware_version:VERSION=%d\n", reg_val);
-		atomic_inc(&enc->is_init);
-	}
-	mpp_write(mpp, 0x0, H265E_CORE_INDEX);
-	mpp_write(mpp, 0x00010000 | index, H265E_INST_INDEX);
-	mpp_write(mpp, (u32)instance->work.dma_addr, H265E_ADDR_WORK_BASE);
-	mpp_write(mpp, H265E_WORK_BUFFER_SIZE, H265E_WORK_SIZE);
-	mpp_write(mpp, 0, H265E_WORK_PARAM);
-	mpp_debug(DEBUG_H265E_INFO,
-		  "open instance=%d work addr=%x\n",
-		  index,
-		  (u32)instance->work.dma_addr);
-	/* create instance*/
-	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_CREATE_INSTANCE);
-	if (rockchip_mpp_h265e_wait_busy(mpp) == -1) {
-		mpp_err("rockchip_mpp_h265e_wait_busy timeout\n");
-		goto FAIL;
-	}
-	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0) {
-		mpp_err("h265e creat instance ret fail\n");
-		goto FAIL;
-	}
-	/* set default buffer counter*/
-	instance->min_frame_buffer_count = 2;
-	instance->min_src_frame_count = 2;
-	instance->src_idx = 0;
-	instance->status = H265E_INSTANCE_STATUS_OPENED;
-#if H265E_POWER_SAVE
-	rockchip_mpp_h265e_disable_clk(mpp);
-#endif
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-	return &session->isession;
-FAIL:
-	rockchip_mpp_h265e_free_instance(mpp, index);
-NFREE_FAIL:
-	kfree(session);
-	session = NULL;
-	mutex_unlock(&enc->lock);
-	mpp_err("h265e open fail\n");
-	return NULL;
-}
-
-static void rockchip_mpp_h265e_free(struct mpp_session *isession)
-{
-	struct h265e_session *session =
-					container_of(isession,
-						     struct h265e_session,
-						     isession);
-	kfree(session);
-}
-
-static void rockchip_mpp_h265e_release(struct mpp_session *isession)
-{
-	struct h265e_session *session =
-					container_of(isession,
-						     struct h265e_session,
-						     isession);
-	struct rockchip_mpp_dev *mpp = session->isession.mpp;
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	int index = 0;
-
-	mpp_debug_enter();
-	mutex_lock(&enc->lock);
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_enable_clk(mpp);
-#endif
-	mpp_dev_power_on(mpp);
-	index = session->instance_index;
-	rockchip_mpp_h265e_issue_command(mpp, index, H265E_CMD_FINI_SEQ);
-	if (rockchip_mpp_h265e_wait_busy(mpp) == -1)
-		mpp_err("h265e_wait_busy timeout,index=%d\n", index);
-	if (mpp_read(mpp, H265E_RET_SUCCESS) == 0)
-		mpp_err("h265e close instance %d ret fail\n", index);
-	rockchip_mpp_h265e_free_instance(mpp, index);
-#if	H265E_POWER_SAVE
-	rockchip_mpp_h265e_disable_clk(mpp);
-#endif
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-}
-
-static int rockchip_mpp_h265e_probe(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct device_node *np = mpp->dev->of_node;
-	int i;
-
-	enc->dev.ops = &h265e_ops;
-	for (i = 0; i < H265E_INSTANCE_NUM; i++)
-		atomic_set(&enc->instance[i].is_used, 0);
-	atomic_set(&enc->load_firmware, 0);
-	atomic_set(&enc->is_init, 0);
-	mutex_init(&enc->lock);
-#if H265E_CLK
-	enc->aclk = devm_clk_get(mpp->dev, "aclk_h265");
-	if (IS_ERR_OR_NULL(enc->aclk)) {
-		dev_err(mpp->dev, "failed on clk_get aclk\n");
-		enc->aclk = NULL;
-		goto fail;
-	}
-	enc->pclk = devm_clk_get(mpp->dev, "pclk_h265");
-	if (IS_ERR_OR_NULL(enc->pclk)) {
-		dev_err(mpp->dev, "failed on clk_get pclk\n");
-		enc->pclk = NULL;
-		goto fail;
-	}
-	enc->core = devm_clk_get(mpp->dev, "clk_core");
-	if (IS_ERR_OR_NULL(enc->core)) {
-		dev_err(mpp->dev, "failed on clk_get core\n");
-		enc->core = NULL;
-		goto fail;
-	}
-	enc->dsp = devm_clk_get(mpp->dev, "clk_dsp");
-	if (IS_ERR_OR_NULL(enc->dsp)) {
-		dev_err(mpp->dev, "failed on clk_get dsp\n");
-		enc->dsp = NULL;
-		goto fail;
-	}
-#if H265E_AXI_STATUS
-	enc->aclk_axi2sram = devm_clk_get(mpp->dev, "aclk_axi2sram");
-	if (IS_ERR_OR_NULL(enc->aclk_axi2sram)) {
-		dev_err(mpp->dev, "failed on clk_get aclk_axi2sram\n");
-		enc->aclk_axi2sram = NULL;
-		goto fail;
-	}
-#endif
-#endif
-	if (of_property_read_bool(np, "mode_ctrl")) {
-		of_property_read_u32(np, "mode_bit", &enc->mode_bit);
-		of_property_read_u32(np, "mode_ctrl", &enc->mode_ctrl);
-#ifdef CONFIG_MFD_SYSCON
-		enc->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
-		if (IS_ERR_OR_NULL(enc->grf)) {
-			enc->grf = NULL;
-			mpp_err("can't find vpu grf property\n");
-			return -1;
-		}
-#endif
-	}
-
-	return 0;
-#if H265E_CLK
-fail:
-	return -1;
-#endif
-}
-
-static void rockchip_mpp_h265e_remove(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_h265e_dev *enc =
-					 container_of(mpp,
-						      struct rockchip_h265e_dev,
-						      dev);
-	struct rockchip_h265e_instance *instance = NULL;
-	struct mpp_h265e_buffer *buf = NULL;
-	struct mpp_session *session = list_first_entry(&mpp->srv->session,
-						       struct mpp_session,
-						       list_session);
-	int i = 0;
-
-	mpp_debug_enter();
-	mutex_lock(&enc->lock);
-	for (i = 0; i < H265E_INSTANCE_NUM; i++) {
-		instance = &enc->instance[i];
-		if (atomic_read(&instance->is_used) == 1) {
-			buf = &instance->work;
-			if (buf->hdl >= 0) {
-				vpu_iommu_unmap_kernel(mpp->iommu_info,
-						       session, buf->hdl);
-				vpu_iommu_free(mpp->iommu_info, session,
-					       buf->hdl);
-			}
-			rockchip_mpp_h265e_free_frame_buffer(mpp, instance);
-			atomic_set(&instance->is_used, 0);
-		}
-	}
-	atomic_set(&enc->is_init, 0);
-	atomic_set(&enc->load_firmware, 0);
-	buf = &enc->temp;
-	if (buf->hdl >= 0) {
-		vpu_iommu_unmap_kernel(mpp->iommu_info, session, buf->hdl);
-		vpu_iommu_free(mpp->iommu_info, session, buf->hdl);
-	}
-
-	if (enc->firmware.hdl >= 0) {
-		vpu_iommu_unmap_kernel(mpp->iommu_info, session,
-				       enc->firmware.hdl);
-		vpu_iommu_free(mpp->iommu_info, session, enc->firmware.hdl);
-	}
-	mutex_unlock(&enc->lock);
-	mpp_debug_leave();
-}
-
-const struct rockchip_mpp_dev_variant h265e_variant = {
-	.data_len = sizeof(struct rockchip_h265e_dev),
-	.trans_info = NULL,
-	.mmu_dev_dts_name = NULL,
-	.hw_probe = rockchip_mpp_h265e_probe,
-	.hw_remove = rockchip_mpp_h265e_remove,
-	.power_on = rockchip_mpp_h265e_power_on,
-	.power_off = rockchip_mpp_h265e_power_off,
-	.reset = NULL,
-};
-EXPORT_SYMBOL(h265e_variant);
diff --git a/drivers/video/rockchip/vpu/mpp_dev_h265e.h b/drivers/video/rockchip/vpu/mpp_dev_h265e.h
deleted file mode 100644
index a4a40c686b9e..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e.h
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: hehua,hh@rock-chips.com
- * lixinhuang, buluess.li@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#ifndef __ROCKCHIP_MPP_DEV_H265E_H
-#define __ROCKCHIP_MPP_DEV_H265E_H
-
-#include "mpp_dev_h265e_define.h"
-#include "mpp_service.h"
-#include <linux/ioctl.h>
-#include <linux/wakelock.h>
-
-#define MPP_DEV_H265E_SET_COLOR_PALETTE	\
-		_IOW(MPP_IOC_MAGIC, MPP_IOC_CUSTOM_BASE + 1, u32)
-
-#define MPP_DEV_H265E_SET_PARAMETER	\
-		_IOW(MPP_IOC_MAGIC, \
-		MPP_IOC_CUSTOM_BASE + 6, struct mpp_h265e_cfg)
-
-#define MPP_DEV_H265E_GET_HEAD_PARAMETER	\
-		_IOW(MPP_IOC_MAGIC, \
-		MPP_IOC_CUSTOM_BASE + 7, struct hal_h265e_header)
-
-#define H265E_INSTANCE_NUM 4
-
-enum H265E_MODE {
-	H265E_MODE_NONE,
-	H265E_MODE_ONEFRAME,
-	H265E_MODE_LINKTABLE_FIX,
-	H265E_MODE_LINKTABLE_UPDATE,
-	H265E_MODE_NUM
-};
-
-struct regmap;
-
-struct h265e_result {
-	u32 bs_size;
-	u32 enc_pic_cnt;
-	u32 pic_type;
-	u32 num_of_slice;
-	u32 pick_skipped;
-	u32 num_intra;
-	u32 num_merge;
-	u32 num_skip_block;
-	u32 avg_ctu_qp;
-	int recon_frame_index;
-	u32 gop_idx;
-	u32 poc;
-	u32 src_idx;
-	u32 fail_reason;
-};
-
-struct mpp_h265e_buffer {
-	unsigned long dma_addr;
-	u32 size;
-	int hdl;
-};
-
-struct mpp_h265e_frame_buffer {
-	struct mpp_h265e_buffer buffer;
-	u32 y;
-	u32 cb;
-	u32 cr;
-};
-
-struct h265e_ctx {
-	struct mpp_ctx ictx;
-	enum H265E_MODE mode;
-	struct mpp_h265e_buffer bs;
-	char __iomem *bs_data;/*for debug read data*/
-	struct mpp_h265e_buffer src;
-	struct mpp_h265e_buffer roi;
-	struct mpp_h265e_buffer ctu;
-
-	struct mpp_h265e_encode_info cfg;
-
-	/* store status read from hw, oneframe mode used only */
-	struct h265e_result result;
-};
-
-enum H265E_INSTANCE_STATUS {
-	H265E_INSTANCE_STATUS_ERROR,
-	H265E_INSTANCE_STATUS_OPENED,
-	H265E_INSTANCE_STATUS_SET_PARAMETER,
-	H265E_INSTANCE_STATUS_ENCODE,
-	H265E_INSTANCE_STATUS_CLOSE
-};
-
-struct rockchip_h265e_instance {
-	int index;
-	atomic_t is_used;
-	struct mpp_h265e_buffer work;
-	struct mpp_h265e_buffer temp;
-	struct mpp_h265e_buffer mv;
-	struct mpp_h265e_buffer fbc_luma;
-	struct mpp_h265e_buffer fbc_chroma;
-	struct mpp_h265e_buffer sub_sample;
-	/*
-	 * for recon frames
-	 */
-	struct mpp_h265e_frame_buffer frame_buffer[16];
-
-	int min_frame_buffer_count;
-	int min_src_frame_count;
-	int src_idx;
-	int status;
-	struct mpp_h265e_cfg cfg;
-	struct mpp_session *session;
-};
-
-struct rockchip_h265e_dev {
-	struct rockchip_mpp_dev dev;
-	struct rockchip_h265e_instance instance[H265E_INSTANCE_NUM];
-	struct mpp_h265e_buffer temp;
-
-	u32 lkt_index;
-	u32 irq_status;
-	atomic_t is_init;
-	atomic_t load_firmware;
-
-	struct delayed_work work_list;
-	struct mutex lock;
-
-	char __iomem *firmware_cpu_addr;
-	struct mpp_h265e_buffer firmware;
-
-	struct clk *aclk;
-	struct clk *aclk_axi2sram;
-	struct clk *pclk;
-	struct clk *core;
-	struct clk *dsp;
-	void __iomem *grf_base;
-	u32 mode_bit;
-	u32 mode_ctrl;
-	struct regmap *grf;
-};
-
-struct h265e_session {
-	struct mpp_session isession;
-	int instance_index;
-};
-
-#endif
-
diff --git a/drivers/video/rockchip/vpu/mpp_dev_h265e_define.h b/drivers/video/rockchip/vpu/mpp_dev_h265e_define.h
deleted file mode 100644
index fd5da7c468fe..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e_define.h
+++ /dev/null
@@ -1,759 +0,0 @@
- /*
-  * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
-  * author: hehua,hh@rock-chips.com
-  * lixinhuang, buluess.li@rock-chips.com
-  *
-  * This software is licensed under the terms of the GNU General Public
-  * License version 2, as published by the Free Software Foundation, and
-  * may be copied, distributed, and modified under those terms.
-  *
-  * This program is distributed in the hope that it will be useful,
-  * but WITHOUT ANY WARRANTY; without even the implied warranty of
-  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-  * GNU General Public License for more details.
-  *
-  */
-#ifndef __MPP_DEV_H265E_DEFINE_H__
-#define __MPP_DEV_H265E_DEFINE_H__
-
-#include <linux/bitops.h>
-
-#define H265E_MVCOL_BUF_SIZE(w, h) \
-	((((w) + 63) / 64) * (((h) + 63) / 64) * 128)
-#define H265E_FBC_LUMA_TABLE_SIZE(w, h) \
-	((((h) + 15) / 16) * (((w) + 255) / 256) * 128)
-#define H265E_FBC_CHROMA_TABLE_SIZE(w, h) \
-	((((h) + 15) / 16) * (((w) / 2 + 255) / 256) * 128)
-#define H265E_SUBSAMPLED_ONE_SIZE(w, h) \
-	(((((w) / 4) + 15) & ~15) * ((((h) / 4) + 7) & ~7))
-
-#define H265E_PIC_TYPE_I 0
-#define H265E_PIC_TYPE_P 1
-
-enum H265E_VPU_COMMAND {
-	H265E_CMD_INIT_VPU        = 0x0001,
-	H265E_CMD_SET_PARAM       = 0x0002,
-	H265E_CMD_FINI_SEQ        = 0x0004,
-	H265E_CMD_ENC_PIC         = 0x0008,
-	H265E_CMD_SET_FRAMEBUF    = 0x0010,
-	H265E_CMD_FLUSH_DECODER   = 0x0020,
-	H265E_CMD_GET_FW_VERSION  = 0x0100,
-	H265E_CMD_QUERY_DECODER   = 0x0200,
-	H265E_CMD_SLEEP_VPU       = 0x0400,
-	H265E_CMD_WAKEUP_VPU      = 0x0800,
-	H265E_CMD_CREATE_INSTANCE = 0x4000,
-	H265E_CMD_RESET_VPU	  = 0x10000,
-	H265E_CMD_MAX_VPU_COMD	  = 0x10000,
-};
-
-enum H265E_PIC_CODE_OPTION {
-	CODEOPT_ENC_HEADER_IMPLICIT = BIT(0),
-	CODEOPT_ENC_VCL             = BIT(1),
-	CODEOPT_ENC_VPS             = BIT(2),
-	CODEOPT_ENC_SPS             = BIT(3),
-	CODEOPT_ENC_PPS             = BIT(4),
-	CODEOPT_ENC_AUD             = BIT(5),
-	CODEOPT_ENC_EOS             = BIT(6),
-	CODEOPT_ENC_EOB             = BIT(7),
-	CODEOPT_ENC_RESERVED        = BIT(8),
-	CODEOPT_ENC_VUI             = BIT(9),
-};
-
-enum H265E_TILED_MAP_TYPE {
-	LINEAR_FRAME_MAP            = 0,
-	TILED_FRAME_V_MAP           = 1,
-	TILED_FRAME_H_MAP           = 2,
-	TILED_FIELD_V_MAP           = 3,
-	TILED_MIXED_V_MAP           = 4,
-	TILED_FRAME_MB_RASTER_MAP   = 5,
-	TILED_FIELD_MB_RASTER_MAP   = 6,
-	TILED_FRAME_NO_BANK_MAP     = 7,
-	TILED_FIELD_NO_BANK_MAP     = 8,
-	LINEAR_FIELD_MAP            = 9,
-	CODA_TILED_MAP_TYPE_MAX     = 10,
-	COMPRESSED_FRAME_MAP        = 10,
-	TILED_SUB_CTU_MAP           = 11,
-	ARM_COMPRESSED_FRAME_MAP      = 12,
-};
-
-#define H265E_MAX_NUM_TEMPORAL_LAYER          7
-#define H265E_MAX_GOP_NUM                     8
-#define H265E_MIN_PIC_WIDTH            256
-#define H265E_MIN_PIC_HEIGHT           128
-#define H265E_MAX_PIC_WIDTH            1920
-#define H265E_MAX_PIC_HEIGHT           1080
-#define MAX_ROI_NUMBER  64
-
-enum H265E_GOP_PRESET_IDX {
-	PRESET_IDX_CUSTOM_GOP       = 0,
-	PRESET_IDX_ALL_I            = 1,
-	PRESET_IDX_IPP              = 2,
-	PRESET_IDX_IPPPP            = 6,
-};
-
-enum H265E_SET_PARAM_OPTION {
-	H265E_OPT_COMMON          = 0,
-	H265E_OPT_CUSTOM_GOP      = 1,
-	H265E_OPT_CUSTOM_HEADER   = 2,
-	H265E_OPT_VUI             = 3,
-	H265E_OPT_ALL_PARAM       = 0xffffffff
-};
-
-enum H265E_PARAM_CHANEGED {
-	H265E_PARAM_CHANEGED_COMMON          = 1,
-	H265E_PARAM_CHANEGED_CUSTOM_GOP      = 2,
-	H265E_PARAM_CHANEGED_VUI             = 4,
-	H265E_PARAM_CHANEGED_REGISTER_BUFFER = 8,
-};
-
-enum H265E_COMON_CFG_MASK {
-	/* COMMON parameters*/
-	H265E_CFG_SEQ_SRC_SIZE_CHANGE             = BIT(0),
-	H265E_CFG_SEQ_PARAM_CHANGE                = BIT(1),
-	H265E_CFG_GOP_PARAM_CHANGE                = BIT(2),
-	H265E_CFG_INTRA_PARAM_CHANGE              = BIT(3),
-	H265E_CFG_CONF_WIN_TOP_BOT_CHANGE         = BIT(4),
-	H265E_CFG_CONF_WIN_LEFT_RIGHT_CHANGE      = BIT(5),
-	H265E_CFG_FRAME_RATE_CHANGE               = BIT(6),
-	H265E_CFG_INDEPENDENT_SLICE_CHANGE        = BIT(7),
-	H265E_CFG_DEPENDENT_SLICE_CHANGE          = BIT(8),
-	H265E_CFG_INTRA_REFRESH_CHANGE            = BIT(9),
-	H265E_CFG_PARAM_CHANGE                    = BIT(10),
-	H265E_CFG_CHANGE_RESERVED                 = BIT(11),
-	H265E_CFG_RC_PARAM_CHANGE                 = BIT(12),
-	H265E_CFG_RC_MIN_MAX_QP_CHANGE            = BIT(13),
-	H265E_CFG_RC_TARGET_RATE_LAYER_0_3_CHANGE = BIT(14),
-	H265E_CFG_RC_TARGET_RATE_LAYER_4_7_CHANGE = BIT(15),
-
-	H265E_CFG_SET_NUM_UNITS_IN_TICK		  = BIT(18),
-	H265E_CFG_SET_TIME_SCALE		  = BIT(19),
-	H265E_CFG_SET_NUM_TICKS_POC_DIFF_ONE	  = BIT(20),
-	H265E_CFG_RC_TRANS_RATE_CHANGE            = BIT(21),
-	H265E_CFG_RC_TARGET_RATE_CHANGE           = BIT(22),
-	H265E_CFG_ROT_PARAM_CHANGE                = BIT(23),
-	H265E_CFG_NR_PARAM_CHANGE                 = BIT(24),
-	H265E_CFG_NR_WEIGHT_CHANGE                = BIT(25),
-
-	H265E_CFG_SET_VCORE_LIMIT                 = BIT(27),
-	H265E_CFG_CHANGE_SET_PARAM_ALL            = (0xFFFFFFFF),
-};
-
-/**
- * @brief    This is a data structure for setting
- * CTU level options (ROI, CTU mode, CTU QP) in HEVC encoder.
- */
-struct h265e_ctu {
-	u32 roi_enable;
-	u32 roi_delta_qp;
-	u32 map_endian;
-
-	/*
-	 * Stride of CTU-level ROI/mode/QP map
-	 * Set this with (Width  + CTB_SIZE - 1) / CTB_SIZE
-	 */
-	u32 map_stride;
-	/*
-	 * It enables CTU QP map that allows
-	 * CTUs to be encoded with the given QPs.
-	 * NOTE: rcEnable should be turned off for this,
-	 * encoding with the given CTU QPs.
-	 */
-	u32 ctu_qp_enable;
-};
-
-struct h265e_sei {
-	u8 prefix_sei_nal_enable;
-
-	/*
-	 * A flag whether to encode PREFIX_SEI_DATA
-	 * with a picture of this command or with a source
-	 * picture of the buffer at the moment
-	 * 0 : encode PREFIX_SEI_DATA when a source picture is encoded.
-	 * 1 : encode PREFIX_SEI_DATA at this command.
-	 */
-	u8 prefix_sei_data_order;
-
-	/*
-	 * enables to encode the suffix SEI NAL which is given by host.
-	 */
-	u8 suffix_sei_nal_enable;
-
-	/*
-	 * A flag whether to encode SUFFIX_SEI_DATA
-	 * with a picture of this command or with a source
-	 * picture of the buffer at the moment
-	 * 0 : encode SUFFIX_SEI_DATA when a source picture is encoded.
-	 * 1 : encode SUFFIX_SEI_DATA at this command.
-	 */
-	u8 suffix_sei_data_enc_order;
-
-	/*
-	 * The total byte size of the prefix SEI
-	 */
-	u32 prefix_sei_data_size;
-
-	/*
-	 * The start address of the total prefix SEI NALs to be encoded
-	 */
-	u32 prefix_sei_nal_addr;
-
-	/*
-	 * The total byte size of the suffix SEI
-	 */
-	u32 suffix_sei_data_size;
-
-	/*
-	 * The start address of the total suffix SEI NALs to be encoded
-	 */
-	u32 suffix_sei_nal_addr;
-};
-
-/**
- * @brief    This is a data structure for setting
- * VUI parameters in HEVC encoder.
- */
-struct h265e_vui {
-	/*
-	 * VUI parameter flag
-	 */
-	u32 flags;
-	/**< aspect_ratio_idc */
-	u32 aspect_ratio_idc;
-	/**< sar_width, sar_height
-	 * (only valid when aspect_ratio_idc is equal to 255)
-	 */
-	u32 sar_size;
-	/**< overscan_appropriate_flag */
-	u32 over_scan_appropriate;
-	/**< VUI parameter flag */
-	u32 signal;
-	/**< chroma_sample_loc_type_top_field,
-	 *chroma_sample_loc_type_bottom_field
-	 */
-	u32 chroma_sample_loc;
-	/**< def_disp_win_left_offset, def_disp_win_right_offset */
-	u32 disp_win_left_right;
-	/**< def_disp_win_top_offset, def_disp_win_bottom_offset */
-	u32 disp_win_top_bottom;
-};
-
-/**
- * @brief    This is a data structure for
- *custom GOP parameters of the given picture.
- */
-struct h265e_custom_gop_pic {
-	/**< A picture type of #th picture in the custom GOP */
-	u32 type;
-	/**< A POC offset of #th picture in the custom GOP */
-	u32 offset;
-	/**< A quantization parameter of #th picture in the custom GOP */
-	u32 qp;
-	/**< POC offset of reference L0 of #th picture in the custom GOP */
-	u32 ref_poc_l0;
-	/**< POC offset of reference L1 of #th picture in the custom GOP */
-	u32 ref_poc_l1;
-	/**< A temporal ID of #th picture in the custom GOP */
-	u32 temporal_id;
-};
-
-/**
- * @brief    This is a data structure for custom GOP parameters.
- */
-struct h265e_custom_gop {
-	/**< Size of the custom GOP (0~8) */
-	u32 custom_gop_size;
-	/**< It derives a lamda weight internally
-	 * instead of using lamda weight specified.
-	 */
-	u32 use_derive_lambda_weight;
-	/**< picture parameters of #th picture in the custom gop */
-	struct h265e_custom_gop_pic pic[H265E_MAX_GOP_NUM];
-	/**< a lamda weight of #th picture in the custom gop */
-	u32 gop_pic_lambda[H265E_MAX_GOP_NUM];
-};
-
-struct enc_code_opt {
-	/**< whether host encode a header implicitly or not.
-	 * if this value is 1, below encode options will be ignored
-	 */
-	int implicit_header_encode;
-	int encode_vcl;/**< a flag to encode vcl nal unit explicitly*/
-	int encode_vps;/**< a flag to encode vps nal unit explicitly*/
-	int encode_sps;/**< a flag to encode sps nal unit explicitly*/
-	int encode_pps;/**< a flag to encode pps nal unit explicitly*/
-	int encode_aud;/**< a flag to encode aud nal unit explicitly*/
-	int encode_eos;/**< a flag to encode eos nal unit explicitly*/
-	int encode_eob;/**< a flag to encode eob nal unit explicitly*/
-	int encode_vui;/**< a flag to encode vui nal unit explicitly*/
-};
-
-enum H265E_SRC_FORMAT {
-	H265E_SRC_YUV_420 = 0,
-	H265E_SRC_YUV_420_YU12 = 0, /*  3Plane 1.Y, 2.U, 3.V*/
-	H265E_SRC_YUV_420_YV12, /*  3Plane 1.Y, 2.V, 3.U*/
-	H265E_SRC_YUV_420_NV12, /* 2 Plane 1.Y 2. UV*/
-	H265E_SRC_YUV_420_NV21, /* 2 Plane 1.Y 2. VU*/
-	H265E_SRC_YUV_420_MAX,
-};
-
-struct hal_h265e_header {
-	u32         buf;
-	u32         size;
-};
-
-struct mpp_h265e_cfg {
-	/*
-	 * A profile indicator
-	 * 1 : main
-	 * 2 : main10
-	 */
-	u8 profile;
-
-	/*
-	 * only support to level 4.1
-	 */
-	u8 level; /**< A level indicator (level * 10) */
-
-	/*
-	 * A tier indicator
-	 * 0 : main
-	 * 1 : high
-	 */
-	u8 tier;
-
-	/*
-	 * A chroma format indecator, only support YUV420
-	 */
-	u8 chroma_idc;
-
-	/*
-	 * the source's width and height
-	 */
-	u16 width;
-	u16 height;
-	u16 width_stride;
-	u16 height_stride;
-
-	/*
-	 * bitdepth,only support 8 bits(only support 8 bits)
-	 */
-	u8 bit_depth;
-
-	/*
-	 * source yuv's format. The value is defined
-	 * in H265E_FrameBufferFormat(only support YUV420)
-	 * the value could be YU12,YV12,NV12,NV21
-	 */
-	u8 src_format;
-
-	u8 src_endian;
-	u8 bs_endian;
-	u8 fb_endian;
-	u8 frame_rate;
-	u8 frame_skip;
-	u32 bit_rate;
-
-	u32 map_type;
-	u32 line_buf_int_en;
-	u32 slice_int_enable;
-	u32 ring_buffer_enable;
-
-	struct enc_code_opt code_option;
-	/*
-	 * A chroma format indecator, only support YUV420
-	 */
-	int lossless_enable;/**< It enables lossless coding */
-	/**< It enables constrained intra prediction */
-	int const_intra_pred_flag;
-	/**< The value of chroma(cb) qp offset (only for WAVE420L) */
-	int chroma_cb_qp_offset;
-	/**< The value of chroma(cr) qp offset  (only for WAVE420L) */
-	int chroma_cr_qp_offset;
-	/**
-	 * A GOP structure option
-	 * 0: Custom GOP
-	 * 1 : I-I-I-I,..I (all intra, gop_size=1)
-	 * 2 : I-P-P-P,... P (consecutive P, gop_size=1)
-	 * 6 : I-P-P-P-P (consecutive P, gop_size=4)
-	 */
-	u32 gop_idx;
-
-	/**
-	 * An intra picture refresh mode
-	 * 0 : Non-IRAP
-	 * 1 : CRA
-	 * 2 : IDR
-	 */
-	u32 decoding_refresh_type;
-
-	/*
-	 * A quantization parameter of intra picture
-	 */
-	u32 intra_qp;
-
-	/*
-	 * A period of intra picture in GOP size
-	 */
-	u32 intra_period;
-
-	/** A conformance window size of TOP,BUTTOM,LEFT,RIGHT */
-	u16 conf_win_top;
-	u16 conf_win_bot;
-	u16 conf_win_left;
-	u16 conf_win_right;
-
-	/*
-	 * A slice mode for independent slice
-	 * 0 : no multi-slice
-	 * 1 : Slice in CTU number
-	 * 2 : Slice in number of byte
-	 */
-	u32 independ_slice_mode;
-
-	/*
-	 * The number of CTU or bytes for a slice
-	 * when independ_slice_mode is set with 1 or 2.
-	 */
-	u32 independ_slice_mode_arg;
-
-	/**
-	 *A slice mode for dependent slice
-	 * 0 : no multi-slice
-	 * 1 : Slice in CTU number
-	 * 2 : Slice in number of byte
-	 */
-	u32 depend_slice_mode;
-
-	/*
-	 * The number of CTU or bytes for a slice
-	 * when depend_slice_mode is set with 1 or 2.
-	 */
-	u32 depend_slice_mode_arg;
-
-	/*
-	 * An intra refresh mode
-	 * 0 : No intra refresh
-	 * 1 : Row
-	 * 2 : Column
-	 * 3 : Step size in CTU
-	 */
-	u32 intra_refresh_mode;
-
-	/*
-	 * The number of CTU (only valid when intraRefreshMode is 3.)
-	 */
-	u32 intra_refresh_arg;
-
-	/*
-	 * It uses one of the recommended encoder parameter presets.
-	 * 0 : Custom
-	 * 1 : Recommend enc params
-	 * (slow encoding speed, highest picture quality)
-	 * 2 : Boost mode (normal encoding speed, normal picture quality)
-	 * 3 : Fast mode (high encoding speed, low picture quality)
-	 */
-	u8 use_recommend_param;
-	u8 scaling_list_enable; /**< It enables a scaling list */
-
-	/*
-	 * It specifies CU size.
-	 * 3'b001: 8x8
-	 * 3'b010: 16x16
-	 * 3'b100 : 32x32
-	 */
-	u8 cu_size_mode;
-	u8 tmvp_enable;
-	u8 wpp_enable; /**< It enables wave-front parallel processing. */
-	u8 max_num_merge; /**< Maximum number of merge candidates (0~2) */
-	u8 dynamic_merge_8x8_enable;
-	u8 dynamic_merge_16x16_enable;
-	u8 dynamic_merge_32x32_enable;
-	u8 disable_deblk; /**< It disables in-loop deblocking filtering. */
-	/**< it enables filtering across slice
-	 * boundaries for in-loop deblocking.
-	 */
-	u8 lf_cross_slice_boundary_enable;
-	/**< BetaOffsetDiv2 for deblocking filter */
-	u8 beta_offset_div2;
-	/**< TcOffsetDiv3 for deblocking filter */
-	u8 tc_offset_div2;
-	/**< It enables transform skip for an intra CU. */
-	u8 skip_intra_trans;
-	/**< It enables SAO (sample adaptive offset). */
-	u8 sao_enable;
-	/**< It enables to make intra CUs in an inter slice. */
-	u8 intra_in_inter_slice_enable;
-	/**< It enables intra NxN PUs. */
-	u8 intra_nxn_enable;
-
-	/*
-	 * specifies intra QP offset relative
-	 * to inter QP (Only available when rc_enable is enabled)
-	 */
-	s8 intra_qp_offset;
-
-	/*
-	 * It specifies encoder initial delay,
-	 * Only available when RateControl is enabled
-	 * (encoder initial delay = initial_delay * init_buf_levelx8 / 8)
-	 */
-	int init_buf_levelx8;
-
-	/*
-	 * specifies picture bits allocation mode.
-	 * Only available when RateControl is enabled
-	 * and GOP size is larger than 1
-	 * 0: More referenced pictures have
-	 * better quality than less referenced pictures
-	 * 1: All pictures in a GOP have similar image quality
-	 * 2: Each picture bits in a GOP is allocated according to FixedRatioN
-	 */
-	u8 bit_alloc_mode;
-
-	/*
-	 * A fixed bit ratio (1 ~ 255) for each picture of GOP's bitallocation
-	 * N = 0 ~ (MAX_GOP_SIZE - 1)
-	 * MAX_GOP_SIZE = 8
-	 * For instance when MAX_GOP_SIZE is 3, FixedBitRaio0
-	 * to FixedBitRaio2 can be set as 2, 1, and 1 respectively for
-	 * the fixed bit ratio 2:1:1. This is only valid when BitAllocMode is 2.
-	 */
-	u8 fixed_bit_ratio[H265E_MAX_GOP_NUM];
-
-	/*
-	 * enable rate control
-	 */
-	u32 rc_enable;
-
-	/*
-	 * enable CU level rate control
-	 */
-	u8 cu_level_rc_enable;
-
-	/*
-	 * enable CU QP adjustment for subjective quality enhancement
-	 */
-	u8 hvs_qp_enable;
-
-	/*
-	 * enable QP scaling factor for CU QP adjustment when hvs_qp_enable = 1
-	 */
-	u8 hvs_qp_scale_enable;
-
-	/*
-	 * A QP scaling factor for CU QP adjustment when hvs_qp_enable = 1
-	 */
-	s8 hvs_qp_scale;
-
-	/*
-	 * A minimum QP for rate control
-	 */
-	u8 min_qp;
-
-	/*
-	 * A maximum QP for rate control
-	 */
-	u8 max_qp;
-
-	/*
-	 * A maximum delta QP for rate control
-	 */
-	u8 max_delta_qp;
-
-	/*
-	 * A peak transmission bitrate in bps
-	 */
-	u32 trans_rate;
-	/*< It specifies the number of time units of
-	 * a clock operating at the frequency time_scale Hz
-	 */
-	u32 num_units_in_tick;
-	/**< It specifies the number of time units that pass in one second */
-	u32 time_scale;
-	/**< It specifies the number of clock ticks corresponding to a
-	 * difference of picture order count values equal to 1
-	 */
-	u32 num_ticks_poc_diff_one;
-
-	/*< The value of initial QP by host.
-	 * This value is meaningless if INITIAL_RC_QP == 63
-	 */
-	int initial_rc_qp;
-
-	/*
-	 * enables noise reduction algorithm to Y/Cb/Cr component.
-	 */
-	u8 nr_y_enable;
-	u8 nr_cb_enable;
-	u8 nr_cr_enable;
-
-	/*
-	 * enables noise estimation for reduction. When this is disabled,
-	 * noise estimation is carried out ouside VPU.
-	 */
-	u8 nr_noise_est_enable;
-	/*
-	 * It specifies Y/Cb/Cr noise standard deviation
-	 * if no use of noise estimation (nr_noise_est_enable=0)
-	 */
-	u8 nr_noise_sigma_y;
-	u8 nr_noise_sigma_cb;
-	u8 nr_noise_sigma_cr;
-	/* ENC_NR_WEIGHT*/
-	/*< A weight to Y noise level for intra picture (0 ~ 31).
-	 * nr_intra_weight_y/4 is multiplied to the noise
-	 * level that has been estimated.
-	 * This weight is put for intra frame to be filtered more strongly or
-	 * more weakly than just with the estimated noise level.
-	 */
-	u8 nr_intra_weight_y;
-	/**< A weight to Cb noise level for intra picture (0 ~ 31). */
-	u8 nr_intra_weight_cb;
-	/**< A weight to Cr noise level for intra picture (0 ~ 31). */
-	u8 nr_intra_weight_cr;
-	/*< A weight to Y noise level for inter picture (0 ~ 31).
-	 * nr_inter_weight_y/4 is multiplied to the noise
-	 * level that has been estimated.
-	 * This weight is put for inter frame to be filtered more strongly or
-	 * more weakly than just with the estimated noise level.
-	 */
-	u8 nr_inter_weight_y;
-	/**< A weight to Cb noise level for inter picture (0 ~ 31). */
-	u8 nr_inter_weight_cb;
-	/**< A weight to Cr noise level for inter picture (0 ~ 31). */
-	u8 nr_inter_weight_cr;
-	/*
-	 * a minimum QP for intra picture (0 ~ 51).
-	 * It is only available when rc_enable is 1.
-	 */
-	u8 intra_min_qp;
-
-	/*
-	 * a maximum QP for intra picture (0 ~ 51).
-	 * It is only available when rc_enable is 1.
-	 */
-	u8 intra_max_qp;
-
-	u32 initial_delay;
-
-	u8 hrd_rbsp_in_vps;
-	u8 hrd_rbsp_in_vui;
-	u32 vui_rbsp;
-
-	u32 hrd_rbsp_data_size; /**< The size of the HRD rbsp data */
-	u32 hrd_rbsp_data_addr;  /**< The address of the HRD rbsp data */
-
-	u32 vui_rbsp_data_size;   /**< The size of the VUI rbsp data */
-	u32 vui_rbsp_data_addr;   /**< The address of the VUI rbsp data */
-
-	u8 use_long_term;
-	u8 use_cur_as_longterm_pic;
-	u8 use_longterm_ref;
-
-	struct h265e_custom_gop gop;
-	struct h265e_ctu ctu;
-	struct h265e_vui vui;
-	struct h265e_sei sei;
-
-	/*
-	 * define which type of parameters are changed,
-	 * only support common parameter chanegd now,
-	 * see H265eCommonCfgMask
-	 */
-	u32 cfg_option;
-
-	/*
-	 * define which parameters are changed,see H265E_SET_PARAM_OPTION
-	 */
-	u32 cfg_mask;
-};
-
-struct mpp_h265e_encode_info {
-	/*
-	 * the address of source(yuv) data for encoding
-	 */
-	u32 src_fd;
-
-	/*
-	 * the size of source(yuv) data for encoding
-	 */
-	u32 src_size;
-
-	/*
-	 * the address of bitstream buffer
-	 */
-	u32 bs_fd;
-
-	/*
-	 * the size of bitstream buffer
-	 */
-	u32 bs_size;
-	u32 roi_fd;
-	u32 ctu_qp_fd;
-	u32 stream_end;
-
-	/*
-	 * skip current frame
-	 */
-	u32 skip_pic;
-
-	/*
-	 * A flag to use a force picture quantization parameter
-	 */
-	u32 force_qp_enable;
-
-	/*
-	 *Force picture quantization parameter for I picture
-	 */
-	u32 force_qp_i;
-
-	/*
-	 * Force picture quantization parameter for P picture
-	 */
-	u32 force_qp_p;
-
-	/*
-	 * A flag to use a force picture type
-	 */
-	u32 force_frame_type_enable;
-
-	/*
-	 * A force picture type (I, P, B, IDR, CRA)
-	 */
-	u32 force_frame_type;
-};
-
-enum INTERRUPT_BIT {
-	INT_BIT_INIT            = 0,
-	INT_BIT_SEQ_INIT        = 1,
-	INT_BIT_SEQ_END         = 2,
-	INT_BIT_PIC_RUN         = 3,
-	INT_BIT_FRAMEBUF_SET    = 4,
-	INT_BIT_ENC_HEADER      = 5,
-	INT_BIT_DEC_PARA_SET    = 7,
-	INT_BIT_DEC_BUF_FLUSH   = 8,
-	INT_BIT_USERDATA        = 9,
-	INT_BIT_DEC_FIELD       = 10,
-	INT_BIT_DEC_MB_ROWS     = 13,
-	INT_BIT_BIT_BUF_EMPTY   = 14,
-	INT_BIT_BIT_BUF_FULL    = 15
-};
-
-enum H265E_INTERRUPT_BIT {
-	INT_H265E_INIT            = 0,
-	INT_H265E_DEC_PIC_HDR     = 1,
-	INT_H265E_FINI_SEQ        = 2,
-	INT_H265E_ENC_PIC         = 3,
-	INT_H265E_SET_FRAMEBUF    = 4,
-	INT_H265E_FLUSH_DECODER   = 5,
-	INT_H265E_GET_FW_VERSION  = 8,
-	INT_H265E_QUERY_DECODER   = 9,
-	INT_H265E_SLEEP_VPU       = 10,
-	INT_H265E_WAKEUP_VPU      = 11,
-	INT_H265E_CHANGE_INST     = 12,
-	INT_H265E_CREATE_INSTANCE = 14,
-	INT_H265E_BIT_BUF_EMPTY   = 15,
-	INT_H265E_BIT_BUF_FULL    = 15,   /* Encoder */
-};
-
-#endif
diff --git a/drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h b/drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h
deleted file mode 100644
index 49f9cff6c1f3..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_h265e_reg.h
+++ /dev/null
@@ -1,235 +0,0 @@
-/*
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: hehua,hh@rock-chips.com
- * lixinhuang, buluess.li@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef _MPP_DEV_H265E_REGISTER_H_
-#define _MPP_DEV_H265E_REGISTER_H_
-
-#define H265E_PO_CONF                        0x0000
-#define H265E_VCPU_CUR_PC                    0x0004
-#define H265E_VPU_PDBG_CTRL                  0x0010
-#define H265E_VPU_PDBG_IDX_REG               0x0014
-#define H265E_VPU_PDBG_WDATA_REG             0x0018
-#define H265E_VPU_PDBG_RDATA_REG             0x001C
-#define H265E_VPU_FIO_CTRL_ADDR              0x0020
-#define H265E_VPU_FIO_DATA                   0x0024
-#define H265E_VPU_VINT_REASON_USR            0x0030
-#define H265E_VPU_VINT_REASON_CLR            0x0034
-#define H265E_VPU_HOST_INT_REQ               0x0038
-#define H265E_VPU_VINT_CLEAR                 0x003C
-#define H265E_VPU_HINT_CLEAR                 0x0040
-#define H265E_VPU_VPU_INT_STS                0x0044
-#define H265E_VPU_VINT_ENABLE                0x0048
-
-#define H265E_CMD_REG_END                    0x0200
-
-#define H265E_VPU_VINT_REASON                0x004c
-#define H265E_VPU_RESET_REQ                  0x0050
-#define H265E_VPU_RESET_STATUS               0x0070
-#define H265E_VPU_REMAP_CTRL                 0x0060
-#define H265E_VPU_REMAP_VADDR                0x0064
-#define H265E_VPU_REMAP_PADDR                0x0068
-#define H265E_VPU_REMAP_CORE_START           0x006C
-#define H265E_VPU_BUSY_STATUS                0x0070
-#define H265E_COMMAND                        0x0100
-#define H265E_CORE_INDEX                     0x0104
-#define H265E_INST_INDEX                     0x0108
-#define H265E_ENC_SET_PARAM_OPTION           0x010C
-#define H265E_RET_FW_VERSION                 0x0118
-#define H265E_ADDR_CODE_BASE                 0x0118
-#define H265E_CODE_SIZE			     0x011C
-#define H265E_CODE_PARAM                     0x0120
-#define H265E_HW_OPTION                      0x0124
-
-#define H265E_RET_SUCCESS                    0x0110
-#define H265E_VPU_HOST_INT_REQ               0x0038
-#define H265E_SFB_OPTION                     0x010C
-#define H265E_RET_FAIL_REASON                0x0114
-#define H265E_BS_START_ADDR                  0x0120
-#define H265E_COMMON_PIC_INFO                0x0120
-#define H265E_BS_SIZE                        0x0124
-#define H265E_PIC_SIZE                       0x0124
-#define H265E_BS_PARAM                       0x0128
-#define H265E_SET_FB_NUM                     0x0128
-#define H265E_BS_OPTION                      0x012C
-#define H265E_BS_RD_PTR                      0x0130
-#define H265E_BS_WR_PTR                      0x0134
-#define H265E_ADDR_WORK_BASE                 0x0138
-#define H265E_WORK_SIZE                      0x013c
-#define H265E_WORK_PARAM                     0x0140
-#define H265E_ADDR_TEMP_BASE                 0x0144
-#define H265E_TEMP_SIZE                      0x0148
-#define H265E_TEMP_PARAM                     0x014C
-#define H265E_FBC_STRIDE                     0x0154
-#define H265E_ENC_SET_PARAM_ENABLE           0x015C
-#define H265E_ENC_SEQ_SRC_SIZE               0x0160
-#define H265E_ADDR_LUMA_BASE0                0x0160
-#define H265E_ADDR_CB_BASE0                  0x0164
-#define H265E_ADDR_CR_BASE0                  0x0168
-#define H265E_ADDR_FBC_Y_OFFSET0             0x0168
-#define H265E_ADDR_FBC_C_OFFSET0             0x016C
-
-#define H265E_ENC_SEQ_PARAM                  0x016C
-#define H265E_ENC_SEQ_GOP_PARAM              0x0170
-#define H265E_ENC_SRC_PIC_IDX                0x0170
-#define H265E_ENC_SEQ_INTRA_PARAM            0x0174
-#define H265E_ENC_SEQ_CONF_WIN_TOP_BOT       0x0178
-#define H265E_ENC_SEQ_CONF_WIN_LEFT_RIGHT    0x017C
-#define H265E_ENC_SEQ_FRAME_RATE             0x0180
-#define H265E_ENC_SEQ_INDEPENDENT_SLICE      0x0184
-#define H265E_ENC_SEQ_DEPENDENT_SLICE        0x0188
-
-#define H265E_ENC_SEQ_INTRA_REFRESH          0x018C
-#define H265E_ENC_PARAM                      0x0190
-#define H265E_ENC_RC_INTRA_MIN_MAX_QP        0x0194
-#define H265E_ENC_RC_PARAM                   0x0198
-#define H265E_ENC_RC_MIN_MAX_QP              0x019C
-#define H265E_ENC_RC_BIT_RATIO_LAYER_0_3     0x01A0
-#define H265E_ENC_RC_BIT_RATIO_LAYER_4_7     0x01A4
-#define H265E_ENC_NR_PARAM                   0x01A8
-#define H265E_ENC_NR_WEIGHT                  0x01AC
-#define H265E_ENC_NUM_UNITS_IN_TICK          0x01B0
-#define H265E_ENC_TIME_SCALE                 0x01B4
-#define H265E_ENC_NUM_TICKS_POC_DIFF_ONE     0x01B8
-#define H265E_ENC_RC_TRANS_RATE              0x01BC
-#define H265E_ENC_RC_TARGET_RATE             0x01C0
-#define H265E_ENC_ROT_PARAM                  0x01C4
-#define H265E_ENC_ROT_RESERVED               0x01C8
-#define H265E_RET_ENC_MIN_FB_NUM             0x01CC
-#define H265E_RET_ENC_NAL_INFO_TO_BE_ENCODED 0x01D0
-#define H265E_RET_ENC_MIN_SRC_BUF_NUM        0x01D8
-
-#define H265E_ADDR_MV_COL0                   0x01E0
-#define H265E_ADDR_MV_COL1                   0x01E4
-#define H265E_ADDR_MV_COL2                   0x01E8
-#define H265E_ADDR_MV_COL3                   0x01EC
-#define H265E_ADDR_MV_COL4                   0x01F0
-#define H265E_ADDR_MV_COL5                   0x01F4
-#define H265E_ADDR_MV_COL6                   0x01F8
-#define H265E_ADDR_MV_COL7                   0x01FC
-
-#define H265E_ADDR_SEC_AXI_BASE              0x150
-#define H265E_SEC_AXI_SIZE                   0x154
-#define H265E_USE_SEC_AXI                    0x158
-
-/************************************************************************/
-/*H265 ENCODER - SET_PARAM + CUSTOM_GOP                                 */
-/************************************************************************/
-#define H265E_ENC_SET_CUSTOM_GOP_ENABLE      0x015C
-#define H265E_ENC_CUSTOM_GOP_PARAM           0x0160
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_0     0x0164
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_1     0x0168
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_2     0x016C
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_3     0x0170
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_4     0x0174
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_5     0x0178
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_6     0x017C
-#define H265E_ENC_CUSTOM_GOP_PIC_PARAM_7     0x0180
-#define H265E_ENC_CUSTOM_GOP_RESERVED        0x0184
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_0    0x0188
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_1    0x018C
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_2    0x0190
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_3    0x0194
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_4    0x0198
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_5    0x019C
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_6    0x01A0
-#define H265E_ENC_CUSTOM_GOP_PIC_LAMBDA_7    0x01A4
-
-/************************************************************************/
-/* H265 ENCODER - SET_PARAM + VUI                                       */
-/************************************************************************/
-#define H265E_ENC_VUI_PARAM_FLAGS            0x015C
-#define H265E_ENC_VUI_ASPECT_RATIO_IDC       0x0160
-#define H265E_ENC_VUI_SAR_SIZE               0x0164
-#define H265E_ENC_VUI_OVERSCAN_APPROPRIATE   0x0168
-#define H265E_ENC_VUI_VIDEO_SIGNAL           0x016C
-#define H265E_ENC_VUI_CHROMA_SAMPLE_LOC      0x0170
-#define H265E_ENC_VUI_DISP_WIN_LEFT_RIGHT    0x0174
-#define H265E_ENC_VUI_DISP_WIN_TOP_BOT       0x0178
-
-#define H265E_ENC_VUI_HRD_RBSP_PARAM_FLAG    0x017C
-#define H265E_ENC_VUI_RBSP_ADDR              0x0180
-#define H265E_ENC_VUI_RBSP_SIZE              0x0184
-#define H265E_ENC_HRD_RBSP_ADDR              0x0188
-#define H265E_ENC_HRD_RBSP_SIZE              0x018C
-
-/************************************************************************/
-/* H265 ENCODER - SET_FRAMEBUF                                          */
-/************************************************************************/
-#define H265E_FBC_STRIDE_Y                   0x150
-#define H265E_FBC_STRIDE_C                   0x154
-/* 1/4 sub-sampled buffer (for S2 ME)
- *      SUB_SAMPLED_ONE_FB_SIZE = ALIGN16(width/4) * ALIGN8(height/4)
- *      total size for sub-sampled buffer = SUB_SAMPLED_ONE_FB_SIZE * SET_FB_NUM
- */
-#define H265E_ADDR_SUB_SAMPLED_FB_BASE       0x0158
-#define H265E_SUB_SAMPLED_ONE_FB_SIZE        0x015C
-
-/************************************************************************/
-/* ENCODER - ENC_PIC                                                    */
-/************************************************************************/
-#define H265E_CMD_ENC_ADDR_REPORT_BASE       0x015C
-#define H265E_CMD_ENC_REPORT_SIZE            0x0160
-#define H265E_CMD_ENC_REPORT_PARAM           0x0164
-#define H265E_CMD_ENC_CODE_OPTION            0x0168
-#define H265E_CMD_ENC_PIC_PARAM              0x016C
-#define H265E_CMD_ENC_SRC_PIC_IDX            0x0170
-#define H265E_CMD_ENC_SRC_ADDR_Y             0x0174
-#define H265E_CMD_ENC_SRC_ADDR_U             0x0178
-#define H265E_CMD_ENC_SRC_ADDR_V             0x017C
-#define H265E_CMD_ENC_SRC_STRIDE             0x0180
-#define H265E_CMD_ENC_SRC_FORMAT             0x0184
-#define H265E_CMD_ENC_PREFIX_SEI_NAL_ADDR    0x0188
-#define H265E_CMD_ENC_PREFIX_SEI_INFO        0x018C
-#define H265E_CMD_ENC_SUFFIX_SEI_NAL_ADDR    0x0190
-#define H265E_CMD_ENC_SUFFIX_SEI_INFO        0x0194
-#define H265E_CMD_ENC_LONGTERM_PIC           0x0198
-#define H265E_CMD_ENC_SUB_FRAME_SYNC_CONFIG  0x019C
-#define H265E_CMD_ENC_CTU_OPT_PARAM          0x01A0
-#define H265E_CMD_ENC_ROI_ADDR_CTU_MAP       0x01A4
-#define H265E_CMD_ENC_CTU_QP_MAP_ADDR        0x01AC
-#define H265E_CMD_ENC_SRC_TIMESTAMP_LOW      0x01B0
-#define H265E_CMD_ENC_SRC_TIMESTAMP_HIGH     0x01B4
-
-#define H265E_CMD_ENC_FC_PARAM               0x01E8
-#define H265E_CMD_ENC_FC_TABLE_ADDR_Y        0x01EC
-#define H265E_CMD_ENC_FC_TABLE_ADDR_C        0x01F0
-
-#define H265E_RET_ENC_PIC_IDX                0x01A8
-#define H265E_RET_ENC_PIC_SLICE_NUM          0x01AC
-#define H265E_RET_ENC_PIC_SKIP               0x01B0
-#define H265E_RET_ENC_PIC_NUM_INTRA          0x01B4
-#define H265E_RET_ENC_PIC_NUM_MERGE          0x01B8
-#define H265E_RET_ENC_PIC_FLAG               0x01BC
-#define H265E_RET_ENC_PIC_NUM_SKIP           0x01C0
-#define H265E_RET_ENC_PIC_AVG_CU_QP          0x01C4
-#define H265E_RET_ENC_PIC_BYTE               0x01C8
-#define H265E_RET_ENC_GOP_PIC_IDX            0x01CC
-#define H265E_RET_ENC_PIC_POC                0x01D0
-#define H265E_RET_ENC_USED_SRC_IDX           0x01D8
-#define H265E_RET_ENC_PIC_NUM                0x01DC
-#define H265E_RET_ENC_PIC_TYPE               0x01E0
-#define H265E_RET_ENC_VCL_NUT                0x01E4
-
-#define H265E_PERF_AXI_CTRL	             0x0240
-#define H265E_PERF_LATENCY_CTRL0             0x0264
-#define H265E_PERF_LATENCY_CTRL1             0x0268
-#define H265E_PERF_RD_MAX_LATENCY_NUM0       0x026C
-#define H265E_PERF_RD_LATENCY_SAMP_NUM       0x0270
-#define H265E_PERF_RD_LATENCY_ACC_SUM        0x0274
-#define H265E_PERF_RD_AXI_TOTAL_BYTE         0x0278
-#define H265E_PERF_WR_AXI_TOTAL_BYTE         0x027C
-#define H265E_PERF_WORKING_CNT		     0x0280
-#endif
diff --git a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.c b/drivers/video/rockchip/vpu/mpp_dev_rkvenc.c
deleted file mode 100644
index bd8e9ab3def8..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.c
+++ /dev/null
@@ -1,813 +0,0 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: chenhengming chm@rock-chips.com
- *	   Alpha Lin, alpha.lin@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/compiler.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/types.h>
-#include <linux/uaccess.h>
-#include <linux/reset.h>
-
-#include "vpu_iommu_ops.h"
-#include "mpp_service.h"
-#include "mpp_dev_common.h"
-#include "mpp_dev_rkvenc.h"
-
-#define MPP_ALIGN_SIZE	0x1000
-
-#define LINK_TABLE_START	12
-#define LINK_TABLE_LEN		128
-
-#define	RKVENC_ENC_START		0x004
-#define		RKVENC_LKT_NUM(x)			(((x) & 0xff) << 0)
-#define		RKVENC_CMD(x)				(((x) & 0x3) << 8)
-#define		RKVENC_CLK_GATE_EN			BIT(16)
-#define	RKVENC_SAFE_CLR			0x008
-#define	RKVENC_LKT_ADDR			0x00c
-#define	RKVENC_INT_EN			0x010
-#define		RKVENC_INT_EN_SAFE_CLEAR		BIT(2)
-#define		RKVENC_INT_EN_TIMEOUT			BIT(8)
-#define	RKVENC_INT_MSK			0x014
-#define		RKVENC_INT_MSK_OVERFLOW			BIT(4)
-#define		RKVENC_INT_MSK_W_FIFO_FULL		BIT(5)
-#define		RKVENC_INT_MSK_W_CHN_ERROR		BIT(6)
-#define		RKVENC_INT_MSK_R_CHN_ERROR		BIT(7)
-#define		RKVENC_INT_MSK_TIMEOUT			BIT(8)
-#define	RKVENC_INT_CLR			0x018
-#define	RKVENC_INT_STATUS		0x01c
-#define		RKVENC_ONE_FRAME_FINISH			BIT(0)
-#define		RKVENC_LINK_TABLE_FINISH		BIT(1)
-#define		RKVENC_SAFE_CLEAR_FINISH		BIT(2)
-#define		RKVENC_ONE_SLICE_FINISH			BIT(3)
-#define		RKVENC_BIT_STREAM_OVERFLOW		BIT(4)
-#define		RKVENC_AXI_WRITE_FIFO_FULL		BIT(5)
-#define		RKVENC_AXI_WRITE_CHANNEL_ERROR		BIT(6)
-#define		RKVENC_AXI_READ_CHANNEL_ERROR		BIT(7)
-#define		RKVENC_TIMEOUT_ERROR			BIT(8)
-#define RKVENC_INT_ERROR_BITS		((RKVENC_BIT_STREAM_OVERFLOW) |	   \
-					 (RKVENC_AXI_WRITE_FIFO_FULL) |	   \
-					 (RKVENC_AXI_WRITE_CHANNEL_ERROR) |\
-					 (RKVENC_AXI_READ_CHANNEL_ERROR) | \
-					 (RKVENC_TIMEOUT_ERROR))
-#define	RKVENC_ENC_PIC			0x034
-#define		RKVENC_ENC_PIC_NODE_INT_EN		BIT(31)
-#define	RKVENC_ENC_WDG			0x038
-#define		RKVENC_PPLN_ENC_LMT(x)			(((x) & 0xff) << 0)
-#define	RKVENC_OSD_CFG			0x1c0
-#define		RKVENC_OSD_PLT_TYPE			BIT(17)
-#define		RKVENC_OSD_CLK_SEL_BIT			BIT(16)
-#define	RKVENC_STATUS(i)		(0x210 + (4 * (i)))
-#define	RKVENC_BSL_STATUS		0x210
-#define		RKVENC_BITSTREAM_LENGTH(x)		((x) & 0x7FFFFFF)
-#define	RKVENC_ENC_STATUS		0x220
-#define		RKVENC_ENC_STATUS_ENC(x)		(((x) >> 0) & 0x3)
-#define	RKVENC_LKT_STATUS		0x224
-#define		RKVENC_LKT_STATUS_FNUM_ENC(x)		(((x) >> 0) & 0xff)
-#define		RKVENC_LKT_STATUS_FNUM_CFG(x)		(((x) >> 8) & 0xff)
-#define		RKVENC_LKT_STATUS_FNUM_INT(x)		(((x) >> 16) & 0xff)
-#define	RKVENC_OSD_PLT(i)		(0x400 + (4 * (i)))
-
-#define to_rkvenc_ctx(ctx)		\
-		container_of(ctx, struct rkvenc_ctx, ictx)
-#define to_rkvenc_session(session)	\
-		container_of(session, struct rkvenc_session, isession)
-#define to_rkvenc_dev(dev)		\
-		container_of(dev, struct rockchip_rkvenc_dev, idev)
-
-/*
- * file handle translate information
- */
-static const char trans_tbl_rkvenc[] = {
-	70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
-	124, 125, 126, 127, 128, 129, 130, 131
-};
-
-static struct mpp_trans_info trans_rkvenc[1] = {
-	[0] = {
-		.count = sizeof(trans_tbl_rkvenc),
-		.table = trans_tbl_rkvenc,
-	},
-};
-
-static struct mpp_dev_rkvenc_reg mpp_rkvenc_dummy_reg = {
-	.enc_rsl = 0x00070007,          /* 64x64 */
-	.enc_pic = 0x00001714,          /* h264, qp 30 */
-	.enc_wdg = 0x00000002,
-	.dtrns_map = 0x00007000,
-	.dtrns_cfg = 0x0000007f,
-	.src_fmt = 0x00000018,          /* nv12 */
-	.src_strd = 0x003f003f,
-	.sli_spl = 0x00000004,
-	.me_rnge = 0x00002f7b,
-	.me_cnst = 0x000e0505,
-	.me_ram = 0x000e79ab,
-	.rc_qp = 0x07340000,
-	.rdo_cfg = 0x00000002,
-	.synt_nal = 0x00000017,
-	.synt_sps = 0x0000019c,
-	.synt_pps = 0x01000d03,
-	.synt_sli0 = 0x00000002,
-};
-
-static int rockchip_mpp_rkvenc_reset(struct rockchip_mpp_dev *mpp);
-
-/*
- * In order to workaround hw bug which make the first frame run failure with
- * timeout interrupt occur, we make a dummy 64x64 encoding on power on here to
- * cover the hw bug.
- */
-static void rockchip_mpp_war_init(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	size_t img_width = 64;
-	size_t img_height = 64;
-	size_t img_y_size = img_width * img_height;
-	size_t img_uv_size = img_y_size / 2;
-	size_t img_u_size = img_uv_size / 2;
-	size_t img_size = img_y_size + img_uv_size;
-
-	enc->war_reg = &mpp_rkvenc_dummy_reg;
-
-	/* 4k align required */
-	enc->war_reg->adr_rfpw = enc->war_dma_addr;
-	enc->war_reg->adr_srcy = enc->war_reg->adr_rfpw + img_size;
-	enc->war_reg->adr_srcu = enc->war_reg->adr_srcy + img_y_size;
-	enc->war_reg->adr_srcv = enc->war_reg->adr_srcu + img_u_size;
-	enc->war_reg->adr_bsbb = enc->war_reg->adr_srcv + img_u_size;
-	enc->war_reg->adr_bsbt = enc->war_reg->adr_bsbb + img_size;
-	enc->war_reg->adr_bsbr = enc->war_reg->adr_bsbb;
-	enc->war_reg->adr_bsbw = enc->war_reg->adr_bsbb;
-
-	/* 1k align required */
-	enc->war_reg->adr_dspw = enc->war_dma_addr + 0x4000;
-	enc->war_reg->adr_dspr = enc->war_reg->adr_dspw + 0x400;
-
-	enc->dummy_ctx = kzalloc(sizeof(*enc->dummy_ctx), GFP_KERNEL);
-	if (!enc->dummy_ctx)
-		return;
-
-	enc->dummy_ctx->ictx.mpp = mpp;
-	enc->dummy_ctx->ictx.session = NULL;
-	enc->dummy_ctx->mode = RKVENC_MODE_ONEFRAME;
-	enc->dummy_ctx->cfg.mode = RKVENC_MODE_ONEFRAME;
-	atomic_set(&enc->dummy_ctx_in_used, 0);
-	memcpy(enc->dummy_ctx->cfg.elem[0].reg, enc->war_reg,
-	       sizeof(*enc->war_reg));
-	enc->dummy_ctx->cfg.elem[0].reg_num = sizeof(*enc->war_reg) / 4;
-}
-
-static void rockchip_mpp_rkvenc_cfg_palette(struct rockchip_mpp_dev *mpp,
-					    struct mpp_session *isession)
-{
-	struct rkvenc_session *session;
-	int i;
-	u32 reg;
-
-	mpp_debug_enter();
-
-	if (!isession) {
-		mpp_debug(DEBUG_TASK_INFO, "fake ctx, do not cfg palette\n");
-		return;
-	}
-	session = to_rkvenc_session(isession);
-
-	if (!session->palette_valid)
-		return;
-
-	reg = mpp_read(mpp, RKVENC_OSD_CFG);
-	mpp_write(mpp, reg & (~RKVENC_OSD_CLK_SEL_BIT), RKVENC_OSD_CFG);
-
-	for (i = 0; i < RKVENC_OSD_PLT_LEN; i++)
-		mpp_write(mpp, session->palette.plalette[i].elem,
-			  RKVENC_OSD_PLT(i));
-
-	mpp_write(mpp, reg | RKVENC_OSD_CLK_SEL_BIT, RKVENC_OSD_CFG);
-
-	mpp_debug_leave();
-}
-
-static struct mpp_ctx *rockchip_mpp_rkvenc_init(struct rockchip_mpp_dev *mpp,
-						struct mpp_session *session,
-						void __user *src, u32 size)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	struct rkvenc_ctx *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
-	int i;
-
-	mpp_debug_enter();
-
-	if (!ctx)
-		return NULL;
-
-	/* HW defeat workaround start */
-	if (!mpp_dev_is_power_on(mpp) && enc->dummy_ctx &&
-	    atomic_inc_return(&enc->dummy_ctx_in_used) == 1) {
-		mpp_debug(DEBUG_RESET, "add a dummy ctx\n");
-		mpp_srv_pending_locked(mpp->srv, &enc->dummy_ctx->ictx);
-	}
-
-	mpp_dev_common_ctx_init(mpp, &ctx->ictx);
-
-	ctx->ictx.session = session;
-	ctx->mode = RKVENC_MODE_LINKTABLE_FIX;
-
-	size = size > sizeof(ctx->cfg) ? sizeof(ctx->cfg) : size;
-
-	if (copy_from_user(&ctx->cfg, src, size)) {
-		mpp_err("error: copy_from_user failed in reg_init\n");
-		kfree(ctx);
-		return NULL;
-	}
-
-	ctx->mode = ctx->cfg.mode;
-	if (ctx->mode >= RKVENC_MODE_NUM || ctx->mode == RKVENC_MODE_NONE) {
-		mpp_err("Invalid rkvenc running mode %d\n", (int)ctx->mode);
-		kfree(ctx);
-		return NULL;
-	} else if (ctx->mode == RKVENC_MODE_ONEFRAME && ctx->cfg.tbl_num > 1) {
-		mpp_err("Configuration miss match, ignore redundant cfg\n");
-		ctx->cfg.tbl_num = 1;
-	}
-
-	mpp_debug(DEBUG_SET_REG, "tbl num %u, mode %u\n",
-		  ctx->cfg.tbl_num, ctx->cfg.mode);
-
-	for (i = 0; i < ctx->cfg.tbl_num; i++) {
-		if (mpp_reg_address_translate(mpp, ctx->cfg.elem[i].reg,
-					      &ctx->ictx, 0) < 0) {
-			mpp_err("error: translate reg address failed.\n");
-
-			if (unlikely(mpp_dev_debug & DEBUG_DUMP_ERR_REG))
-				mpp_dump_reg_mem(ctx->cfg.elem[i].reg,
-						 ctx->cfg.elem[i].reg_num);
-
-			mpp_dev_common_ctx_deinit(mpp, &ctx->ictx);
-			kfree(ctx);
-
-			return NULL;
-		}
-
-		mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
-			  ctx->cfg.elem[i].ext_inf.cnt,
-			  ctx->cfg.elem[i].ext_inf.magic);
-
-		mpp_translate_extra_info(&ctx->ictx, &ctx->cfg.elem[i].ext_inf,
-					 ctx->cfg.elem[i].reg);
-	}
-
-	mpp_debug_leave();
-
-	return &ctx->ictx;
-}
-
-static int rockchip_mpp_rkvenc_reset_init(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-
-	mpp_debug(DEBUG_RESET, "reset init in:\n");
-	enc->rst_a = devm_reset_control_get(mpp->dev, "video_a");
-	enc->rst_h = devm_reset_control_get(mpp->dev, "video_h");
-	enc->rst_v = devm_reset_control_get(mpp->dev, "video_c");
-
-	if (IS_ERR_OR_NULL(enc->rst_a)) {
-		mpp_err("No aclk reset resource define\n");
-		enc->rst_a = NULL;
-	}
-
-	if (IS_ERR_OR_NULL(enc->rst_h)) {
-		mpp_err("No hclk reset resource define\n");
-		enc->rst_h = NULL;
-	}
-
-	if (IS_ERR_OR_NULL(enc->rst_v)) {
-		mpp_err("No core reset resource define\n");
-		enc->rst_v = NULL;
-	}
-
-	return 0;
-}
-
-static int rockchip_mpp_rkvenc_reset(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	int cnt = 100;
-
-	if (enc->rst_a && enc->rst_h && enc->rst_v) {
-		mpp_debug(DEBUG_RESET, "reset in\n");
-		mpp_write(mpp, 0, RKVENC_INT_EN);
-		mpp_write(mpp, 1, RKVENC_SAFE_CLR);
-		while (cnt-- > 0) {
-			int status;
-
-			usleep_range(100, 200);
-			status = mpp_read(mpp, RKVENC_ENC_STATUS);
-			if (status & 4) {
-				mpp_debug(DEBUG_RESET, "st_enc %08x\n", status);
-				break;
-			}
-		}
-		reset_control_assert(enc->rst_v);
-		reset_control_assert(enc->rst_a);
-		reset_control_assert(enc->rst_h);
-
-		udelay(1);
-
-		reset_control_deassert(enc->rst_v);
-		reset_control_deassert(enc->rst_a);
-		reset_control_deassert(enc->rst_h);
-		mpp_debug(DEBUG_RESET, "reset out\n");
-	}
-	return 0;
-}
-
-static int rockchip_mpp_rkvenc_prepare(struct rockchip_mpp_dev *mpp)
-{
-	struct rkvenc_ctx *ctx_curr;
-	struct rkvenc_ctx *ctx_ready;
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	u32 lkt_status;
-	u32 fnum_int;
-	u32 fnum_cfg;
-	u32 fnum_enc;
-	u8 *cpu_addr;
-	int i;
-
-	u32 reg = 0;
-
-	mpp_debug_enter();
-
-	if (!mpp_srv_is_running(mpp->srv))
-		return 0;
-
-	/* if service running, determine link table mode */
-	ctx_curr = to_rkvenc_ctx(mpp_srv_get_current_ctx(mpp->srv));
-	ctx_ready = to_rkvenc_ctx(mpp_srv_get_pending_ctx(mpp->srv));
-
-	if (ctx_curr->mode != RKVENC_MODE_LINKTABLE_UPDATE ||
-	    ctx_ready->mode != ctx_curr->mode) {
-		mpp_debug(DEBUG_TASK_INFO,
-			  "link table condition not fulfill\n");
-		return -1;
-	}
-
-	lkt_status = mpp_read(mpp, RKVENC_LKT_STATUS);
-	fnum_int = RKVENC_LKT_STATUS_FNUM_INT(lkt_status);
-	fnum_cfg = RKVENC_LKT_STATUS_FNUM_CFG(lkt_status);
-	fnum_enc = RKVENC_LKT_STATUS_FNUM_ENC(lkt_status);
-	cpu_addr = (u8 *)enc->lkt_cpu_addr + fnum_cfg * LINK_TABLE_LEN * 4;
-
-	mpp_dev_power_on(mpp);
-
-	mpp_debug(DEBUG_GET_REG, "frame number int %u, cfg %u, enc %u\n",
-		  fnum_int, fnum_cfg, fnum_enc);
-
-	for (i = 0; i < ctx_ready->cfg.tbl_num; i++) {
-		u32 *src = ctx_ready->cfg.elem[i].reg;
-
-		memcpy(cpu_addr + i * LINK_TABLE_LEN * 4,
-		       &src[LINK_TABLE_START], LINK_TABLE_LEN * 4);
-	}
-
-	reg = RKVENC_CLK_GATE_EN |
-		RKVENC_CMD(ctx_curr->mode) |
-		RKVENC_LKT_NUM(ctx_ready->cfg.tbl_num);
-	mpp_write_relaxed(mpp, reg, RKVENC_ENC_START);
-
-	/* remove from pending queue */
-	mpp_dev_common_ctx_deinit(mpp, &ctx_ready->ictx);
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static int rockchip_mpp_rkvenc_run(struct rockchip_mpp_dev *mpp)
-{
-	struct rkvenc_ctx *ctx =
-			to_rkvenc_ctx(mpp_srv_get_current_ctx(mpp->srv));
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	u32 reg;
-	int i;
-
-	mpp_debug_enter();
-
-	switch (ctx->mode) {
-	case RKVENC_MODE_ONEFRAME:
-		{
-			u32 *src = ctx->cfg.elem[0].reg;
-
-			for (i = 2; i < (LINK_TABLE_START + LINK_TABLE_LEN); i++)
-				mpp_write_relaxed(mpp, src[i], i * 4);
-
-			rockchip_mpp_rkvenc_cfg_palette(mpp, ctx->ictx.session);
-
-			mpp_write_relaxed(mpp, 0x1ff, RKVENC_INT_EN);
-			reg = RKVENC_CLK_GATE_EN
-				| RKVENC_CMD(1);
-			mpp_write(mpp, reg, RKVENC_ENC_START);
-
-			break;
-		}
-	case RKVENC_MODE_LINKTABLE_FIX:
-	case RKVENC_MODE_LINKTABLE_UPDATE:
-		{
-			for (i = 0; i < ctx->cfg.tbl_num; i++) {
-				u32 *src = ctx->cfg.elem[i].reg;
-
-				memcpy(enc->lkt_cpu_addr +
-				       i * LINK_TABLE_LEN * 4,
-				       &src[LINK_TABLE_START],
-				       LINK_TABLE_LEN * 4);
-			}
-
-			rockchip_mpp_rkvenc_cfg_palette(mpp, ctx->ictx.session);
-
-			mpp_write_relaxed(mpp,
-					  enc->lkt_dma_addr,
-					  RKVENC_LKT_ADDR);
-			mpp_write_relaxed(mpp, 0xffffffff, RKVENC_INT_EN);
-
-			reg = RKVENC_LKT_NUM(ctx->cfg.tbl_num) |
-				RKVENC_CMD(RKVENC_MODE_LINKTABLE_FIX) |
-				RKVENC_CLK_GATE_EN;
-
-			mpp_write_relaxed(mpp, reg, RKVENC_ENC_START);
-
-			break;
-		}
-	default:
-		break;
-	}
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static int rockchip_mpp_rkvenc_done(struct rockchip_mpp_dev *mpp)
-{
-	struct mpp_ctx *ictx = mpp_srv_get_current_ctx(mpp->srv);
-	struct rkvenc_ctx *ctx;
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	struct rkvenc_result *result;
-	int i;
-
-	mpp_debug_enter();
-
-	if (IS_ERR_OR_NULL(ictx)) {
-		mpp_err("Invaidate context to save result\n");
-		return -1;
-	}
-
-	ctx = to_rkvenc_ctx(ictx);
-
-	if (enc->irq_status & RKVENC_INT_ERROR_BITS)
-		/*
-		 * according to war running, if the dummy encoding
-		 * running with timeout, we enable a safe clear process,
-		 * we reset the ip, and complete the war procedure.
-		 */
-		atomic_inc(&mpp->reset_request);
-
-	if (ctx == enc->dummy_ctx) {
-		mpp_debug(DEBUG_RESET, "war done\n");
-
-		/* for war do not trigger service done process */
-		list_del_init(&ictx->status_link);
-		atomic_set(&enc->dummy_ctx_in_used, 0);
-
-		/* dummy ctx, do not trigger service to wake up done process */
-		return -1;
-	}
-
-	result = &ctx->result;
-	switch (ctx->mode) {
-	case RKVENC_MODE_ONEFRAME:
-		result->tbl_num = 1;
-		result->elem[0].status = enc->irq_status;
-		for (i = 0; i < sizeof(result->elem[0].result) / 4; i++)
-			result->elem[0].result[i] =
-						    mpp_read(mpp,
-							     RKVENC_STATUS(i));
-		break;
-	case RKVENC_MODE_LINKTABLE_FIX:
-	case RKVENC_MODE_LINKTABLE_UPDATE:
-		{
-			u32 lkt_status = mpp_read(mpp, RKVENC_LKT_STATUS);
-			u32 fnum_int = RKVENC_LKT_STATUS_FNUM_INT(lkt_status);
-			u32 fnum_cfg = RKVENC_LKT_STATUS_FNUM_CFG(lkt_status);
-			u32 fnum_enc = RKVENC_LKT_STATUS_FNUM_ENC(lkt_status);
-
-			u32 *lkt_cpu_addr = (u32 *)enc->lkt_cpu_addr;
-
-			if (unlikely(mpp_dev_debug & DEBUG_DUMP_ERR_REG))
-				mpp_dump_reg_mem(lkt_cpu_addr, LINK_TABLE_LEN);
-
-			result->tbl_num = fnum_int;
-			for (i = 0; i < fnum_int; i++) {
-				result->elem[i].status = enc->irq_status;
-				memcpy(result->elem[i].result,
-				       &lkt_cpu_addr[i * LINK_TABLE_LEN + 120],
-				       sizeof(result->elem[i].result));
-				mpp_debug(DEBUG_GET_REG, "stream length %u\n",
-					  result->elem[i].result[0]);
-			}
-			mpp_debug(DEBUG_GET_REG, "frame number %u, %u, %u\n",
-				  fnum_int, fnum_cfg, fnum_enc);
-			break;
-		}
-	default:
-		break;
-	}
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static int rockchip_mpp_rkvenc_irq(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-
-	enc->irq_status = mpp_read(mpp, RKVENC_INT_STATUS);
-
-	mpp_debug_enter();
-
-	if (enc->irq_status == 0)
-		return -1;
-
-	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n", enc->irq_status);
-	mpp_write(mpp, 0xffffffff, RKVENC_INT_CLR);
-	if (enc->irq_status & RKVENC_INT_ERROR_BITS) {
-		mpp_err("error irq %08x\n", enc->irq_status);
-		/* time out error */
-		mpp_write(mpp, RKVENC_INT_ERROR_BITS, RKVENC_INT_MSK);
-	}
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static int rockchip_mpp_rkvenc_result(struct rockchip_mpp_dev *mpp,
-				      struct mpp_ctx *ictx, u32 __user *dst)
-{
-	struct rkvenc_ctx *ctx = to_rkvenc_ctx(ictx);
-	struct rkvenc_result *result = &ctx->result;
-	unsigned long tbl_size = sizeof(result->tbl_num) +
-				 sizeof(result->elem[0]) * result->tbl_num;
-
-	switch (ctx->mode) {
-	case RKVENC_MODE_ONEFRAME:
-	case RKVENC_MODE_LINKTABLE_FIX:
-	case RKVENC_MODE_LINKTABLE_UPDATE:
-		{
-			if (copy_to_user(dst, &ctx->result, tbl_size)) {
-				mpp_err("copy result to user failed\n");
-				return -1;
-			}
-			break;
-		}
-	default:
-		mpp_err("invalid context mode %d\n", (int)ctx->mode);
-		return -1;
-	}
-
-	return 0;
-}
-
-static long rockchip_mpp_rkvenc_ioctl(struct mpp_session *isession,
-				      unsigned int cmd,
-				      unsigned long arg)
-{
-	struct rkvenc_session *session = to_rkvenc_session(isession);
-
-	mpp_debug_enter();
-
-	switch (cmd) {
-	case MPP_DEV_RKVENC_SET_COLOR_PALETTE:
-		if (copy_from_user(&session->palette, (void __user *)arg,
-				   sizeof(session->palette))) {
-			mpp_err("copy palette from user failed\n");
-			return -EINVAL;
-		}
-		session->palette_valid = true;
-
-		break;
-	default:
-		mpp_err("%s, unknown ioctl cmd %x\n",
-			dev_name(isession->mpp->dev), cmd);
-		break;
-	}
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static struct mpp_session *mpp_dev_rkvenc_open(struct rockchip_mpp_dev *mpp)
-{
-	struct rkvenc_session *session = kzalloc(sizeof(*session), GFP_KERNEL);
-
-	mpp_debug_enter();
-
-	if (!session)
-		return NULL;
-
-	session->palette_valid = false;
-
-	mpp_debug_leave();
-
-	return &session->isession;
-}
-
-static void mpp_dev_rkvenc_free(struct mpp_session *isession)
-{
-	struct rkvenc_session *session = to_rkvenc_session(isession);
-
-	kfree(session);
-}
-
-struct mpp_dev_ops rkvenc_ops = {
-	.init = rockchip_mpp_rkvenc_init,
-	.prepare = rockchip_mpp_rkvenc_prepare,
-	.run = rockchip_mpp_rkvenc_run,
-	.done = rockchip_mpp_rkvenc_done,
-	.irq = rockchip_mpp_rkvenc_irq,
-	.result = rockchip_mpp_rkvenc_result,
-	.ioctl = rockchip_mpp_rkvenc_ioctl,
-	.open = mpp_dev_rkvenc_open,
-	.free = mpp_dev_rkvenc_free,
-};
-
-static void rockchip_mpp_rkvenc_power_on(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-
-	if (enc->aclk)
-		clk_prepare_enable(enc->aclk);
-	if (enc->hclk)
-		clk_prepare_enable(enc->hclk);
-	if (enc->core)
-		clk_prepare_enable(enc->core);
-
-	/*
-	 * Because hw cannot reset status fully in all its modules, we make a
-	 * reset here to make sure the hw status fully reset.
-	 */
-	rockchip_mpp_rkvenc_reset(mpp);
-}
-
-static void rockchip_mpp_rkvenc_power_off(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-
-	if (enc->core)
-		clk_disable_unprepare(enc->core);
-	if (enc->hclk)
-		clk_disable_unprepare(enc->hclk);
-	if (enc->aclk)
-		clk_disable_unprepare(enc->aclk);
-}
-
-static int rockchip_mpp_rkvenc_probe(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	struct mpp_session *session = list_first_entry(&mpp->srv->session,
-						       struct mpp_session,
-						       list_session);
-	int ret;
-	size_t tmp;
-
-	enc->idev.ops = &rkvenc_ops;
-
-	enc->lkt_hdl = vpu_iommu_alloc(mpp->iommu_info, session,
-				       LINK_TABLE_LEN * 4 * 256,
-				       MPP_ALIGN_SIZE);
-
-	if (enc->lkt_hdl < 0) {
-		dev_err(mpp->dev, "allocate link table buffer failure\n");
-		return -1;
-	}
-
-	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
-				  enc->lkt_hdl, &enc->lkt_dma_addr, &tmp);
-
-	if (ret < 0) {
-		dev_err(mpp->dev, "get link table dma_addr failed\n");
-		goto fail;
-	}
-
-	enc->lkt_cpu_addr = vpu_iommu_map_kernel(mpp->iommu_info,
-						 session, enc->lkt_hdl);
-
-	/*
-	 * buffer for workaround context running, include input picture, output
-	 * stream, reconstruction picture. we set the output stream buffer to 1
-	 * time picture size, so the total buffer size is 3 times picture size,
-	 * 64 * 64 * 3 / 2 * 3 = 4.5 * 4k.
-	 */
-	enc->war_hdl = vpu_iommu_alloc(mpp->iommu_info, session,
-				       MPP_ALIGN_SIZE * 5,
-				       MPP_ALIGN_SIZE);
-	if (enc->war_hdl < 0) {
-		dev_err(mpp->dev, "allocate workaround buffer failure\n");
-		goto fail;
-	}
-
-	ret = vpu_iommu_map_iommu(mpp->iommu_info, session,
-				  enc->war_hdl, &enc->war_dma_addr, &tmp);
-
-	if (ret < 0) {
-		dev_err(mpp->dev, "get war dma_addr failed\n");
-		goto fail;
-	}
-
-	rockchip_mpp_war_init(mpp);
-
-	enc->aclk = devm_clk_get(mpp->dev, "aclk_vcodec");
-	if (IS_ERR_OR_NULL(enc->aclk)) {
-		dev_err(mpp->dev, "failed on clk_get aclk\n");
-		goto fail;
-	}
-
-	enc->hclk = devm_clk_get(mpp->dev, "hclk_vcodec");
-	if (IS_ERR_OR_NULL(enc->hclk)) {
-		dev_err(mpp->dev, "failed on clk_get hclk\n");
-		goto fail;
-	}
-
-	enc->core = devm_clk_get(mpp->dev, "clk_core");
-	if (IS_ERR_OR_NULL(enc->core)) {
-		dev_err(mpp->dev, "failed on clk_get core\n");
-		goto fail;
-	}
-
-	rockchip_mpp_rkvenc_reset_init(mpp);
-
-	return 0;
-
-fail:
-	kfree(enc->dummy_ctx);
-
-	if (enc->war_hdl >= 0) {
-		vpu_iommu_unmap_iommu(mpp->iommu_info,
-				      session, enc->war_hdl);
-		vpu_iommu_free(mpp->iommu_info, session, enc->war_hdl);
-	}
-	if (enc->lkt_cpu_addr)
-		vpu_iommu_unmap_kernel(mpp->iommu_info, session, enc->lkt_hdl);
-	if (enc->lkt_hdl >= 0) {
-		vpu_iommu_unmap_iommu(mpp->iommu_info,
-				      session, enc->lkt_hdl);
-		vpu_iommu_free(mpp->iommu_info, session, enc->lkt_hdl);
-	}
-
-	return -1;
-}
-
-static void rockchip_mpp_rkvenc_remove(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_rkvenc_dev *enc = to_rkvenc_dev(mpp);
-	struct mpp_session *session = list_first_entry(&mpp->srv->session,
-						       struct mpp_session,
-						       list_session);
-
-	vpu_iommu_unmap_kernel(mpp->iommu_info, session, enc->lkt_hdl);
-	vpu_iommu_unmap_iommu(mpp->iommu_info,
-			      session, enc->lkt_hdl);
-	vpu_iommu_free(mpp->iommu_info, session, enc->lkt_hdl);
-
-	vpu_iommu_unmap_iommu(mpp->iommu_info,
-			      session, enc->war_hdl);
-	vpu_iommu_free(mpp->iommu_info, session, enc->war_hdl);
-
-	kfree(enc->dummy_ctx);
-}
-
-const struct rockchip_mpp_dev_variant rkvenc_variant = {
-	.data_len = sizeof(struct rockchip_rkvenc_dev),
-	.reg_len = 140,
-	.trans_info = trans_rkvenc,
-	.hw_probe = rockchip_mpp_rkvenc_probe,
-	.hw_remove = rockchip_mpp_rkvenc_remove,
-	.power_on = rockchip_mpp_rkvenc_power_on,
-	.power_off = rockchip_mpp_rkvenc_power_off,
-	.reset = rockchip_mpp_rkvenc_reset,
-};
-EXPORT_SYMBOL(rkvenc_variant);
-
diff --git a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.h b/drivers/video/rockchip/vpu/mpp_dev_rkvenc.h
deleted file mode 100644
index a9fad2c86600..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_rkvenc.h
+++ /dev/null
@@ -1,177 +0,0 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: chenhengming chm@rock-chips.com
- *	   Alpha Lin, alpha.lin@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef __ROCKCHIP_MPP_DEV_RKVENC_H
-#define __ROCKCHIP_MPP_DEV_RKVENC_H
-
-union rkvenc_osd_palette_elem {
-	struct  {
-		u8 y;
-		u8 u;
-		u8 v;
-		u8 alpha;
-	};
-	u32 elem;
-};
-
-#define	RKVENC_OSD_PLT_LEN		256
-struct rkvenc_osd_palette {
-	union rkvenc_osd_palette_elem plalette[RKVENC_OSD_PLT_LEN];
-};
-
-#define MPP_DEV_RKVENC_SET_COLOR_PALETTE	\
-			_IOW(MPP_IOC_MAGIC, MPP_IOC_CUSTOM_BASE + 1,	\
-			struct rkvenc_osd_palette)
-
-struct rkvenc_config_elem {
-	u32 reg_num;
-	u32 reg[140];
-	struct extra_info_for_iommu ext_inf;
-};
-
-struct rkvenc_config {
-	u32 mode;
-	u32 tbl_num;
-	struct rkvenc_config_elem elem[10];
-};
-
-struct rkvenc_result_elem {
-	u32 status;
-	u32 result[11];
-};
-
-struct rkvenc_result {
-	u32 tbl_num;
-	struct rkvenc_result_elem elem[10];
-};
-
-struct rkvenc_ctx {
-	struct mpp_ctx ictx;
-	enum RKVENC_MODE mode;
-
-	struct rkvenc_config cfg;
-
-	/* store status read from hw, oneframe mode used only */
-	struct rkvenc_result result;
-};
-
-struct rkvenc_session {
-	struct mpp_session isession;
-
-	struct rkvenc_osd_palette palette;
-	bool palette_valid;
-};
-
-struct mpp_dev_rkvenc_reg {
-	u32 unused_00;
-	u32 enc_strt;
-	u32 enc_clr;
-	u32 lkt_addr;
-	u32 int_en;
-	u32 int_msk;
-	u32 int_clr;
-	u32 unused_20[4];
-	u32 int_stus;
-	/* 12 */
-	u32 enc_rsl;
-	u32 enc_pic;
-	u32 enc_wdg;
-	u32 dtrns_map;
-	u32 dtrns_cfg;
-	u32 src_fmt;
-	u32 src_udfy;
-	u32 src_udfu;
-	u32 src_udfv;
-	u32 src_udfo;
-	u32 src_proc;
-	u32 src_tthrd;
-	u32 src_stbl[5];
-	u32 h3d_tbl[40];
-	u32 src_strd;
-	u32 adr_srcy;
-	u32 adr_srcu;
-	u32 adr_srcv;
-	u32 adr_fltw;
-	u32 adr_fltr;
-	u32 adr_ctuc;
-	u32 adr_rfpw;
-	u32 adr_rfpr;
-	u32 adr_cmvw;
-	u32 adr_cmvr;
-	u32 adr_dspw;
-	u32 adr_dspr;
-	u32 adr_meiw;
-	u32 adr_bsbt;
-	u32 adr_bsbb;
-	u32 adr_bsbr;
-	u32 adr_bsbw;
-	u32 sli_spl;
-	u32 sli_spl_byte;
-	u32 me_rnge;
-	u32 me_cnst;
-	u32 me_ram;
-	u32 rc_cfg;
-	u32 rc_erp[5];
-	u32 rc_adj[2];
-	u32 rc_qp;
-	u32 rc_tgt;
-	u32 rdo_cfg;
-	u32 synt_nal;
-	u32 synt_sps;
-	u32 synt_pps;
-	u32 synt_sli0;
-	u32 synt_sli1;
-	u32 synt_sli2_rodr;
-	u32 synt_ref_mark0;
-	u32 synt_ref_mark1;
-	u32 osd_cfg;
-	u32 osd_inv;
-	u32 unused_1c8[2];
-	u32 osd_pos[8];
-	u32 osd_addr[8];
-	u32 unused_210[9];
-};
-
-struct rockchip_rkvenc_dev {
-	struct rockchip_mpp_dev idev;
-	unsigned long lkt_dma_addr;
-	int lkt_hdl;
-	void *lkt_cpu_addr;
-	u32 irq_status;
-	unsigned long war_dma_addr;
-	int war_hdl;
-	struct mpp_dev_rkvenc_reg *war_reg;
-	struct rkvenc_ctx *dummy_ctx;
-	atomic_t dummy_ctx_in_used;
-
-	struct clk *aclk;
-	struct clk *hclk;
-	struct clk *core;
-
-	struct reset_control *rst_a;
-	struct reset_control *rst_h;
-	struct reset_control *rst_v;
-};
-
-struct link_table_elem {
-	unsigned long lkt_dma_addr;
-	int lkt_hdl;
-	void *lkt_cpu_addr;
-	u32 lkt_index;
-	struct list_head list;
-};
-
-#endif
diff --git a/drivers/video/rockchip/vpu/mpp_iommu_dma.c b/drivers/video/rockchip/vpu/mpp_iommu_dma.c
new file mode 100644
index 000000000000..a73b09b94365
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_iommu_dma.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 - 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *		Randy Li, <ayaka@soulik.info>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/dma-buf.h>
+#include <linux/dma-iommu.h>
+#include <linux/iommu.h>
+#include <linux/kref.h>
+#include <linux/rcupdate.h>
+#include <linux/slab.h>
+
+#include "mpp_iommu_dma.h"
+
+/* pixel buffer, stream buffer and video codec buffer, not used */
+#define BUFFER_LIST_MAX_NUMS		30
+
+struct mpp_dma_buffer {
+	struct list_head list;
+	struct mpp_dma_session *session;
+	/* DMABUF information */
+	struct dma_buf *dma_buf;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	enum dma_data_direction dir;
+
+	dma_addr_t iova;
+	unsigned long size;
+	/* Only be used for identifying the buffer */
+	int fd;
+
+	struct kref ref;
+	struct rcu_head rcu;
+};
+
+struct mpp_iommu_info {
+	struct iommu_domain *domain;
+	struct iommu_group *group;
+};
+
+struct mpp_dma_session {
+	struct list_head buffer_list;
+	/* the mutex for the above buffer list */
+	struct mutex list_mutex;
+
+	struct device *dev;
+};
+
+static struct mpp_dma_buffer *
+mpp_dma_find_buffer(struct mpp_dma_session *session, int fd)
+{
+	struct mpp_dma_buffer *buffer = NULL;
+
+	list_for_each_entry_rcu(buffer, &session->buffer_list, list) {
+		/*
+		 * As long as the last reference is hold by the buffer pool,
+		 * the same fd won't be assigned to the other application.
+		 */
+		if (buffer->fd == fd)
+			return buffer;
+	}
+
+	return NULL;
+}
+
+/* Release the buffer from the current list */
+static void mpp_dma_buffer_delete_rcu(struct kref *ref)
+{
+	struct mpp_dma_buffer *buffer =
+		container_of(ref, struct mpp_dma_buffer, ref);
+
+	mutex_lock(&buffer->session->list_mutex);
+	list_del_rcu(&buffer->list);
+	mutex_unlock(&buffer->session->list_mutex);
+
+	dma_buf_unmap_attachment(buffer->attach, buffer->sgt, buffer->dir);
+	dma_buf_detach(buffer->dma_buf, buffer->attach);
+	dma_buf_put(buffer->dma_buf);
+	kfree_rcu(buffer, rcu);
+}
+
+int mpp_dma_release_fd(struct mpp_dma_session *session, int fd)
+{
+	struct device *dev = session->dev;
+	struct mpp_dma_buffer *buffer = NULL;
+
+	rcu_read_lock();
+	buffer = mpp_dma_find_buffer(session, fd);
+	rcu_read_unlock();
+	if (IS_ERR_OR_NULL(buffer)) {
+		dev_err(dev, "can not find %d buffer in list to release\n", fd);
+
+		return -EINVAL;
+	}
+
+	kref_put(&buffer->ref, mpp_dma_buffer_delete_rcu);
+
+	return 0;
+}
+
+dma_addr_t mpp_dma_import_fd(struct mpp_dma_session *session, int fd)
+{
+	struct mpp_dma_buffer *buffer = NULL;
+	struct dma_buf_attachment *attach;
+	struct sg_table *sgt;
+	struct dma_buf *dma_buf;
+	int ret = 0;
+
+	if (!session)
+		return -EINVAL;
+
+	dma_buf = dma_buf_get(fd);
+	if (IS_ERR(dma_buf)) {
+		ret = PTR_ERR(dma_buf);
+		return ret;
+	}
+
+	rcu_read_lock();
+	buffer = mpp_dma_find_buffer(session, fd);
+	if (!IS_ERR_OR_NULL(buffer)) {
+		if (buffer->dma_buf == dma_buf) {
+			if (kref_get_unless_zero(&buffer->ref)) {
+				dma_buf_put(dma_buf);
+				rcu_read_unlock();
+				return buffer->iova;
+			}
+		}
+		rcu_read_unlock();
+		dev_dbg(session->dev,
+			"missing the fd %d\n", fd);
+		kref_put(&buffer->ref, mpp_dma_buffer_delete_rcu);
+	} else {
+		rcu_read_unlock();
+	}
+
+	/* A new DMA buffer */
+	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
+	if (!buffer) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	buffer->dma_buf = dma_buf;
+	buffer->fd = fd;
+	/* TODO */
+	buffer->dir = DMA_BIDIRECTIONAL;
+
+	kref_init(&buffer->ref);
+
+	attach = dma_buf_attach(buffer->dma_buf, session->dev);
+	if (IS_ERR(attach)) {
+		ret = PTR_ERR(attach);
+		goto fail_out;
+	}
+
+	sgt = dma_buf_map_attachment(attach, buffer->dir);
+	if (IS_ERR(sgt)) {
+		ret = PTR_ERR(sgt);
+		goto fail_detach;
+	}
+
+	buffer->iova = sg_dma_address(sgt->sgl);
+	buffer->size = sg_dma_len(sgt->sgl);
+
+	buffer->attach = attach;
+	buffer->sgt = sgt;
+
+	/* Increase the reference for used outside the buffer pool */
+	kref_get(&buffer->ref);
+
+	INIT_LIST_HEAD(&buffer->list);
+
+	mutex_lock(&session->list_mutex);
+	buffer->session = session;
+	list_add_tail_rcu(&buffer->list, &session->buffer_list);
+	mutex_unlock(&session->list_mutex);
+
+	return buffer->iova;
+
+fail_detach:
+	dma_buf_detach(buffer->dma_buf, attach);
+fail_out:
+	kfree(buffer);
+err:
+	dma_buf_put(dma_buf);
+	return ret;
+}
+
+void mpp_dma_destroy_session(struct mpp_dma_session *session)
+{
+	struct mpp_dma_buffer *buffer = NULL;
+
+	if (!session)
+		return;
+
+	mutex_lock(&session->list_mutex);
+	list_for_each_entry_rcu(buffer, &session->buffer_list, list) {
+		list_del_rcu(&buffer->list);
+		dma_buf_unmap_attachment(buffer->attach, buffer->sgt,
+					 buffer->dir);
+		dma_buf_detach(buffer->dma_buf, buffer->attach);
+		dma_buf_put(buffer->dma_buf);
+		kfree_rcu(buffer, rcu);
+	}
+	mutex_unlock(&session->list_mutex);
+
+	kfree(session);
+}
+
+struct mpp_dma_session *mpp_dma_session_create(struct device *dev)
+{
+	struct mpp_dma_session *session = NULL;
+
+	session = kzalloc(sizeof(*session), GFP_KERNEL);
+	if (!session)
+		return session;
+
+	INIT_LIST_HEAD(&session->buffer_list);
+	mutex_init(&session->list_mutex);
+
+	session->dev = dev;
+
+	return session;
+}
+
+void mpp_iommu_detach(struct mpp_iommu_info *info)
+{
+	struct iommu_domain *domain = info->domain;
+	struct iommu_group *group = info->group;
+
+	iommu_detach_group(domain, group);
+}
+
+int mpp_iommu_attach(struct mpp_iommu_info *info)
+{
+	struct iommu_domain *domain = info->domain;
+	struct iommu_group *group = info->group;
+	int ret;
+
+	ret = iommu_attach_group(domain, group);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+struct mpp_iommu_info *mpp_iommu_probe(struct device *dev)
+{
+	struct mpp_iommu_info *info = NULL;
+	int ret = 0;
+
+	info = kzalloc(sizeof(*info), GFP_KERNEL);
+	if (!info) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	info->group = iommu_group_get(dev);
+	if (!info->group) {
+		ret = -EINVAL;
+		goto err_free_info;
+	}
+
+	info->domain = iommu_get_domain_for_dev(dev);
+	if (!info->domain) {
+		ret = -EINVAL;
+		goto err_put_group;
+	}
+
+	return info;
+
+err_put_group:
+	iommu_group_put(info->group);
+err_free_info:
+	kfree(info);
+err:
+	return ERR_PTR(ret);
+}
+
+int mpp_iommu_remove(struct mpp_iommu_info *info)
+{
+	iommu_group_put(info->group);
+	kfree(info);
+
+	return 0;
+}
diff --git a/drivers/video/rockchip/vpu/mpp_iommu_dma.h b/drivers/video/rockchip/vpu/mpp_iommu_dma.h
new file mode 100644
index 000000000000..5f4d27736986
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_iommu_dma.h
@@ -0,0 +1,37 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *		Randy Li, <ayaka@soulik.info>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef __VCODEC_IOMMU_DMA_H__
+#define __VCODEC_IOMMU_DMA_H__
+
+#include <linux/dma-mapping.h>
+
+struct mpp_iommu_info;
+struct mpp_dma_session;
+
+struct mpp_dma_session *mpp_dma_session_create(struct device *dev);
+void mpp_dma_destroy_session(struct mpp_dma_session *session);
+
+dma_addr_t mpp_dma_import_fd(struct mpp_dma_session *session, int fd);
+int mpp_dma_release_fd(struct mpp_dma_session *session, int fd);
+
+struct mpp_iommu_info *mpp_iommu_probe(struct device *dev);
+int mpp_iommu_remove(struct mpp_iommu_info *info);
+
+int mpp_iommu_attach(struct mpp_iommu_info *info);
+void mpp_iommu_detach(struct mpp_iommu_info *info);
+
+#endif
diff --git a/drivers/video/rockchip/vpu/mpp_service.h b/drivers/video/rockchip/vpu/mpp_service.h
index 8e7287f75cee..b60d6b02c8b3 100644
--- a/drivers/video/rockchip/vpu/mpp_service.h
+++ b/drivers/video/rockchip/vpu/mpp_service.h
@@ -22,6 +22,7 @@
 #include "mpp_dev_common.h"
 
 struct mpp_session {
+	struct mpp_dma_session *dma;
 	/* a linked list of data so we can access them for debugging */
 	struct list_head list_session;
 	/* the session related device private data */
diff --git a/drivers/video/rockchip/vpu/vpu_iommu_drm.c b/drivers/video/rockchip/vpu/vpu_iommu_drm.c
deleted file mode 100644
index ef307c57051b..000000000000
--- a/drivers/video/rockchip/vpu/vpu_iommu_drm.c
+++ /dev/null
@@ -1,936 +0,0 @@
-/*
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: Jung Zhao jung.zhao@rock-chips.com
- *         Randy Li, randy.li@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/dma-iommu.h>
-
-#include <linux/dma-buf.h>
-#include <drm/drmP.h>
-#include <drm/drm_atomic.h>
-#include <drm/drm_crtc_helper.h>
-#include <drm/drm_fb_helper.h>
-#include <drm/drm_sync_helper.h>
-#include <drm/rockchip_drm.h>
-#include <linux/dma-mapping.h>
-#include <linux/rockchip-iovmm.h>
-#include <linux/pm_runtime.h>
-#include <linux/memblock.h>
-#include <linux/module.h>
-#include <linux/of_address.h>
-#include <linux/of_graph.h>
-#include <linux/component.h>
-#include <linux/fence.h>
-#include <linux/console.h>
-#include <linux/kref.h>
-#include <linux/fdtable.h>
-#include <linux/ktime.h>
-#include <linux/iova.h>
-
-#include "vpu_iommu_ops.h"
-
-#define VPU_DRM_BUFFER_ALLOC	0x00000001
-
-struct vpu_drm_buffer {
-	struct list_head list;
-	struct dma_buf *dma_buf;
-	union {
-		unsigned long iova;
-		unsigned long phys;
-	};
-	void *cpu_addr;
-	unsigned long size;
-	int index;
-	struct dma_buf_attachment *attach;
-	struct sg_table *sgt;
-	struct sg_table *copy_sgt;
-	struct page **pages;
-	struct kref ref;
-	struct vpu_iommu_session_info *session_info;
-	ktime_t last_used;
-	int flags;
-};
-
-struct vpu_iommu_drm_info {
-	struct iommu_domain *domain;
-	bool attached;
-};
-
-static struct vpu_drm_buffer *
-vpu_drm_get_buffer_no_lock(struct vpu_iommu_session_info *session_info,
-			   int idx)
-{
-	struct vpu_drm_buffer *drm_buffer = NULL, *n;
-
-	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
-				 list) {
-		if (drm_buffer->index == idx) {
-			drm_buffer->last_used = ktime_get();
-			return drm_buffer;
-		}
-	}
-
-	return NULL;
-}
-
-static struct vpu_drm_buffer*
-vpu_drm_get_buffer_fd_no_lock(struct vpu_iommu_session_info *session_info,
-			      int fd)
-{
-	struct vpu_drm_buffer *drm_buffer = NULL, *n;
-	struct dma_buf *dma_buf = NULL;
-
-	dma_buf = dma_buf_get(fd);
-
-	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
-				 list) {
-		if (drm_buffer->dma_buf == dma_buf) {
-			drm_buffer->last_used = ktime_get();
-			dma_buf_put(dma_buf);
-			return drm_buffer;
-		}
-	}
-
-	dma_buf_put(dma_buf);
-
-	return NULL;
-}
-
-static void vpu_drm_detach(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
-	struct device *dev = iommu_info->dev;
-	struct iommu_domain *domain = drm_info->domain;
-
-	mutex_lock(&iommu_info->iommu_mutex);
-
-	if (!drm_info->attached) {
-		mutex_unlock(&iommu_info->iommu_mutex);
-		return;
-	}
-
-	iommu_detach_device(domain, dev);
-	drm_info->attached = false;
-
-	mutex_unlock(&iommu_info->iommu_mutex);
-}
-
-static int vpu_drm_attach_unlock(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
-	struct device *dev = iommu_info->dev;
-	struct iommu_domain *domain = drm_info->domain;
-	int ret = 0;
-
-	ret = dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
-	if (ret)
-		return ret;
-
-	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
-	ret = iommu_attach_device(domain, dev);
-	if (ret) {
-		dev_err(dev, "Failed to attach iommu device\n");
-		return ret;
-	}
-
-	return ret;
-}
-
-static int vpu_drm_attach(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
-	int ret;
-
-	mutex_lock(&iommu_info->iommu_mutex);
-
-	if (drm_info->attached) {
-		mutex_unlock(&iommu_info->iommu_mutex);
-		return 0;
-	}
-
-	ret = vpu_drm_attach_unlock(iommu_info);
-	if (ret) {
-		mutex_unlock(&iommu_info->iommu_mutex);
-		return ret;
-	}
-
-	drm_info->attached = true;
-
-	mutex_unlock(&iommu_info->iommu_mutex);
-
-	return ret;
-}
-
-static void *vpu_drm_sgt_map_kernel(struct vpu_drm_buffer *drm_buffer)
-{
-	struct vpu_iommu_session_info *session_info =
-						      drm_buffer->session_info;
-	struct device *dev = session_info->dev;
-	struct scatterlist *sgl, *sg;
-	int nr_pages = PAGE_ALIGN(drm_buffer->size) >> PAGE_SHIFT;
-	int i = 0, j = 0, k = 0;
-	struct page *page;
-
-	drm_buffer->pages = kmalloc_array(nr_pages, sizeof(*drm_buffer->pages),
-					  GFP_KERNEL);
-	if (!(drm_buffer->pages)) {
-		dev_err(dev, "drm map can not alloc pages\n");
-
-		return NULL;
-	}
-
-	sgl = drm_buffer->copy_sgt->sgl;
-
-	for_each_sg(sgl, sg, drm_buffer->copy_sgt->nents, i) {
-		page = sg_page(sg);
-		for (j = 0; j < sg->length / PAGE_SIZE; j++)
-			drm_buffer->pages[k++] = page++;
-	}
-
-	return vmap(drm_buffer->pages, nr_pages, VM_MAP,
-		    pgprot_noncached(PAGE_KERNEL));
-}
-
-static void vpu_drm_sgt_unmap_kernel(struct vpu_drm_buffer *drm_buffer)
-{
-	vunmap(drm_buffer->cpu_addr);
-	kfree(drm_buffer->pages);
-}
-
-static int vpu_finalise_sg(struct scatterlist *sg,
-			   int nents,
-			   dma_addr_t dma_addr)
-{
-	struct scatterlist *s, *cur = sg;
-	unsigned long seg_mask = DMA_BIT_MASK(32);
-	unsigned int cur_len = 0, max_len = DMA_BIT_MASK(32);
-	int i, count = 0;
-
-	for_each_sg(sg, s, nents, i) {
-		/* Restore this segment's original unaligned fields first */
-		unsigned int s_iova_off = sg_dma_address(s);
-		unsigned int s_length = sg_dma_len(s);
-		unsigned int s_iova_len = s->length;
-
-		s->offset += s_iova_off;
-		s->length = s_length;
-		sg_dma_address(s) = DMA_ERROR_CODE;
-		sg_dma_len(s) = 0;
-
-		/*
-		 * Now fill in the real DMA data. If...
-		 * - there is a valid output segment to append to
-		 * - and this segment starts on an IOVA page boundary
-		 * - but doesn't fall at a segment boundary
-		 * - and wouldn't make the resulting output segment too long
-		 */
-		if (cur_len && !s_iova_off && (dma_addr & seg_mask) &&
-		    (cur_len + s_length <= max_len)) {
-			/* ...then concatenate it with the previous one */
-			cur_len += s_length;
-		} else {
-			/* Otherwise start the next output segment */
-			if (i > 0)
-				cur = sg_next(cur);
-			cur_len = s_length;
-			count++;
-
-			sg_dma_address(cur) = dma_addr + s_iova_off;
-		}
-
-		sg_dma_len(cur) = cur_len;
-		dma_addr += s_iova_len;
-
-		if (s_length + s_iova_off < s_iova_len)
-			cur_len = 0;
-	}
-	return count;
-}
-
-static void vpu_invalidate_sg(struct scatterlist *sg, int nents)
-{
-	struct scatterlist *s;
-	int i;
-
-	for_each_sg(sg, s, nents, i) {
-		if (sg_dma_address(s) != DMA_ERROR_CODE)
-			s->offset += sg_dma_address(s);
-		if (sg_dma_len(s))
-			s->length = sg_dma_len(s);
-		sg_dma_address(s) = DMA_ERROR_CODE;
-		sg_dma_len(s) = 0;
-	}
-}
-
-static dma_addr_t vpu_dma_map_sg(struct iommu_domain *domain,
-				 struct scatterlist *sg,
-				 int nents, int prot)
-{
-	struct iova_domain *iovad = domain->iova_cookie;
-	struct iova *iova;
-	struct scatterlist *s, *prev = NULL;
-	dma_addr_t dma_addr;
-	size_t iova_len = 0;
-	unsigned long mask = DMA_BIT_MASK(32);
-	unsigned long shift = iova_shift(iovad);
-	int i;
-
-	/*
-	 * Work out how much IOVA space we need, and align the segments to
-	 * IOVA granules for the IOMMU driver to handle. With some clever
-	 * trickery we can modify the list in-place, but reversibly, by
-	 * stashing the unaligned parts in the as-yet-unused DMA fields.
-	 */
-	for_each_sg(sg, s, nents, i) {
-		size_t s_iova_off = iova_offset(iovad, s->offset);
-		size_t s_length = s->length;
-		size_t pad_len = (mask - iova_len + 1) & mask;
-
-		sg_dma_address(s) = s_iova_off;
-		sg_dma_len(s) = s_length;
-		s->offset -= s_iova_off;
-		s_length = iova_align(iovad, s_length + s_iova_off);
-		s->length = s_length;
-
-		/*
-		 * Due to the alignment of our single IOVA allocation, we can
-		 * depend on these assumptions about the segment boundary mask:
-		 * - If mask size >= IOVA size, then the IOVA range cannot
-		 *   possibly fall across a boundary, so we don't care.
-		 * - If mask size < IOVA size, then the IOVA range must start
-		 *   exactly on a boundary, therefore we can lay things out
-		 *   based purely on segment lengths without needing to know
-		 *   the actual addresses beforehand.
-		 * - The mask must be a power of 2, so pad_len == 0 if
-		 *   iova_len == 0, thus we cannot dereference prev the first
-		 *   time through here (i.e. before it has a meaningful value).
-		 */
-		if (pad_len && pad_len < s_length - 1) {
-			prev->length += pad_len;
-			iova_len += pad_len;
-		}
-
-		iova_len += s_length;
-		prev = s;
-	}
-
-	iova = alloc_iova(iovad, iova_align(iovad, iova_len) >> shift,
-			  mask >> shift, true);
-	if (!iova)
-		goto out_restore_sg;
-
-	/*
-	 * We'll leave any physical concatenation to the IOMMU driver's
-	 * implementation - it knows better than we do.
-	 */
-	dma_addr = iova_dma_addr(iovad, iova);
-	if (iommu_map_sg(domain, dma_addr, sg, nents, prot) < iova_len)
-		goto out_free_iova;
-
-	return vpu_finalise_sg(sg, nents, dma_addr);
-
-out_free_iova:
-	__free_iova(iovad, iova);
-out_restore_sg:
-	vpu_invalidate_sg(sg, nents);
-	return 0;
-}
-
-static void vpu_dma_unmap_sg(struct iommu_domain *domain,
-			     dma_addr_t dma_addr)
-{
-	struct iova_domain *iovad = domain->iova_cookie;
-	unsigned long shift = iova_shift(iovad);
-	unsigned long pfn = dma_addr >> shift;
-	struct iova *iova = find_iova(iovad, pfn);
-	size_t size;
-
-	if (WARN_ON(!iova))
-		return;
-
-	size = iova_size(iova) << shift;
-	size -= iommu_unmap(domain, pfn << shift, size);
-	/* ...and if we can't, then something is horribly, horribly wrong */
-	WARN_ON(size > 0);
-	__free_iova(iovad, iova);
-}
-
-static void vpu_drm_clear_map(struct kref *ref)
-{
-	struct vpu_drm_buffer *drm_buffer =
-					    container_of(ref,
-							 struct vpu_drm_buffer,
-							 ref);
-	struct vpu_iommu_session_info *session_info =
-						      drm_buffer->session_info;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
-					      struct sg_table *table;
-					      struct scatterlist *sg;
-					      struct page *page;
-					      int i;
-
-	mutex_lock(&iommu_info->iommu_mutex);
-	drm_info = session_info->iommu_info->private;
-
-	if (drm_buffer->cpu_addr) {
-		vpu_drm_sgt_unmap_kernel(drm_buffer);
-		drm_buffer->cpu_addr = NULL;
-	}
-
-	vpu_dma_unmap_sg(drm_info->domain, drm_buffer->iova);
-	if (drm_buffer->flags & VPU_DRM_BUFFER_ALLOC) {
-		table = drm_buffer->copy_sgt;
-		for_each_sg(table->sgl, sg, table->nents, i) {
-			page = sg_page(sg);
-			__free_pages(page, compound_order(page));
-		}
-	}
-	sg_free_table(drm_buffer->copy_sgt);
-	kfree(drm_buffer->copy_sgt);
-
-	if (drm_buffer->attach) {
-		dma_buf_unmap_attachment(drm_buffer->attach, drm_buffer->sgt,
-					 DMA_BIDIRECTIONAL);
-		dma_buf_detach(drm_buffer->dma_buf, drm_buffer->attach);
-		dma_buf_put(drm_buffer->dma_buf);
-		drm_buffer->attach = NULL;
-	}
-
-	mutex_unlock(&iommu_info->iommu_mutex);
-}
-
-static void vcdoec_drm_dump_info(struct vpu_iommu_session_info *session_info)
-{
-	struct vpu_drm_buffer *drm_buffer = NULL, *n;
-
-	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
-			"still there are below buffers stored in list\n");
-	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
-				 list) {
-		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_OPS_DUMP,
-				"index %d drm_buffer dma_buf %p cpu_addr %p\n",
-				drm_buffer->index,
-				drm_buffer->dma_buf, drm_buffer->cpu_addr);
-	}
-}
-
-static int vpu_drm_free(struct vpu_iommu_session_info *session_info,
-			int idx)
-{
-	struct device *dev = session_info->dev;
-	/* please double-check all maps have been release */
-	struct vpu_drm_buffer *drm_buffer;
-
-	mutex_lock(&session_info->list_mutex);
-	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
-
-	if (!drm_buffer) {
-		dev_err(dev, "can not find %d buffer in list\n", idx);
-		mutex_unlock(&session_info->list_mutex);
-
-		return -EINVAL;
-	}
-
-	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
-		if (drm_buffer->dma_buf)
-			dma_buf_put(drm_buffer->dma_buf);
-		list_del_init(&drm_buffer->list);
-		kfree(drm_buffer);
-		session_info->buffer_nums--;
-		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
-				"buffer nums %d\n", session_info->buffer_nums);
-	}
-	mutex_unlock(&session_info->list_mutex);
-
-	return 0;
-}
-
-static int
-vpu_drm_unmap_iommu(struct vpu_iommu_session_info *session_info,
-		    int idx)
-{
-	struct device *dev = session_info->dev;
-	struct vpu_drm_buffer *drm_buffer;
-
-	/* Force to flush iommu table */
-	if (of_machine_is_compatible("rockchip,rk3288"))
-		rockchip_iovmm_invalidate_tlb(session_info->mmu_dev);
-
-	mutex_lock(&session_info->list_mutex);
-	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!drm_buffer) {
-		dev_err(dev, "can not find %d buffer in list\n", idx);
-		return -EINVAL;
-	}
-
-	kref_put(&drm_buffer->ref, vpu_drm_clear_map);
-
-	return 0;
-}
-
-static int vpu_drm_map_iommu(struct vpu_iommu_session_info *session_info,
-			     int idx,
-			     unsigned long *iova,
-			     unsigned long *size)
-{
-	struct device *dev = session_info->dev;
-	struct vpu_drm_buffer *drm_buffer;
-
-	/* Force to flush iommu table */
-	if (of_machine_is_compatible("rockchip,rk3288"))
-		rockchip_iovmm_invalidate_tlb(session_info->mmu_dev);
-
-	mutex_lock(&session_info->list_mutex);
-	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!drm_buffer) {
-		dev_err(dev, "can not find %d buffer in list\n", idx);
-		return -EINVAL;
-	}
-
-	kref_get(&drm_buffer->ref);
-	if (iova)
-		*iova = drm_buffer->iova;
-	if (size)
-		*size = drm_buffer->size;
-	return 0;
-}
-
-static int
-vpu_drm_unmap_kernel(struct vpu_iommu_session_info *session_info, int idx)
-{
-	struct device *dev = session_info->dev;
-	struct vpu_drm_buffer *drm_buffer;
-
-	mutex_lock(&session_info->list_mutex);
-	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!drm_buffer) {
-		dev_err(dev, "can not find %d buffer in list\n", idx);
-
-		return -EINVAL;
-	}
-
-	if (drm_buffer->cpu_addr) {
-		vpu_drm_sgt_unmap_kernel(drm_buffer);
-		drm_buffer->cpu_addr = NULL;
-	}
-
-	kref_put(&drm_buffer->ref, vpu_drm_clear_map);
-	return 0;
-}
-
-static int
-vpu_drm_free_fd(struct vpu_iommu_session_info *session_info, int fd)
-{
-	struct device *dev = session_info->dev;
-	/* please double-check all maps have been release */
-	struct vpu_drm_buffer *drm_buffer = NULL;
-
-	mutex_lock(&session_info->list_mutex);
-	drm_buffer = vpu_drm_get_buffer_fd_no_lock(session_info, fd);
-
-	if (!drm_buffer) {
-		dev_err(dev, "can not find %d buffer in list\n", fd);
-		mutex_unlock(&session_info->list_mutex);
-
-		return -EINVAL;
-	}
-	mutex_unlock(&session_info->list_mutex);
-
-	vpu_drm_unmap_iommu(session_info, drm_buffer->index);
-
-	mutex_lock(&session_info->list_mutex);
-	if (atomic_read(&drm_buffer->ref.refcount) == 0) {
-		if (drm_buffer->dma_buf)
-			dma_buf_put(drm_buffer->dma_buf);
-		list_del_init(&drm_buffer->list);
-		kfree(drm_buffer);
-		session_info->buffer_nums--;
-		vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
-				"buffer nums %d\n", session_info->buffer_nums);
-	}
-	mutex_unlock(&session_info->list_mutex);
-
-	return 0;
-}
-
-static void
-vpu_drm_clear_session(struct vpu_iommu_session_info *session_info)
-{
-	struct vpu_drm_buffer *drm_buffer = NULL, *n;
-
-	list_for_each_entry_safe(drm_buffer, n, &session_info->buffer_list,
-				 list) {
-		kref_put(&drm_buffer->ref, vpu_drm_clear_map);
-		vpu_drm_free(session_info, drm_buffer->index);
-	}
-}
-
-static void*
-vpu_drm_map_kernel(struct vpu_iommu_session_info *session_info, int idx)
-{
-	struct device *dev = session_info->dev;
-	struct vpu_drm_buffer *drm_buffer;
-
-	mutex_lock(&session_info->list_mutex);
-	drm_buffer = vpu_drm_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!drm_buffer) {
-		dev_err(dev, "can not find %d buffer in list\n", idx);
-		return NULL;
-	}
-
-	if (!drm_buffer->cpu_addr)
-		drm_buffer->cpu_addr =
-				       vpu_drm_sgt_map_kernel(drm_buffer);
-
-	kref_get(&drm_buffer->ref);
-
-	return drm_buffer->cpu_addr;
-}
-
-static void vpu_drm_remove_extra_buffer_no_lock(struct vpu_iommu_session_info *session_info)
-{
-	struct vpu_drm_buffer *oldest_buffer = NULL, *loop_buffer = NULL;
-	struct vpu_drm_buffer *n;
-	ktime_t oldest_time = ktime_set(0, 0);
-
-	if (session_info->buffer_nums > BUFFER_LIST_MAX_NUMS) {
-		list_for_each_entry_safe(loop_buffer, n,
-					 &session_info->buffer_list, list) {
-			if (loop_buffer->flags & VPU_DRM_BUFFER_ALLOC)
-				continue;
-
-			if (ktime_to_ns(oldest_time) == 0 ||
-			    ktime_after(oldest_time,
-					loop_buffer->last_used)) {
-				oldest_time = loop_buffer->last_used;
-				oldest_buffer = loop_buffer;
-			}
-		}
-		kref_put(&oldest_buffer->ref, vpu_drm_clear_map);
-		dma_buf_put(oldest_buffer->dma_buf);
-		list_del_init(&oldest_buffer->list);
-		kfree(oldest_buffer);
-		session_info->buffer_nums--;
-	}
-}
-
-static int vpu_drm_import(struct vpu_iommu_session_info *session_info,
-			  int fd)
-{
-	struct vpu_drm_buffer *drm_buffer = NULL, *n;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
-	struct device *dev = session_info->dev;
-	struct dma_buf_attachment *attach;
-	struct sg_table *sgt;
-	struct dma_buf *dma_buf;
-	struct scatterlist *sg, *s;
-	int i;
-	int ret = 0;
-
-	dma_buf = dma_buf_get(fd);
-	if (IS_ERR(dma_buf)) {
-		ret = PTR_ERR(dma_buf);
-		return ret;
-	}
-
-	list_for_each_entry_safe(drm_buffer, n,
-				 &session_info->buffer_list, list) {
-		if (drm_buffer->dma_buf == dma_buf) {
-			dma_buf_put(dma_buf);
-			drm_buffer->last_used = ktime_get();
-			return drm_buffer->index;
-		}
-	}
-
-	drm_buffer = kzalloc(sizeof(*drm_buffer), GFP_KERNEL);
-	if (!drm_buffer) {
-		ret = -ENOMEM;
-		return ret;
-	}
-
-	drm_buffer->dma_buf = dma_buf;
-	drm_buffer->session_info = session_info;
-	drm_buffer->last_used = ktime_get();
-
-	kref_init(&drm_buffer->ref);
-
-	mutex_lock(&iommu_info->iommu_mutex);
-	drm_info = session_info->iommu_info->private;
-
-	attach = dma_buf_attach(drm_buffer->dma_buf, dev);
-	if (IS_ERR(attach)) {
-		ret = PTR_ERR(attach);
-		goto fail_out;
-	}
-
-	get_dma_buf(drm_buffer->dma_buf);
-
-	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
-	if (IS_ERR(sgt)) {
-		ret = PTR_ERR(sgt);
-		goto fail_detach;
-	}
-
-	/*
-	 * Since we call dma_buf_map_attachment outside attach/detach, this
-	 * will cause incorrectly map. we have to re-build map table native
-	 * and for avoiding destroy their origin map table, we need use a
-	 * copy one sg_table.
-	 */
-	drm_buffer->copy_sgt = kmalloc(sizeof(*drm_buffer->copy_sgt),
-				       GFP_KERNEL);
-	if (!drm_buffer->copy_sgt) {
-		ret = -ENOMEM;
-		goto fail_detach;
-	}
-
-	ret = sg_alloc_table(drm_buffer->copy_sgt, sgt->nents, GFP_KERNEL);
-	s = drm_buffer->copy_sgt->sgl;
-	for_each_sg(sgt->sgl, sg, sgt->nents, i) {
-		sg_set_page(s, sg_page(sg),
-			    PAGE_SIZE << compound_order(sg_page(sg)), 0);
-		sg_dma_address(s) = page_to_phys(sg_page(sg));
-		s->offset = sg->offset;
-		s->length = sg->length;
-		s = sg_next(s);
-	}
-
-	vpu_dma_map_sg(drm_info->domain, drm_buffer->copy_sgt->sgl,
-		       drm_buffer->copy_sgt->nents,
-		       IOMMU_READ | IOMMU_WRITE);
-	drm_buffer->iova = sg_dma_address(drm_buffer->copy_sgt->sgl);
-	drm_buffer->size = drm_buffer->dma_buf->size;
-
-	drm_buffer->attach = attach;
-	drm_buffer->sgt = sgt;
-
-	mutex_unlock(&iommu_info->iommu_mutex);
-
-	INIT_LIST_HEAD(&drm_buffer->list);
-	mutex_lock(&session_info->list_mutex);
-	session_info->buffer_nums++;
-	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
-			"buffer nums %d\n", session_info->buffer_nums);
-	vpu_drm_remove_extra_buffer_no_lock(session_info);
-	drm_buffer->index = session_info->max_idx;
-	list_add_tail(&drm_buffer->list, &session_info->buffer_list);
-	session_info->max_idx++;
-	if ((session_info->max_idx & 0xfffffff) == 0)
-		session_info->max_idx = 0;
-	mutex_unlock(&session_info->list_mutex);
-
-	return drm_buffer->index;
-
-fail_detach:
-	dev_err(dev, "dmabuf map attach failed\n");
-	dma_buf_detach(drm_buffer->dma_buf, attach);
-	dma_buf_put(drm_buffer->dma_buf);
-fail_out:
-	kfree(drm_buffer);
-	mutex_unlock(&iommu_info->iommu_mutex);
-
-	return ret;
-}
-
-static int vpu_drm_alloc(struct vpu_iommu_session_info *session_info,
-			 unsigned long size,
-			 unsigned long align)
-{
-	struct sg_table *table;
-	struct scatterlist *sg;
-	struct list_head pages;
-	struct page *page, *tmp_page;
-	long size_remaining = PAGE_ALIGN(size);
-	struct vpu_drm_buffer *drm_buffer;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
-	int i;
-
-	if (align > PAGE_SIZE)
-		return -EINVAL;
-
-	if (size / PAGE_SIZE > totalram_pages / 2)
-		return -ENOMEM;
-
-	drm_buffer = kzalloc(sizeof(*drm_buffer), GFP_KERNEL);
-	if (!drm_buffer)
-		return -ENOMEM;
-
-	drm_buffer->session_info = session_info;
-	drm_buffer->last_used = ktime_set(0, 0);
-
-	kref_init(&drm_buffer->ref);
-
-	INIT_LIST_HEAD(&pages);
-
-	i = 0;
-	while (size_remaining > 0) {
-		gfp_t gfp_flags = (GFP_HIGHUSER | __GFP_ZERO | __GFP_NOWARN |
-				   __GFP_NORETRY) & ~__GFP_DIRECT_RECLAIM;
-		page = alloc_pages(gfp_flags | __GFP_COMP, 8);
-		if (!page)
-			goto free_pages;
-
-		size_remaining -= PAGE_SIZE << compound_order(page);
-		list_add_tail(&page->lru, &pages);
-		i++;
-	}
-
-	table = kmalloc(sizeof(*table), GFP_KERNEL);
-	if (!table)
-		goto free_pages;
-
-	if (sg_alloc_table(table, i, GFP_KERNEL))
-		goto free_table;
-
-	sg = table->sgl;
-	list_for_each_entry_safe(page, tmp_page, &pages, lru) {
-		sg_set_page(sg, page, PAGE_SIZE << compound_order(page), 0);
-		sg = sg_next(sg);
-		list_del(&page->lru);
-	}
-
-	mutex_lock(&iommu_info->iommu_mutex);
-	drm_info = session_info->iommu_info->private;
-	drm_buffer->copy_sgt = table;
-
-	vpu_dma_map_sg(drm_info->domain, drm_buffer->copy_sgt->sgl,
-		       drm_buffer->copy_sgt->nents,
-		       IOMMU_READ | IOMMU_WRITE);
-	drm_buffer->iova = sg_dma_address(drm_buffer->copy_sgt->sgl);
-	drm_buffer->size = size;
-	drm_buffer->flags = VPU_DRM_BUFFER_ALLOC;
-
-	mutex_unlock(&iommu_info->iommu_mutex);
-
-	INIT_LIST_HEAD(&drm_buffer->list);
-	mutex_lock(&session_info->list_mutex);
-	session_info->buffer_nums++;
-	vpu_iommu_debug(session_info->debug_level, DEBUG_IOMMU_NORMAL,
-			"buffer nums %d\n", session_info->buffer_nums);
-	vpu_drm_remove_extra_buffer_no_lock(session_info);
-	drm_buffer->index = session_info->max_idx;
-	list_add_tail(&drm_buffer->list, &session_info->buffer_list);
-	session_info->max_idx++;
-	if ((session_info->max_idx & 0xfffffff) == 0)
-		session_info->max_idx = 0;
-	mutex_unlock(&session_info->list_mutex);
-
-	return drm_buffer->index;
-
-free_table:
-	kfree(table);
-free_pages:
-	list_for_each_entry_safe(page, tmp_page, &pages, lru)
-	__free_pages(page, 8);
-
-	kfree(drm_buffer);
-
-	return -ENOMEM;
-}
-
-static int vpu_drm_create(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_drm_info *drm_info;
-	struct iommu_group *group;
-	int ret;
-
-	iommu_info->private = kzalloc(sizeof(*drm_info),
-				      GFP_KERNEL);
-	drm_info = iommu_info->private;
-	if (!drm_info)
-		return -ENOMEM;
-
-	drm_info->domain = iommu_domain_alloc(&platform_bus_type);
-	drm_info->attached = false;
-	if (!drm_info->domain)
-		return -ENOMEM;
-
-	ret = iommu_get_dma_cookie(drm_info->domain);
-	if (ret)
-		goto err_free_domain;
-
-	group = iommu_group_get(iommu_info->dev);
-	if (!group) {
-		group = iommu_group_alloc();
-		if (IS_ERR(group)) {
-			dev_err(iommu_info->dev,
-				"Failed to allocate IOMMU group\n");
-			goto err_put_cookie;
-		}
-		ret = iommu_group_add_device(group, iommu_info->dev);
-		if (ret) {
-			dev_err(iommu_info->dev,
-				"failed to add device to IOMMU group\n");
-			goto err_put_cookie;
-		}
-	}
-	iommu_dma_init_domain(drm_info->domain, 0x10000000, SZ_2G);
-	iommu_group_put(group);
-
-	return 0;
-
-err_put_cookie:
-	iommu_put_dma_cookie(drm_info->domain);
-err_free_domain:
-	iommu_domain_free(drm_info->domain);
-
-	return ret;
-}
-
-static int vpu_drm_destroy(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_drm_info *drm_info = iommu_info->private;
-
-	iommu_put_dma_cookie(drm_info->domain);
-	iommu_domain_free(drm_info->domain);
-
-	kfree(drm_info);
-	iommu_info->private = NULL;
-
-	return 0;
-}
-
-static struct vpu_iommu_ops drm_ops = {
-	.create = vpu_drm_create,
-	.alloc = vpu_drm_alloc,
-	.import = vpu_drm_import,
-	.free = vpu_drm_free,
-	.free_fd = vpu_drm_free_fd,
-	.map_kernel = vpu_drm_map_kernel,
-	.unmap_kernel = vpu_drm_unmap_kernel,
-	.map_iommu = vpu_drm_map_iommu,
-	.unmap_iommu = vpu_drm_unmap_iommu,
-	.destroy = vpu_drm_destroy,
-	.dump = vcdoec_drm_dump_info,
-	.attach = vpu_drm_attach,
-	.detach = vpu_drm_detach,
-	.clear = vpu_drm_clear_session,
-};
-
-void vpu_iommu_drm_set_ops(struct vpu_iommu_info *iommu_info)
-{
-	if (!iommu_info)
-		return;
-	iommu_info->ops = &drm_ops;
-}
diff --git a/drivers/video/rockchip/vpu/vpu_iommu_ion.c b/drivers/video/rockchip/vpu/vpu_iommu_ion.c
deleted file mode 100644
index 06d7c2c27016..000000000000
--- a/drivers/video/rockchip/vpu/vpu_iommu_ion.c
+++ /dev/null
@@ -1,410 +0,0 @@
-/*
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: Jung Zhao jung.zhao@rock-chips.com
- *         Randy Li, randy.li@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include "vpu_iommu_ops.h"
-
-#if defined(CONFIG_ION_ROCKCHIP)
-#include <linux/rockchip_ion.h>
-#include <linux/rockchip-iovmm.h>
-#include <linux/slab.h>
-#include <linux/pm_runtime.h>
-#include <linux/memblock.h>
-#include <linux/module.h>
-#include <linux/of_address.h>
-#include <linux/of_graph.h>
-#include <linux/component.h>
-#include <linux/fence.h>
-#include <linux/console.h>
-#include <linux/kref.h>
-#include <linux/fdtable.h>
-
-struct vpu_ion_buffer {
-	struct list_head list;
-	struct ion_handle *handle;
-	int index;
-};
-
-struct vpu_iommu_ion_info {
-	struct ion_client *ion_client;
-	bool attached;
-};
-
-static struct vpu_ion_buffer*
-vpu_ion_get_buffer_no_lock(struct vpu_iommu_session_info *session_info,
-			   int idx)
-{
-	struct vpu_ion_buffer *ion_buffer = NULL, *n;
-
-	list_for_each_entry_safe(ion_buffer, n,
-				 &session_info->buffer_list, list) {
-		if (ion_buffer->index == idx)
-			return ion_buffer;
-	}
-
-	return NULL;
-}
-
-static void
-vpu_ion_clear_session(struct vpu_iommu_session_info *session_info)
-{
-	/* do nothing */
-}
-
-static int vpu_ion_attach(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-					      int ret;
-
-	mutex_lock(&iommu_info->iommu_mutex);
-
-	if (ion_info->attached) {
-		mutex_unlock(&iommu_info->iommu_mutex);
-		return 0;
-	}
-
-	rockchip_iovmm_activate(iommu_info->dev);
-
-	ion_info->attached = true;
-
-	mutex_unlock(&iommu_info->iommu_mutex);
-
-	return ret;
-}
-
-static void vpu_ion_detach(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-
-	mutex_lock(&iommu_info->iommu_mutex);
-
-	if (!ion_info->attached) {
-		mutex_unlock(&iommu_info->iommu_mutex);
-		return;
-	}
-
-	rockchip_iovmm_deactivate(iommu_info->dev);
-	ion_info->attached = false;
-
-	mutex_unlock(&iommu_info->iommu_mutex);
-}
-
-static int vpu_ion_destroy(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-
-	vpu_ion_detach(iommu_info);
-	kfree(ion_info);
-	iommu_info->private = NULL;
-
-	return 0;
-}
-
-static int
-vpu_ion_free(struct vpu_iommu_session_info *session_info, int idx)
-{
-	struct vpu_ion_buffer *ion_buffer;
-
-	mutex_lock(&session_info->list_mutex);
-	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
-
-	if (!ion_buffer) {
-		mutex_unlock(&session_info->list_mutex);
-		pr_err("%s can not find %d buffer in list\n", __func__, idx);
-
-		return -EINVAL;
-	}
-
-	list_del_init(&ion_buffer->list);
-	mutex_unlock(&session_info->list_mutex);
-	kfree(ion_buffer);
-
-	return 0;
-}
-
-static int
-vpu_ion_unmap_iommu(struct vpu_iommu_session_info *session_info, int idx)
-{
-	struct vpu_ion_buffer *ion_buffer;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-
-	mutex_lock(&session_info->list_mutex);
-	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!ion_buffer) {
-		pr_err("%s can not find %d buffer in list\n", __func__, idx);
-
-		return -EINVAL;
-	}
-
-	ion_free(ion_info->ion_client, ion_buffer->handle);
-
-	return 0;
-}
-
-static int
-vpu_ion_map_iommu(struct vpu_iommu_session_info *session_info, int idx,
-		  unsigned long *iova, unsigned long *size)
-{
-	struct vpu_ion_buffer *ion_buffer;
-	struct device *dev = session_info->dev;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-					      int ret = 0;
-
-	/* Force to flush iommu table */
-	rockchip_iovmm_invalidate_tlb(session_info->dev);
-
-	mutex_lock(&session_info->list_mutex);
-	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!ion_buffer) {
-		pr_err("%s can not find %d buffer in list\n", __func__, idx);
-
-		return -EINVAL;
-	}
-
-	if (session_info->mmu_dev)
-		ret = ion_map_iommu(dev, ion_info->ion_client,
-				    ion_buffer->handle, iova, size);
-	else
-		ret = ion_phys(ion_info->ion_client, ion_buffer->handle,
-			       iova, (size_t *)size);
-
-	return ret;
-}
-
-static int
-vpu_ion_unmap_kernel(struct vpu_iommu_session_info *session_info,
-		     int idx)
-{
-	struct vpu_ion_buffer *ion_buffer;
-
-	mutex_lock(&session_info->list_mutex);
-	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!ion_buffer) {
-		pr_err("%s can not find %d buffer in list\n", __func__, idx);
-
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static void*
-vpu_ion_map_kernel(struct vpu_iommu_session_info *session_info, int idx)
-{
-	struct vpu_ion_buffer *ion_buffer;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-
-	rockchip_iovmm_invalidate_tlb(session_info->dev);
-
-	mutex_lock(&session_info->list_mutex);
-	ion_buffer = vpu_ion_get_buffer_no_lock(session_info, idx);
-	mutex_unlock(&session_info->list_mutex);
-
-	if (!ion_buffer) {
-		pr_err("%s can not find %d buffer in list\n", __func__, idx);
-
-		return NULL;
-	}
-
-	return ion_map_kernel(ion_info->ion_client, ion_buffer->handle);
-}
-
-static int vpu_ion_alloc(struct vpu_iommu_session_info *session_info,
-			 unsigned long size,
-			 unsigned long align)
-{
-	struct vpu_ion_buffer *ion_buffer = NULL;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-	unsigned int heap_id_mask;
-
-	if (iommu_info->mmu_dev)
-		heap_id_mask = ION_HEAP_TYPE_SYSTEM;
-	else
-		heap_id_mask = ION_HEAP_TYPE_DMA;
-
-	ion_buffer = kzalloc(sizeof(*ion_buffer), GFP_KERNEL);
-	if (!ion_buffer)
-		return -ENOMEM;
-
-	ion_buffer->handle = ion_alloc(ion_info->ion_client, size,
-				       align, heap_id_mask, 0);
-
-	INIT_LIST_HEAD(&ion_buffer->list);
-	mutex_lock(&session_info->list_mutex);
-	ion_buffer->index = session_info->max_idx;
-	list_add_tail(&ion_buffer->list, &session_info->buffer_list);
-	session_info->max_idx++;
-	if ((session_info->max_idx & 0xfffffff) == 0)
-		session_info->max_idx = 0;
-	mutex_unlock(&session_info->list_mutex);
-
-	return ion_buffer->index;
-}
-
-static int
-vpu_ion_import(struct vpu_iommu_session_info *session_info, int fd)
-{
-	struct vpu_ion_buffer *ion_buffer = NULL;
-	struct vpu_iommu_info *iommu_info = session_info->iommu_info;
-	struct vpu_iommu_ion_info *ion_info = iommu_info->private;
-
-	ion_buffer = kzalloc(sizeof(*ion_buffer), GFP_KERNEL);
-	if (!ion_buffer)
-		return -ENOMEM;
-
-	ion_buffer->handle = ion_import_dma_buf(ion_info->ion_client, fd);
-
-	INIT_LIST_HEAD(&ion_buffer->list);
-	mutex_lock(&session_info->list_mutex);
-	ion_buffer->index = session_info->max_idx;
-	list_add_tail(&ion_buffer->list, &session_info->buffer_list);
-	session_info->max_idx++;
-	if ((session_info->max_idx & 0xfffffff) == 0)
-		session_info->max_idx = 0;
-	mutex_unlock(&session_info->list_mutex);
-
-	return ion_buffer->index;
-}
-
-static int vpu_ion_create(struct vpu_iommu_info *iommu_info)
-{
-	struct vpu_iommu_ion_info *ion_info;
-
-	iommu_info->private = kmalloc(sizeof(*ion_info), GFP_KERNEL);
-
-	ion_info = iommu_info->private;
-	if (!ion_info)
-		return -ENOMEM;
-
-	ion_info->ion_client = rockchip_ion_client_create("vpu");
-	ion_info->attached = false;
-
-	vpu_ion_attach(iommu_info);
-
-	return IS_ERR(ion_info->ion_client) ? -1 : 0;
-}
-
-#else
-
-static void
-vpu_ion_clear_session(struct vpu_iommu_session_info *session_info)
-{
-	/* do nothing */
-}
-
-static int vpu_ion_attach(struct vpu_iommu_info *iommu_info)
-{
-	return 0;
-}
-
-static void vpu_ion_detach(struct vpu_iommu_info *iommu_info)
-{
-}
-
-static int vpu_ion_destroy(struct vpu_iommu_info *iommu_info)
-{
-	return 0;
-}
-
-static int
-vpu_ion_free(struct vpu_iommu_session_info *session_info, int idx)
-{
-	return 0;
-}
-
-static int
-vpu_ion_unmap_iommu(struct vpu_iommu_session_info *session_info, int idx)
-{
-	return 0;
-}
-
-static int
-vpu_ion_map_iommu(struct vpu_iommu_session_info *session_info, int idx,
-		  unsigned long *iova, unsigned long *size)
-{
-	return 0;
-}
-
-static int
-vpu_ion_unmap_kernel(struct vpu_iommu_session_info *session_info,
-		     int idx)
-{
-	return 0;
-}
-
-static void*
-vpu_ion_map_kernel(struct vpu_iommu_session_info *session_info, int idx)
-{
-	return NULL;
-}
-
-static int vpu_ion_alloc(struct vpu_iommu_session_info *session_info,
-			 unsigned long size,
-			 unsigned long align)
-{
-	return 0;
-}
-
-static int
-vpu_ion_import(struct vpu_iommu_session_info *session_info, int fd)
-{
-	return 0;
-}
-
-static int vpu_ion_create(struct vpu_iommu_info *iommu_info)
-{
-	return -1;
-}
-#endif
-
-static struct vpu_iommu_ops ion_ops = {
-	.create = vpu_ion_create,
-	.destroy = vpu_ion_destroy,
-	.alloc = vpu_ion_alloc,
-	.import = vpu_ion_import,
-	.free = vpu_ion_free,
-	.free_fd = NULL,
-	.map_kernel = vpu_ion_map_kernel,
-	.unmap_kernel = vpu_ion_unmap_kernel,
-	.map_iommu = vpu_ion_map_iommu,
-	.unmap_iommu = vpu_ion_unmap_iommu,
-	.dump = NULL,
-	.attach = vpu_ion_attach,
-	.detach = vpu_ion_detach,
-	.clear = vpu_ion_clear_session,
-};
-
-/*
- * we do not manage the ref number ourselves,
- * since ion will help us to do that. what we
- * need to do is just map/unmap and import/free
- * every time
- */
-void vpu_iommu_ion_set_ops(struct vpu_iommu_info *iommu_info)
-{
-	if (!iommu_info)
-		return;
-	iommu_info->ops = &ion_ops;
-}
diff --git a/drivers/video/rockchip/vpu/vpu_iommu_ops.c b/drivers/video/rockchip/vpu/vpu_iommu_ops.c
deleted file mode 100644
index 369358c14245..000000000000
--- a/drivers/video/rockchip/vpu/vpu_iommu_ops.c
+++ /dev/null
@@ -1,291 +0,0 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: Jung Zhao jung.zhao@rock-chips.com
- *         Randy Li, randy.li@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/slab.h>
-
-#include "vpu_iommu_ops.h"
-
-static
-struct vpu_iommu_session_info *vpu_iommu_get_session_info(struct vpu_iommu_info *iommu_info,
-							  struct mpp_session *session)
-{
-	struct vpu_iommu_session_info *session_info = NULL, *n;
-
-	list_for_each_entry_safe(session_info, n, &iommu_info->session_list,
-				 head) {
-		if (session_info->session == session)
-			return session_info;
-	}
-
-	return NULL;
-}
-
-int vpu_iommu_create(struct vpu_iommu_info *iommu_info)
-{
-	if (!iommu_info || !iommu_info->ops->create)
-		return -EINVAL;
-
-	return iommu_info->ops->create(iommu_info);
-}
-
-int vpu_iommu_alloc(struct vpu_iommu_info *iommu_info,
-		    struct mpp_session *session,
-		    unsigned long size,
-		    unsigned long align)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	if (!iommu_info || !iommu_info->ops->alloc || !session)
-		return -EINVAL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-	if (!session_info) {
-		session_info = kzalloc(sizeof(*session_info), GFP_KERNEL);
-		if (!session_info)
-			return -ENOMEM;
-
-		INIT_LIST_HEAD(&session_info->head);
-		INIT_LIST_HEAD(&session_info->buffer_list);
-		mutex_init(&session_info->list_mutex);
-		session_info->max_idx = 0;
-		session_info->session = session;
-		session_info->mmu_dev = iommu_info->mmu_dev;
-		session_info->dev = iommu_info->dev;
-		session_info->iommu_info = iommu_info;
-		session_info->buffer_nums = 0;
-		mutex_lock(&iommu_info->list_mutex);
-		list_add_tail(&session_info->head, &iommu_info->session_list);
-		mutex_unlock(&iommu_info->list_mutex);
-	}
-
-	session_info->debug_level = iommu_info->debug_level;
-
-	return iommu_info->ops->alloc(session_info, size, align);
-}
-
-int vpu_iommu_import(struct vpu_iommu_info *iommu_info,
-		     struct mpp_session *session, int fd)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	if (!iommu_info || !iommu_info->ops->import || !session)
-		return -EINVAL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-	if (!session_info) {
-		session_info = kzalloc(sizeof(*session_info), GFP_KERNEL);
-		if (!session_info)
-			return -ENOMEM;
-
-		INIT_LIST_HEAD(&session_info->head);
-		INIT_LIST_HEAD(&session_info->buffer_list);
-		mutex_init(&session_info->list_mutex);
-		session_info->max_idx = 0;
-		session_info->session = session;
-		session_info->mmu_dev = iommu_info->mmu_dev;
-		session_info->dev = iommu_info->dev;
-		session_info->iommu_info = iommu_info;
-		session_info->buffer_nums = 0;
-		mutex_lock(&iommu_info->list_mutex);
-		list_add_tail(&session_info->head, &iommu_info->session_list);
-		mutex_unlock(&iommu_info->list_mutex);
-	}
-
-	session_info->debug_level = iommu_info->debug_level;
-
-	return iommu_info->ops->import(session_info, fd);
-}
-
-int vpu_iommu_free(struct vpu_iommu_info *iommu_info,
-		   struct mpp_session *session, int idx)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->free || !session_info)
-		return -EINVAL;
-
-	return iommu_info->ops->free(session_info, idx);
-}
-
-int vpu_iommu_free_fd(struct vpu_iommu_info *iommu_info,
-		      struct mpp_session *session, int fd)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->free_fd || !session_info)
-		return -EINVAL;
-
-	return iommu_info->ops->free_fd(session_info, fd);
-}
-
-void *vpu_iommu_map_kernel(struct vpu_iommu_info *iommu_info,
-			   struct mpp_session *session, int idx)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->map_kernel || !session_info)
-		return NULL;
-
-	return iommu_info->ops->map_kernel(session_info, idx);
-}
-
-int vpu_iommu_unmap_kernel(struct vpu_iommu_info *iommu_info,
-			   struct mpp_session *session, int idx)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->unmap_kernel || !session_info)
-		return -EINVAL;
-
-	return iommu_info->ops->unmap_kernel(session_info, idx);
-}
-
-int vpu_iommu_map_iommu(struct vpu_iommu_info *iommu_info,
-			struct mpp_session *session,
-			int idx, unsigned long *iova,
-			unsigned long *size)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->map_iommu || !session_info)
-		return -EINVAL;
-
-	return iommu_info->ops->map_iommu(session_info, idx, iova, size);
-}
-
-int vpu_iommu_unmap_iommu(struct vpu_iommu_info *iommu_info,
-			  struct mpp_session *session, int idx)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->unmap_iommu || !session_info)
-		return -EINVAL;
-
-	return iommu_info->ops->unmap_iommu(session_info, idx);
-}
-
-int vpu_iommu_destroy(struct vpu_iommu_info *iommu_info)
-{
-	if (!iommu_info || !iommu_info->ops->destroy)
-		return -EINVAL;
-
-	return iommu_info->ops->destroy(iommu_info);
-}
-
-void vpu_iommu_dump(struct vpu_iommu_info *iommu_info,
-		    struct mpp_session *session)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->dump || !session_info)
-		return;
-
-	iommu_info->ops->dump(session_info);
-}
-
-void vpu_iommu_clear(struct vpu_iommu_info *iommu_info,
-		     struct mpp_session *session)
-{
-	struct vpu_iommu_session_info *session_info = NULL;
-
-	session_info = vpu_iommu_get_session_info(iommu_info, session);
-
-	if (!iommu_info || !iommu_info->ops->clear || !session_info)
-		return;
-
-	iommu_info->ops->clear(session_info);
-
-	mutex_lock(&iommu_info->list_mutex);
-	list_del_init(&session_info->head);
-	kfree(session_info);
-	mutex_unlock(&iommu_info->list_mutex);
-}
-
-int vpu_iommu_attach(struct vpu_iommu_info *iommu_info)
-{
-	if (!iommu_info || !iommu_info->ops->attach)
-		return 0;
-
-	return iommu_info->ops->attach(iommu_info);
-}
-
-void vpu_iommu_detach(struct vpu_iommu_info *iommu_info)
-{
-	if (!iommu_info || !iommu_info->ops->detach)
-		return;
-
-	return iommu_info->ops->detach(iommu_info);
-}
-
-struct vpu_iommu_info*
-vpu_iommu_info_create(struct device *dev,
-		      struct device *mmu_dev,
-		      int alloc_type)
-{
-	struct vpu_iommu_info *iommu_info = NULL;
-
-	iommu_info = kzalloc(sizeof(*iommu_info), GFP_KERNEL);
-	if (!iommu_info)
-		return NULL;
-
-	iommu_info->dev = dev;
-	INIT_LIST_HEAD(&iommu_info->session_list);
-	mutex_init(&iommu_info->list_mutex);
-	mutex_init(&iommu_info->iommu_mutex);
-	switch (alloc_type) {
-#ifdef CONFIG_DRM
-	case ALLOCATOR_USE_DRM:
-		vpu_iommu_drm_set_ops(iommu_info);
-		break;
-#endif
-#ifdef CONFIG_ION
-	case ALLOCATOR_USE_ION:
-		vpu_iommu_ion_set_ops(iommu_info);
-		break;
-#endif
-	default:
-		iommu_info->ops = NULL;
-		break;
-	}
-
-	iommu_info->mmu_dev = mmu_dev;
-
-	vpu_iommu_create(iommu_info);
-
-	return iommu_info;
-}
-
-int vpu_iommu_info_destroy(struct vpu_iommu_info *iommu_info)
-{
-	vpu_iommu_destroy(iommu_info);
-	kfree(iommu_info);
-
-	return 0;
-}
diff --git a/drivers/video/rockchip/vpu/vpu_iommu_ops.h b/drivers/video/rockchip/vpu/vpu_iommu_ops.h
deleted file mode 100644
index 032f6c5c0c52..000000000000
--- a/drivers/video/rockchip/vpu/vpu_iommu_ops.h
+++ /dev/null
@@ -1,139 +0,0 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: Jung Zhao jung.zhao@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef __VPU_IOMMU_OPS_H__
-#define __VPU_IOMMU_OPS_H__
-
-#include <linux/platform_device.h>
-#include "mpp_service.h"
-
-#define BUFFER_LIST_MAX_NUMS	30
-
-#define ALLOCATOR_USE_ION		0x00000000
-#define ALLOCATOR_USE_DRM		0x00000001
-
-#define DEBUG_IOMMU_OPS_DUMP	0x00020000
-#define DEBUG_IOMMU_NORMAL	0x00040000
-
-#define vpu_iommu_debug_func(debug_level, type, fmt, args...)	\
-	do {							\
-		if (unlikely((debug_level) & type)) {		\
-			pr_info("%s:%d: " fmt,			\
-				 __func__, __LINE__, ##args);	\
-		}						\
-	} while (0)
-#define vpu_iommu_debug(debug_level, type, fmt, args...)	\
-	do {							\
-		if (unlikely((debug_level) & type)) {		\
-			pr_info(fmt, ##args);			\
-		}						\
-	} while (0)
-
-struct vpu_iommu_info;
-struct vpu_iommu_session_info;
-
-struct vpu_iommu_ops {
-	int (*create)(struct vpu_iommu_info *iommu_info);
-	int (*alloc)(struct vpu_iommu_session_info *session_info,
-		     unsigned long size,
-		     unsigned long align);
-	int (*import)(struct vpu_iommu_session_info *session_info, int fd);
-	int (*free)(struct vpu_iommu_session_info *session_info, int idx);
-	int (*free_fd)(struct vpu_iommu_session_info *session_info, int fd);
-	void* (*map_kernel)(struct vpu_iommu_session_info *session_info,
-			    int idx);
-	int (*unmap_kernel)(struct vpu_iommu_session_info *session_info,
-			    int idx);
-	int (*map_iommu)(struct vpu_iommu_session_info *session_info,
-			 int idx,
-			 unsigned long *iova, unsigned long *size);
-	int (*unmap_iommu)(struct vpu_iommu_session_info *session_info,
-			   int idx);
-	int (*destroy)(struct vpu_iommu_info *iommu_info);
-	void (*dump)(struct vpu_iommu_session_info *session_info);
-	int (*attach)(struct vpu_iommu_info *iommu_info);
-	void (*detach)(struct vpu_iommu_info *iommu_info);
-	void (*clear)(struct vpu_iommu_session_info *session_info);
-};
-
-struct vpu_iommu_session_info {
-	struct list_head head;
-	struct mpp_session *session;
-	int buffer_nums;
-	struct list_head buffer_list;
-	struct mutex list_mutex;
-	int max_idx;
-	struct device *dev;
-	struct device *mmu_dev;
-	struct vpu_iommu_info *iommu_info;
-	int debug_level;
-};
-
-struct vpu_iommu_info {
-	struct list_head session_list;
-	struct mutex list_mutex;
-	struct mutex iommu_mutex;
-	struct device *dev;
-	struct device *mmu_dev;
-	struct vpu_iommu_ops *ops;
-	int debug_level;
-	void *private;
-};
-
-#ifdef CONFIG_DRM
-void vpu_iommu_drm_set_ops(struct vpu_iommu_info *iommu_info);
-#endif
-#ifdef CONFIG_ION
-void vpu_iommu_ion_set_ops(struct vpu_iommu_info *iommu_info);
-#endif
-
-struct vpu_iommu_info *vpu_iommu_info_create(struct device *dev,
-					     struct device *mmu_dev,
-					     int alloc_type);
-int vpu_iommu_info_destroy(struct vpu_iommu_info *iommu_info);
-
-int vpu_iommu_create(struct vpu_iommu_info *iommu_info);
-int vpu_iommu_alloc(struct vpu_iommu_info *iommu_info,
-		    struct mpp_session *session,
-		    unsigned long size,
-		    unsigned long align);
-int vpu_iommu_import(struct vpu_iommu_info *iommu_info,
-		     struct mpp_session *session, int fd);
-int vpu_iommu_free(struct vpu_iommu_info *iommu_info,
-		   struct mpp_session *session, int idx);
-int vpu_iommu_free_fd(struct vpu_iommu_info *iommu_info,
-		      struct mpp_session *session, int fd);
-void *vpu_iommu_map_kernel(struct vpu_iommu_info *iommu_info,
-			   struct mpp_session *session, int idx);
-int vpu_iommu_unmap_kernel(struct vpu_iommu_info *iommu_info,
-			   struct mpp_session *session, int idx);
-int vpu_iommu_map_iommu(struct vpu_iommu_info *iommu_info,
-			struct mpp_session *session,
-			int idx,
-			unsigned long *iova,
-			unsigned long *size);
-int vpu_iommu_unmap_iommu(struct vpu_iommu_info *iommu_info,
-			  struct mpp_session *session,
-			  int idx);
-int vpu_iommu_destroy(struct vpu_iommu_info *iommu_info);
-void vpu_iommu_dump(struct vpu_iommu_info *iommu_info,
-		    struct mpp_session *session);
-void vpu_iommu_clear(struct vpu_iommu_info *iommu_info,
-		     struct mpp_session *session);
-
-int vpu_iommu_attach(struct vpu_iommu_info *iommu_info);
-void vpu_iommu_detach(struct vpu_iommu_info *iommu_info);
-
-#endif

From d20c05099f7574937fb0c8a78e49024789c8645b Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Wed, 18 Apr 2018 17:47:39 +0800
Subject: [PATCH] video: rockchip/mpp_service: switching in multiple sequences

--------------    ---------------    ------------------
|            |    |             |    | mpp device     |
| mpp device |<-->| mpp service |<-->|  implementation|
|    top     |    |             |    |  and buttom    |
--------------    ---------------    ------------------

The device class of the mpp service will be create at
the module loading time. But the class for the mpp device
will create at the mpp common device.

The power and clocks management have been left to the
power domain, so the combo device won't worry whether
those things are ready when the device is going to run.

It won't work for the link table mode. The steps of the lock
are fine at the most of time, but we need a way to push
a bunch of tasks to run then wait them done. I also need a way
to insert new task.

TODO:
1. Device scheduler

Change-Id: I4abae5fa054a583fbb4a49fc68726ce8405f2901
Signed-off-by: Randy Li <randy.li@rock-chips.com>
Signed-off-by: ayaka <ayaka@soulik.info>
---
 drivers/video/rockchip/vpu/mpp_service.c | 223 +++++++++++++------------------
 drivers/video/rockchip/vpu/mpp_service.h |  72 +++-------
 2 files changed, 113 insertions(+), 182 deletions(-)

diff --git a/drivers/video/rockchip/vpu/mpp_service.c b/drivers/video/rockchip/vpu/mpp_service.c
index dfbef466d9a7..1e45ce141fc4 100644
--- a/drivers/video/rockchip/vpu/mpp_service.c
+++ b/drivers/video/rockchip/vpu/mpp_service.c
@@ -1,7 +1,6 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: chenhengming chm@rock-chips.com
- *	   Alpha Lin, alpha.lin@rock-chips.com
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2016 - 2017 Fuzhou Rockchip Electronics Co., Ltd
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -16,175 +15,142 @@
 
 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
 
+#include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/of_platform.h>
+#include <linux/slab.h>
 
 #include "mpp_dev_common.h"
 #include "mpp_service.h"
 
-void mpp_srv_lock(struct mpp_service *pservice)
-{
-	mutex_lock(&pservice->lock);
-}
-EXPORT_SYMBOL(mpp_srv_lock);
+struct mpp_service {
+	/* service critical time lock */
+	struct completion running;
+	struct mpp_task *cur_task;
+
+	u32 dev_cnt;
+	struct list_head subdev_list;
+};
 
-void mpp_srv_unlock(struct mpp_service *pservice)
+struct mpp_service_node {
+	/* node structure global lock */
+	struct mutex lock;
+	struct mpp_service *parent;
+	struct list_head pending;
+};
+
+/* service queue schedule */
+void mpp_srv_push_pending(struct mpp_service_node *node, struct mpp_task *task)
 {
-	mutex_unlock(&pservice->lock);
+	mutex_lock(&node->lock);
+	list_add_tail(&task->service_link, &node->pending);
+	mutex_unlock(&node->lock);
 }
-EXPORT_SYMBOL(mpp_srv_unlock);
+EXPORT_SYMBOL(mpp_srv_push_pending);
 
-/* service queue schedule */
-void mpp_srv_pending_locked(struct mpp_service *pservice,
-			    struct mpp_ctx *ctx)
+struct mpp_task *mpp_srv_get_pending_task(struct mpp_service_node *node)
 {
-	mpp_srv_lock(pservice);
+	struct mpp_task *task = NULL;
 
-	list_add_tail(&ctx->status_link, &pservice->pending);
+	mutex_lock(&node->lock);
+	if (!list_empty(&node->pending)) {
+		task = list_first_entry(&node->pending, struct mpp_task,
+					service_link);
+		list_del_init(&task->service_link);
+	}
+	mutex_unlock(&node->lock);
 
-	mpp_srv_unlock(pservice);
+	return task;
 }
-EXPORT_SYMBOL(mpp_srv_pending_locked);
+EXPORT_SYMBOL(mpp_srv_get_pending_task);
 
-void mpp_srv_run(struct mpp_service *pservice)
+int mpp_srv_is_running(struct mpp_service_node *node)
 {
-	struct mpp_ctx *ctx = mpp_srv_get_pending_ctx(pservice);
+	struct mpp_service *pservice = node->parent;
 
-	list_del_init(&ctx->status_link);
-	list_add_tail(&ctx->status_link, &pservice->running);
+	return !try_wait_for_completion(&pservice->running);
 }
-EXPORT_SYMBOL(mpp_srv_run);
+EXPORT_SYMBOL(mpp_srv_is_running);
 
-void mpp_srv_done(struct mpp_service *pservice)
+void mpp_srv_wait_to_run(struct mpp_service_node *node, struct mpp_task *task)
 {
-	struct mpp_ctx *ctx = list_entry(pservice->running.next,
-					 struct mpp_ctx, status_link);
+	struct mpp_service *pservice = node->parent;
 
-	list_del_init(&ctx->session_link);
-	list_add_tail(&ctx->session_link, &ctx->session->done);
-
-	list_del_init(&ctx->status_link);
-	list_add_tail(&ctx->status_link, &pservice->done);
-
-	wake_up(&ctx->session->wait);
+	wait_for_completion(&pservice->running);
+	pservice->cur_task = task;
 }
-EXPORT_SYMBOL(mpp_srv_done);
+EXPORT_SYMBOL(mpp_srv_wait_to_run);
 
-struct mpp_ctx *mpp_srv_get_pending_ctx(struct mpp_service *pservice)
+struct mpp_task *mpp_srv_get_cur_task(struct mpp_service_node *node)
 {
-	return list_entry(pservice->pending.next, struct mpp_ctx, status_link);
-}
-EXPORT_SYMBOL(mpp_srv_get_pending_ctx);
+	struct mpp_service *pservice = node->parent;
 
-struct mpp_ctx *mpp_srv_get_current_ctx(struct mpp_service *pservice)
-{
-	return list_entry(pservice->running.next, struct mpp_ctx, status_link);
+	return pservice->cur_task;
 }
-EXPORT_SYMBOL(mpp_srv_get_current_ctx);
+EXPORT_SYMBOL(mpp_srv_get_cur_task);
 
-struct mpp_ctx *mpp_srv_get_last_running_ctx(struct mpp_service *pservice)
+void mpp_srv_done(struct mpp_service_node *node, struct mpp_task *task)
 {
-	return list_entry(pservice->running.prev, struct mpp_ctx, status_link);
-}
-EXPORT_SYMBOL(mpp_srv_get_last_running_ctx);
+	struct mpp_service *pservice = node->parent;
 
-struct mpp_session *mpp_srv_get_current_session(struct mpp_service *pservice)
-{
-	struct mpp_ctx *ctx = list_entry(pservice->running.next,
-					 struct mpp_ctx, status_link);
-	return ctx ? ctx->session : NULL;
+	pservice->cur_task = NULL;
+	complete(&pservice->running);
 }
-EXPORT_SYMBOL(mpp_srv_get_current_session);
+EXPORT_SYMBOL(mpp_srv_done);
 
-struct mpp_ctx *mpp_srv_get_done_ctx(struct mpp_session *session)
+int mpp_srv_abort(struct mpp_service_node *node, struct mpp_task *task)
 {
-	return list_entry(session->done.next, struct mpp_ctx, session_link);
-}
-EXPORT_SYMBOL(mpp_srv_get_done_ctx);
+	struct mpp_service *pservice = node->parent;
 
-bool mpp_srv_pending_is_empty(struct mpp_service *pservice)
-{
-	return !!list_empty(&pservice->pending);
+	if (task) {
+		if (pservice->cur_task == task)
+			pservice->cur_task = NULL;
+	}
+	complete(&pservice->running);
+
+	return 0;
 }
-EXPORT_SYMBOL(mpp_srv_pending_is_empty);
+EXPORT_SYMBOL(mpp_srv_abort);
 
-void mpp_srv_attach(struct mpp_service *pservice, struct list_head *elem)
+void *mpp_srv_attach(struct mpp_service *pservice, void *data)
 {
-	INIT_LIST_HEAD(elem);
-	list_add_tail(elem, &pservice->subdev_list);
-	pservice->dev_cnt++;
+	struct mpp_service_node *node = NULL;
+
+	node = kzalloc(sizeof(*node), GFP_KERNEL);
+	if (!node)
+		return node;
+
+	node->parent = pservice;
+	mutex_init(&node->lock);
+	INIT_LIST_HEAD(&node->pending);
+
+	return node;
 }
 EXPORT_SYMBOL(mpp_srv_attach);
 
-void mpp_srv_detach(struct mpp_service *pservice, struct list_head *elem)
+void mpp_srv_detach(struct mpp_service_node *node)
 {
-	list_del_init(elem);
-	pservice->dev_cnt--;
+	kfree(node);
 }
 EXPORT_SYMBOL(mpp_srv_detach);
 
-bool mpp_srv_is_running(struct mpp_service *pservice)
-{
-	return !list_empty(&pservice->running);
-}
-EXPORT_SYMBOL(mpp_srv_is_running);
-
 static void mpp_init_drvdata(struct mpp_service *pservice)
 {
-	INIT_LIST_HEAD(&pservice->pending);
-	mutex_init(&pservice->lock);
-
-	INIT_LIST_HEAD(&pservice->done);
-	INIT_LIST_HEAD(&pservice->session);
-	INIT_LIST_HEAD(&pservice->subdev_list);
-	INIT_LIST_HEAD(&pservice->running);
+	init_completion(&pservice->running);
+	complete(&pservice->running);
 }
 
-#if defined(CONFIG_OF)
-static const struct of_device_id mpp_service_dt_ids[] = {
-	{ .compatible = "rockchip,mpp_service", },
-	{ },
-};
-#endif
-
 static int mpp_probe(struct platform_device *pdev)
 {
-	int ret = 0;
-	struct resource *res = NULL;
 	struct device *dev = &pdev->dev;
-	struct device_node *np = pdev->dev.of_node;
-	struct mpp_service *pservice =
-				       devm_kzalloc(dev, sizeof(*pservice),
+	struct mpp_service *pservice = devm_kzalloc(dev, sizeof(*pservice),
 						    GFP_KERNEL);
-
-	dev_info(dev, "%s enter\n", __func__);
-
-	pservice->dev = dev;
+	if (!pservice)
+		return -ENOMEM;
 
 	mpp_init_drvdata(pservice);
 
-	if (of_property_read_bool(np, "reg")) {
-		res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-
-		pservice->reg_base = devm_ioremap_resource(pservice->dev, res);
-		if (IS_ERR(pservice->reg_base)) {
-			dev_err(dev, "ioremap registers base failed\n");
-			ret = PTR_ERR(pservice->reg_base);
-			pservice->reg_base = 0;
-		}
-	} else {
-		pservice->reg_base = 0;
-	}
-
-	pservice->cls = class_create(THIS_MODULE, dev_name(dev));
-
-	if (IS_ERR(pservice->cls)) {
-		ret = PTR_ERR(pservice->cls);
-		dev_err(dev, "class_create err:%d\n", ret);
-		return -1;
-	}
-
 	platform_set_drvdata(pdev, pservice);
 	dev_info(dev, "init success\n");
 
@@ -193,21 +159,20 @@ static int mpp_probe(struct platform_device *pdev)
 
 static int mpp_remove(struct platform_device *pdev)
 {
-	struct mpp_service *pservice = platform_get_drvdata(pdev);
-
-	class_destroy(pservice->cls);
 	return 0;
 }
 
+static const struct of_device_id mpp_service_dt_ids[] = {
+	{ .compatible = "rockchip,mpp-service", },
+	{ },
+};
+
 static struct platform_driver mpp_driver = {
 	.probe = mpp_probe,
 	.remove = mpp_remove,
 	.driver = {
 		.name = "mpp",
-		.owner = THIS_MODULE,
-#if defined(CONFIG_OF)
 		.of_match_table = of_match_ptr(mpp_service_dt_ids),
-#endif
 	},
 };
 
@@ -216,13 +181,17 @@ static int __init mpp_service_init(void)
 	int ret = platform_driver_register(&mpp_driver);
 
 	if (ret) {
-		mpp_err("Platform device register failed (%d).\n", ret);
+		pr_err("Platform device register failed (%d).\n", ret);
 		return ret;
 	}
 
 	return ret;
 }
 
-subsys_initcall(mpp_service_init);
-MODULE_LICENSE("GPL");
+static void __exit mpp_service_exit(void)
+{
+}
 
+module_init(mpp_service_init);
+module_exit(mpp_service_exit)
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/rockchip/vpu/mpp_service.h b/drivers/video/rockchip/vpu/mpp_service.h
index b60d6b02c8b3..a77cff7b02df 100644
--- a/drivers/video/rockchip/vpu/mpp_service.h
+++ b/drivers/video/rockchip/vpu/mpp_service.h
@@ -1,7 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- * author: chenhengming chm@rock-chips.com
- *	   Alpha Lin, alpha.lin@rock-chips.com
+ * Copyright (C) 2016 - 2017 Fuzhou Rockchip Electronics Co., Ltd
  *
  * This software is licensed under the terms of the GNU General Public
  * License version 2, as published by the Free Software Foundation, and
@@ -14,63 +13,26 @@
  *
  */
 
-#ifndef __ROCKCHIP_MPP_SERVICE_H
-#define __ROCKCHIP_MPP_SERVICE_H
+#ifndef _ROCKCHIP_MPP_SERVICE_H_
+#define _ROCKCHIP_MPP_SERVICE_H_
 
-#include <linux/ioctl.h>
+struct mpp_service_node;
+struct mpp_service;
 
-#include "mpp_dev_common.h"
+struct mpp_task;
 
-struct mpp_session {
-	struct mpp_dma_session *dma;
-	/* a linked list of data so we can access them for debugging */
-	struct list_head list_session;
-	/* the session related device private data */
-	struct rockchip_mpp_dev *mpp;
-	struct list_head done;
-	wait_queue_head_t wait;
-	pid_t pid;
-	atomic_t task_running;
-};
+void mpp_srv_push_pending(struct mpp_service_node *node, struct mpp_task *task);
+struct mpp_task *mpp_srv_get_pending_task(struct mpp_service_node *node);
 
-enum mpp_srv_state {
-	HW_RUNNING	= BIT(1)
-};
+void mpp_srv_run(struct mpp_service_node *node, struct mpp_task *task);
+void mpp_srv_done(struct mpp_service_node *node, struct mpp_task *task);
+int mpp_srv_abort(struct mpp_service_node *node, struct mpp_task *task);
 
-struct mpp_service {
-	/* service structure global lock */
-	struct mutex lock;
-	struct list_head pending;
-	struct list_head done;
-	struct list_head running;
-	/* link to list_session in struct mpp_session */
-	struct list_head session;
+void mpp_srv_wait_to_run(struct mpp_service_node *node, struct mpp_task *task);
+struct mpp_task *mpp_srv_get_cur_task(struct mpp_service_node *node);
 
-	struct device *dev;
-
-	void __iomem *reg_base;
-
-	struct class *cls;
-
-	u32 dev_cnt;
-	struct list_head subdev_list;
-};
-
-void mpp_srv_lock(struct mpp_service *pservice);
-void mpp_srv_unlock(struct mpp_service *pservice);
-void mpp_srv_pending_locked(struct mpp_service *pservice, struct mpp_ctx *ctx);
-void mpp_srv_run(struct mpp_service *pservice);
-void mpp_srv_done(struct mpp_service *pservice);
-void mpp_srv_attach(struct mpp_service *pservice, struct list_head *elem);
-void mpp_srv_detach(struct mpp_service *pservice, struct list_head *elem);
-struct mpp_ctx *mpp_srv_get_pending_ctx(struct mpp_service *pservice);
-struct mpp_ctx *mpp_srv_get_current_ctx(struct mpp_service *pservice);
-struct mpp_ctx *mpp_srv_get_last_running_ctx(struct mpp_service *pservice);
-struct mpp_session *mpp_srv_get_current_session(struct mpp_service *pservice);
-bool mpp_srv_pending_is_empty(struct mpp_service *pservice);
-struct mpp_ctx *mpp_srv_get_done_ctx(struct mpp_session *session);
-bool mpp_srv_is_power_on(struct mpp_service *pservice);
-bool mpp_srv_is_running(struct mpp_service *pservice);
+int mpp_srv_is_running(struct mpp_service_node *node);
 
+void *mpp_srv_attach(struct mpp_service *pservice, void *data);
+void mpp_srv_detach(struct mpp_service_node *node);
 #endif
-

From f99eaee0e54477c0734add1583fb299d71932c91 Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Thu, 2 Nov 2017 10:51:14 +0800
Subject: [PATCH] video: rockchip/mpp_device: add rockchip decoder

Both rockchip video decoder and rockchip HEVC decoder
are supported by this driver.

Change-Id: Ie5e23db3191a71784aca41f1f7d2d4f89ce27a52
Signed-off-by: Randy Li <randy.li@rock-chips.com>
Signed-off-by: ayaka <ayaka@soulik.info>
---
 drivers/video/rockchip/vpu/Kconfig          |   9 +-
 drivers/video/rockchip/vpu/Makefile         |   2 +
 drivers/video/rockchip/vpu/mpp_dev_rkvdec.c | 782 ++++++++++++++++++++++++++++
 3 files changed, 792 insertions(+), 1 deletion(-)
 create mode 100644 drivers/video/rockchip/vpu/mpp_dev_rkvdec.c

diff --git a/drivers/video/rockchip/vpu/Kconfig b/drivers/video/rockchip/vpu/Kconfig
index d1ceffdeac61..cb1776088d6c 100644
--- a/drivers/video/rockchip/vpu/Kconfig
+++ b/drivers/video/rockchip/vpu/Kconfig
@@ -13,5 +13,12 @@ config ROCKCHIP_MPP_DEVICE
 	depends on ROCKCHIP_MPP_SERVICE
 	default n
 	help
-	  rockchip mpp module.
+	  rockchip mpp device framework.
+
+config ROCKCHIP_MPP_VDEC_DEVICE
+	tristate "video decoder device driver"
+	depends on ROCKCHIP_MPP_DEVICE
+	default n
+	help
+	  rockchip mpp video decoder and hevc decoder.
 endmenu
diff --git a/drivers/video/rockchip/vpu/Makefile b/drivers/video/rockchip/vpu/Makefile
index d6b3b3956b16..51b90a9426d3 100644
--- a/drivers/video/rockchip/vpu/Makefile
+++ b/drivers/video/rockchip/vpu/Makefile
@@ -1,6 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0
 rk-mpp-service-objs := mpp_service.o
 rk-mpp-device-objs := mpp_dev_common.o mpp_iommu_dma.o
+rk-mpp-vdec-objs := mpp_dev_rkvdec.o
 
 obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += rk-mpp-service.o
 obj-$(CONFIG_ROCKCHIP_MPP_DEVICE) += rk-mpp-device.o
+obj-$(CONFIG_ROCKCHIP_MPP_VDEC_DEVICE) += rk-mpp-vdec.o
diff --git a/drivers/video/rockchip/vpu/mpp_dev_rkvdec.c b/drivers/video/rockchip/vpu/mpp_dev_rkvdec.c
new file mode 100644
index 000000000000..f56b33ea237a
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_dev_rkvdec.c
@@ -0,0 +1,782 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <soc/rockchip/pm_domains.h>
+
+#include "mpp_debug.h"
+#include "mpp_dev_common.h"
+
+#define RKVDEC_DRIVER_NAME		"mpp_rkvdec"
+
+#define RKVDEC_NODE_NAME		"rkvdec"
+#define RK_HEVCDEC_NODE_NAME		"hevc-service"
+
+/* The maximum registers number of all the version */
+#define ROCKCHIP_RKVDEC_REG_NUM			(109)
+
+#define RKVDEC_REG_DEC_INT_EN			0x004
+#define RKVDEC_REG_DEC_INT_EN_INDEX		(1)
+#define		RKVDEC_WR_DDR_ALIGN_EN		BIT(23)
+#define		RKVDEC_FORCE_SOFT_RESET_VALID	BIT(21)
+#define		RKVDEC_SOFTWARE_RESET_EN	BIT(20)
+#define		RKVDEC_INT_COLMV_REF_ERROR	BIT(17)
+#define		RKVDEC_INT_BUF_EMPTY		BIT(16)
+#define		RKVDEC_INT_TIMEOUT		BIT(15)
+#define		RKVDEC_INT_STRM_ERROR		BIT(14)
+#define		RKVDEC_INT_BUS_ERROR		BIT(13)
+#define		RKVDEC_DEC_INT_RAW		BIT(9)
+#define		RKVDEC_DEC_INT			BIT(8)
+#define		RKVDEC_DEC_TIMEOUT_EN		BIT(5)
+#define		RKVDEC_DEC_IRQ_DIS		BIT(4)
+#define		RKVDEC_CLOCK_GATE_EN		BIT(1)
+#define		RKVDEC_DEC_START		BIT(0)
+
+#define RKVDEC_REG_SYS_CTRL			0x008
+#define RKVDEC_REG_SYS_CTRL_INDEX		(2)
+#define		RKVDEC_GET_FORMAT(x)		(((x) >> 20) & 0x3)
+#define		RKVDEC_FMT_H265D		(0)
+#define		RKVDEC_FMT_H264D		(1)
+#define		RKVDEC_FMT_VP9D			(2)
+
+#define RKVDEC_REG_STREAM_RLC_BASE		0x010
+#define RKVDEC_REG_STREAM_RLC_BASE_INDEX	(4)
+
+#define RKVDEC_REG_PPS_BASE			0x0a0
+#define RKVDEC_REG_PPS_BASE_INDEX		(42)
+
+#define RKVDEC_REG_VP9_REFCOLMV_BASE		0x0d0
+#define RKVDEC_REG_VP9_REFCOLMV_BASE_INDEX	(52)
+
+#define RKVDEC_REG_CACHE_ENABLE(i)		(0x41c + ((i) * 0x40))
+#define		RKVDEC_CACHE_PERMIT_CACHEABLE_ACCESS	BIT(0)
+#define		RKVDEC_CACHE_PERMIT_READ_ALLOCATE	BIT(1)
+#define		RKVDEC_CACHE_LINE_SIZE_64_BYTES		BIT(4)
+
+#define MPP_ALIGN_SIZE	0x1000
+
+#define MHZ		(1000 * 1000)
+#define DEF_ACLK	400
+#define DEF_CORE	250
+#define DEF_CABAC	300
+
+#define to_rkvdec_task(ctx)		\
+		container_of(ctx, struct rkvdec_task, mpp_task)
+#define to_rkvdec_dev(dev)		\
+		container_of(dev, struct rockchip_rkvdec_dev, mpp_dev)
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "bit switch for rkvdec debug information");
+
+enum RKVDEC_STATE {
+	RKVDEC_STATE_NORMAL,
+	RKVDEC_STATE_LT_START,
+	RKVDEC_STATE_LT_RUN,
+};
+
+struct rockchip_rkvdec_dev {
+	struct rockchip_mpp_dev mpp_dev;
+
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+	struct reset_control *rst_niu_a;
+	struct reset_control *rst_niu_h;
+	struct reset_control *rst_core;
+	struct reset_control *rst_cabac;
+
+	enum RKVDEC_STATE state;
+
+	void *current_task;
+};
+
+struct rkvdec_task {
+	struct mpp_task mpp_task;
+
+	u32 reg[ROCKCHIP_RKVDEC_REG_NUM];
+	u32 idx;
+
+	u32 strm_base;
+	u32 irq_status;
+};
+
+/*
+ * file handle translate information
+ */
+static const char trans_tbl_h264d[] = {
+	4, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+	23, 24, 41, 42, 43, 48, 75
+};
+
+static const char trans_tbl_h265d[] = {
+	4, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,
+	23, 24, 42, 43
+};
+
+static const char trans_tbl_vp9d[] = {
+	4, 6, 7, 11, 12, 13, 14, 15, 16
+};
+
+static struct mpp_trans_info trans_rk_hevcdec[] = {
+	[RKVDEC_FMT_H265D] = {
+		.count = sizeof(trans_tbl_h265d),
+		.table = trans_tbl_h265d,
+	},
+};
+
+static struct mpp_trans_info trans_rkvdec[] = {
+	[RKVDEC_FMT_H265D] = {
+		.count = sizeof(trans_tbl_h265d),
+		.table = trans_tbl_h265d,
+	},
+	[RKVDEC_FMT_H264D] = {
+		.count = sizeof(trans_tbl_h264d),
+		.table = trans_tbl_h264d,
+	},
+	[RKVDEC_FMT_VP9D] = {
+		.count = sizeof(trans_tbl_vp9d),
+		.table = trans_tbl_vp9d,
+	},
+};
+
+static const struct mpp_dev_variant rkvdec_v1_data = {
+	.reg_len = 76,
+	.trans_info = trans_rkvdec,
+	.node_name = RKVDEC_NODE_NAME,
+};
+
+static const struct mpp_dev_variant rk_hevcdec_data = {
+	.reg_len = 48,
+	.trans_info = trans_rk_hevcdec,
+	.node_name = RK_HEVCDEC_NODE_NAME,
+};
+
+static void *rockchip_rkvdec_get_drv_data(struct platform_device *pdev);
+
+/*
+ * NOTE: rkvdec/rkhevc put scaling list address in pps buffer hardware will read
+ * it by pps id in video stream data.
+ *
+ * So we need to translate the address in iommu case. The address data is also
+ * 10bit fd + 22bit offset mode.
+ * Because userspace decoder do not give the pps id in the register file sets
+ * kernel driver need to translate each scaling list address in pps buffer which
+ * means 256 pps for H.264, 64 pps for H.265.
+ *
+ * In order to optimize the performance kernel driver ask userspace decoder to
+ * set all scaling list address in pps buffer to the same one which will be used
+ * on current decoding task. Then kernel driver can only translate the first
+ * address then copy it all pps buffer.
+ */
+static int fill_scaling_list_pps(struct rkvdec_task *task, int fd, int offset,
+				 int count, int pps_info_size,
+				 int sub_addr_offset)
+{
+	struct device *dev = NULL;
+	struct dma_buf *dmabuf = NULL;
+	void *vaddr = NULL;
+	u8 *pps = NULL;
+	u32 base = sub_addr_offset;
+	u32 scaling_fd = 0;
+	u32 scaling_offset;
+	int ret = 0;
+
+	/* FIXME: find a better way, it only be used for debugging purpose */
+	dev = task->mpp_task.session->mpp->dev;
+	if (!dev)
+		return -EINVAL;
+
+	dmabuf = dma_buf_get(fd);
+	if (IS_ERR_OR_NULL(dmabuf)) {
+		dev_err(dev, "invliad pps buffer\n");
+		return -ENOENT;
+	}
+
+	ret = dma_buf_begin_cpu_access(dmabuf, 0, dmabuf->size,
+				       DMA_FROM_DEVICE);
+	if (ret) {
+		dev_err(dev, "can't access the pps buffer\n");
+		goto done;
+	}
+
+	vaddr = dma_buf_vmap(dmabuf);
+	if (!vaddr) {
+		dev_err(dev, "can't access the pps buffer\n");
+		ret = -EIO;
+		goto done;
+	}
+	pps = vaddr + offset;
+
+	memcpy(&scaling_offset, pps + base, sizeof(scaling_offset));
+	scaling_offset = le32_to_cpu(scaling_offset);
+
+	scaling_fd = scaling_offset & 0x3ff;
+	scaling_offset = scaling_offset >> 10;
+
+	if (scaling_fd > 0) {
+		struct mpp_mem_region *mem_region = NULL;
+		dma_addr_t tmp = 0;
+		int i = 0;
+
+		mem_region = mpp_dev_task_attach_fd(&task->mpp_task,
+						    scaling_fd);
+		if (IS_ERR(mem_region)) {
+			ret = PTR_ERR(mem_region);
+			goto done;
+		}
+
+		tmp = mem_region->iova;
+		tmp += scaling_offset;
+		tmp = cpu_to_le32(tmp);
+		mpp_debug(DEBUG_PPS_FILL,
+			  "pps at %p, scaling fd: %3d => %pad + offset %10d\n",
+			  pps, scaling_fd, &mem_region->iova, offset);
+
+		/* Fill the scaling list address in each pps entries */
+		for (i = 0; i < count; i++, base += pps_info_size)
+			memcpy(pps + base, &tmp, sizeof(tmp));
+	}
+
+done:
+	dma_buf_vunmap(dmabuf, vaddr);
+	dma_buf_end_cpu_access(dmabuf, 0, dmabuf->size, DMA_FROM_DEVICE);
+	dma_buf_put(dmabuf);
+
+	return ret;
+}
+
+static void *rockchip_mpp_rkvdec_alloc_task(struct mpp_session *session,
+					    void __user *src, u32 size)
+{
+	struct rkvdec_task *task = NULL;
+	u32 reg_len;
+	u32 fmt = 0;
+	u32 dwsize = size / sizeof(u32);
+	int pps_fd;
+	u32 pps_offset;
+	int err = -EFAULT;
+
+	mpp_debug_enter();
+
+	task = kzalloc(sizeof(*task), GFP_KERNEL);
+	if (!task)
+		return NULL;
+
+	mpp_dev_task_init(session, &task->mpp_task);
+
+	reg_len = dwsize > ROCKCHIP_RKVDEC_REG_NUM ?
+		ROCKCHIP_RKVDEC_REG_NUM : dwsize;
+
+	if (copy_from_user(task->reg, src, reg_len * 4)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		err = -EFAULT;
+		goto fail;
+	}
+
+	fmt = RKVDEC_GET_FORMAT(task->reg[RKVDEC_REG_SYS_CTRL_INDEX]);
+	/*
+	 * special offset scale case
+	 *
+	 * This translation is for fd + offset translation.
+	 * One register has 32bits. We need to transfer both buffer file
+	 * handle and the start address offset so we packet file handle
+	 * and offset together using below format.
+	 *
+	 *  0~9  bit for buffer file handle range 0 ~ 1023
+	 * 10~31 bit for offset range 0 ~ 4M
+	 *
+	 * But on 4K case the offset can be larger the 4M
+	 * So on VP9 4K decoder colmv base we scale the offset by 16
+	 */
+	if (fmt == RKVDEC_FMT_VP9D) {
+		struct mpp_mem_region *mem_region = NULL;
+		dma_addr_t iova = 0;
+		u32 offset = task->reg[RKVDEC_REG_VP9_REFCOLMV_BASE_INDEX];
+		int fd = task->reg[RKVDEC_REG_VP9_REFCOLMV_BASE_INDEX] & 0x3ff;
+
+		offset = offset >> 10 << 4;
+		mem_region = mpp_dev_task_attach_fd(&task->mpp_task, fd);
+		if (IS_ERR(mem_region)) {
+			err = PTR_ERR(mem_region);
+			goto fail;
+		}
+
+		iova = mem_region->iova;
+		task->reg[RKVDEC_REG_VP9_REFCOLMV_BASE_INDEX] = iova + offset;
+	}
+
+	pps_fd = task->reg[RKVDEC_REG_PPS_BASE_INDEX] & 0x3ff;
+	pps_offset = task->reg[RKVDEC_REG_PPS_BASE_INDEX] >> 10;
+	if (pps_fd > 0) {
+		int pps_info_offset;
+		int pps_info_count;
+		int pps_info_size;
+		int scaling_list_addr_offset;
+
+		switch (fmt) {
+		case RKVDEC_FMT_H264D:
+			pps_info_offset = pps_offset;
+			pps_info_count = 256;
+			pps_info_size = 32;
+			scaling_list_addr_offset = 23;
+			break;
+		case RKVDEC_FMT_H265D:
+			pps_info_offset = pps_offset;
+			pps_info_count = 64;
+			pps_info_size = 80;
+			scaling_list_addr_offset = 74;
+			break;
+		default:
+			pps_info_offset = 0;
+			pps_info_count = 0;
+			pps_info_size = 0;
+			scaling_list_addr_offset = 0;
+			break;
+		}
+
+		mpp_debug(DEBUG_PPS_FILL,
+			  "scaling list filling parameter:\n");
+		mpp_debug(DEBUG_PPS_FILL,
+			  "pps_info_offset %d\n", pps_info_offset);
+		mpp_debug(DEBUG_PPS_FILL,
+			  "pps_info_count  %d\n", pps_info_count);
+		mpp_debug(DEBUG_PPS_FILL,
+			  "pps_info_size   %d\n", pps_info_size);
+		mpp_debug(DEBUG_PPS_FILL,
+			  "scaling_list_addr_offset %d\n",
+			  scaling_list_addr_offset);
+
+		if (pps_info_count) {
+			err = fill_scaling_list_pps(task, pps_fd,
+						    pps_info_offset,
+						    pps_info_count,
+						    pps_info_size,
+						    scaling_list_addr_offset);
+			if (err) {
+				mpp_err("fill pps failed\n");
+				goto fail;
+			}
+		}
+	}
+
+	err = mpp_reg_address_translate(session->mpp, &task->mpp_task, fmt,
+					task->reg);
+	if (err) {
+		mpp_err("error: translate reg address failed.\n");
+
+		if (unlikely(debug & DEBUG_DUMP_ERR_REG))
+			mpp_debug_dump_reg_mem(task->reg,
+					       ROCKCHIP_RKVDEC_REG_NUM);
+		goto fail;
+	}
+
+	task->strm_base = task->reg[RKVDEC_REG_STREAM_RLC_BASE_INDEX];
+
+	mpp_debug_leave();
+
+	return &task->mpp_task;
+
+fail:
+	mpp_dev_task_finalize(session, &task->mpp_task);
+	kfree(task);
+	return ERR_PTR(err);
+}
+
+static int rockchip_mpp_rkvdec_prepare(struct rockchip_mpp_dev *mpp_dev,
+				       struct mpp_task *task)
+{
+	struct rockchip_rkvdec_dev *dec_dev = to_rkvdec_dev(mpp_dev);
+
+	if (dec_dev->state == RKVDEC_STATE_NORMAL)
+		return -EINVAL;
+	/*
+	 * Don't do soft reset before running or you will meet 0x00408322
+	 * if you will decode a HEVC stream. Different error for the AVC.
+	 */
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdec_run(struct rockchip_mpp_dev *mpp_dev,
+				   struct mpp_task *mpp_task)
+{
+	struct rockchip_rkvdec_dev *dec_dev = NULL;
+	struct rkvdec_task *task = NULL;
+	u32 reg = 0;
+
+	mpp_debug_enter();
+
+	dec_dev = to_rkvdec_dev(mpp_dev);
+	task = to_rkvdec_task(mpp_task);
+#if 0
+	/*
+	 * hardware bug workaround, because the write ddr align optimize need
+	 * aclk and core clock using the same parent clock. so when optimization
+	 * enable, we need to reset the clocks.
+	 */
+	if (ctx->reg[RKVDEC_REG_DEC_INT_EN / 4] & RKVDEC_WR_DDR_ALIGN_EN) {
+		if (atomic_read(&dec->cur_core) != 250) {
+			atomic_set(&dec->cur_core, 250);
+			mpp_debug(DEBUG_CLOCK, "set core clock to 250 MHz\n");
+			clk_set_rate(dec->core, 250 * MHZ);
+		}
+	} else {
+		if (atomic_read(&dec->cur_core) != 200) {
+			atomic_set(&dec->cur_core, 200);
+			mpp_debug(DEBUG_CLOCK, "set core clock to 200 MHz\n");
+			clk_set_rate(dec->core, 200 * MHZ);
+		}
+		if (atomic_read(&dec->cur_aclk) != 300) {
+			atomic_set(&dec->cur_aclk, 300);
+			mpp_debug(DEBUG_CLOCK, "set core clock to 300 MHz\n");
+			clk_set_rate(dec->aclk, 300 * MHZ);
+		}
+		if (atomic_read(&dec->cur_caback) != 200) {
+			atomic_set(&dec->cur_caback, 200);
+			mpp_debug(DEBUG_CLOCK, "set core clock to 200 MHz\n");
+			clk_set_rate(dec->cabac, 200 * MHZ);
+		}
+	}
+#endif
+	switch (dec_dev->state) {
+	case RKVDEC_STATE_NORMAL:
+		/* FIXME: spin lock here */
+		dec_dev->current_task = task;
+
+		reg = RKVDEC_CACHE_PERMIT_CACHEABLE_ACCESS
+			| RKVDEC_CACHE_PERMIT_READ_ALLOCATE;
+		if (!(debug & DEBUG_CACHE_32B))
+			reg |= RKVDEC_CACHE_LINE_SIZE_64_BYTES;
+
+		mpp_dev_write(mpp_dev, RKVDEC_REG_CACHE_ENABLE(0), reg);
+		mpp_dev_write(mpp_dev, RKVDEC_REG_CACHE_ENABLE(1), reg);
+
+		mpp_dev_write_seq(mpp_dev, RKVDEC_REG_SYS_CTRL,
+				  &task->reg[RKVDEC_REG_SYS_CTRL_INDEX],
+				  mpp_dev->variant->reg_len
+				  - RKVDEC_REG_SYS_CTRL_INDEX);
+
+		/* Flush the register before the start the device */
+		wmb();
+		mpp_dev_write(mpp_dev, RKVDEC_REG_DEC_INT_EN,
+			      task->reg[RKVDEC_REG_DEC_INT_EN_INDEX]
+			      | RKVDEC_DEC_START);
+		break;
+	default:
+		break;
+	}
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdec_finish(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task)
+{
+	struct rockchip_rkvdec_dev *dec_dev = to_rkvdec_dev(mpp_dev);
+	struct rkvdec_task *task = to_rkvdec_task(mpp_task);
+
+	mpp_debug_enter();
+
+	switch (dec_dev->state) {
+	case RKVDEC_STATE_NORMAL: {
+		mpp_dev_read_seq(mpp_dev, RKVDEC_REG_SYS_CTRL,
+				 &task->reg[RKVDEC_REG_SYS_CTRL_INDEX],
+				 mpp_dev->variant->reg_len
+				 - RKVDEC_REG_SYS_CTRL_INDEX);
+		task->reg[RKVDEC_REG_DEC_INT_EN_INDEX] = task->irq_status;
+	} break;
+	default:
+		break;
+	}
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdec_result(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task,
+				      u32 __user *dst, u32 size)
+{
+	struct rkvdec_task *task = to_rkvdec_task(mpp_task);
+
+	/* FIXME may overflow the kernel */
+	if (copy_to_user(dst, task->reg, size)) {
+		mpp_err("copy_to_user failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdec_free_task(struct mpp_session *session,
+					 struct mpp_task *mpp_task)
+{
+	struct rkvdec_task *task = to_rkvdec_task(mpp_task);
+
+	mpp_dev_task_finalize(session, mpp_task);
+	kfree(task);
+
+	return 0;
+}
+
+static irqreturn_t mpp_rkvdec_isr(int irq, void *dev_id)
+{
+	struct rockchip_rkvdec_dev *dec_dev = dev_id;
+	struct rockchip_mpp_dev *mpp_dev = &dec_dev->mpp_dev;
+	struct rkvdec_task *task = NULL;
+	struct mpp_task *mpp_task = NULL;
+	u32 irq_status;
+	u32 err_mask;
+
+	irq_status = mpp_dev_read(mpp_dev, RKVDEC_REG_DEC_INT_EN);
+	if (!(irq_status & RKVDEC_DEC_INT_RAW))
+		return IRQ_NONE;
+
+	mpp_dev_write(mpp_dev, RKVDEC_REG_DEC_INT_EN, RKVDEC_CLOCK_GATE_EN);
+	/* FIXME use a spin lock here */
+	task = (struct rkvdec_task *)dec_dev->current_task;
+	if (!task) {
+		dev_err(dec_dev->mpp_dev.dev, "no current task\n");
+		return IRQ_HANDLED;
+	}
+	mpp_debug_time_diff(&task->mpp_task);
+
+	task->irq_status = irq_status;
+	switch (dec_dev->state) {
+	case RKVDEC_STATE_NORMAL:
+		mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n",
+			  task->irq_status);
+
+		err_mask = RKVDEC_INT_BUF_EMPTY
+			| RKVDEC_INT_BUS_ERROR
+			| RKVDEC_INT_COLMV_REF_ERROR
+			| RKVDEC_INT_STRM_ERROR
+			| RKVDEC_INT_TIMEOUT;
+
+		if (err_mask & task->irq_status)
+			atomic_set(&mpp_dev->reset_request, 1);
+
+		mpp_task = &task->mpp_task;
+		mpp_dev_task_finish(mpp_task->session, mpp_task);
+
+		mpp_debug_leave();
+		return IRQ_HANDLED;
+	default:
+		goto fail;
+	}
+fail:
+	return IRQ_HANDLED;
+}
+
+static int rockchip_mpp_rkvdec_assign_reset(struct rockchip_rkvdec_dev *dec_dev)
+{
+	struct rockchip_mpp_dev *mpp_dev = &dec_dev->mpp_dev;
+
+	/* TODO: use devm_reset_control_get_share() instead */
+	dec_dev->rst_a = devm_reset_control_get(mpp_dev->dev, "video_a");
+	dec_dev->rst_h = devm_reset_control_get(mpp_dev->dev, "video_h");
+	dec_dev->rst_core = devm_reset_control_get(mpp_dev->dev, "video_core");
+	/* The reset controller below are not shared with VPU */
+	dec_dev->rst_niu_a = devm_reset_control_get(mpp_dev->dev, "niu_a");
+	dec_dev->rst_niu_h = devm_reset_control_get(mpp_dev->dev, "niu_h");
+	dec_dev->rst_cabac = devm_reset_control_get(mpp_dev->dev,
+						    "video_cabac");
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_a)) {
+		mpp_err("No aclk reset resource define\n");
+		dec_dev->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_h)) {
+		mpp_err("No hclk reset resource define\n");
+		dec_dev->rst_h = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_niu_a)) {
+		mpp_err("No axi niu reset resource define\n");
+		dec_dev->rst_niu_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_niu_h)) {
+		mpp_err("No ahb niu reset resource define\n");
+		dec_dev->rst_niu_h = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_core)) {
+		mpp_err("No core reset resource define\n");
+		dec_dev->rst_core = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_cabac)) {
+		mpp_err("No cabac reset resource define\n");
+		dec_dev->rst_cabac = NULL;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdec_reset(struct rockchip_mpp_dev *mpp_dev)
+{
+	struct rockchip_rkvdec_dev *dec = to_rkvdec_dev(mpp_dev);
+
+	if (dec->rst_a && dec->rst_h) {
+		mpp_debug(DEBUG_RESET, "reset in\n");
+		rockchip_pmu_idle_request(mpp_dev->dev, true);
+
+		safe_reset(dec->rst_niu_a);
+		safe_reset(dec->rst_niu_h);
+		safe_reset(dec->rst_a);
+		safe_reset(dec->rst_h);
+		safe_reset(dec->rst_core);
+		safe_reset(dec->rst_cabac);
+		udelay(5);
+		safe_unreset(dec->rst_niu_h);
+		safe_unreset(dec->rst_niu_a);
+		safe_unreset(dec->rst_a);
+		safe_unreset(dec->rst_h);
+		safe_unreset(dec->rst_core);
+		safe_unreset(dec->rst_cabac);
+
+		rockchip_pmu_idle_request(mpp_dev->dev, false);
+
+		mpp_dev_write(mpp_dev, RKVDEC_REG_DEC_INT_EN, 0);
+		dec->current_task = NULL;
+		mpp_debug(DEBUG_RESET, "reset out\n");
+	}
+
+	return 0;
+}
+
+static struct mpp_dev_ops rkvdec_ops = {
+	.alloc_task = rockchip_mpp_rkvdec_alloc_task,
+	.prepare = rockchip_mpp_rkvdec_prepare,
+	.run = rockchip_mpp_rkvdec_run,
+	.finish = rockchip_mpp_rkvdec_finish,
+	.result = rockchip_mpp_rkvdec_result,
+	.free_task = rockchip_mpp_rkvdec_free_task,
+	.reset = rockchip_mpp_rkvdec_reset,
+};
+
+static int rockchip_mpp_rkvdec_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rockchip_rkvdec_dev *dec_dev = NULL;
+	struct rockchip_mpp_dev *mpp_dev = NULL;
+	int ret = 0;
+
+	dec_dev = devm_kzalloc(dev, sizeof(struct rockchip_rkvdec_dev),
+			       GFP_KERNEL);
+	if (!dec_dev)
+		return -ENOMEM;
+
+	mpp_dev = &dec_dev->mpp_dev;
+	mpp_dev->variant = rockchip_rkvdec_get_drv_data(pdev);
+	ret = mpp_dev_common_probe(mpp_dev, pdev, &rkvdec_ops);
+	if (ret)
+		return ret;
+
+	ret = devm_request_threaded_irq(dev, mpp_dev->irq, NULL, mpp_rkvdec_isr,
+					IRQF_SHARED | IRQF_ONESHOT,
+					dev_name(dev), dec_dev);
+	if (ret) {
+		dev_err(dev, "register interrupter runtime failed\n");
+		return ret;
+	}
+
+	rockchip_mpp_rkvdec_assign_reset(dec_dev);
+	dec_dev->state = RKVDEC_STATE_NORMAL;
+
+	ret = mpp_dev_register_node(mpp_dev, mpp_dev->variant->node_name, NULL);
+	if (ret)
+		dev_err(dev, "register char device failed: %d\n", ret);
+
+	dev_info(dev, "probing finish\n");
+
+	platform_set_drvdata(pdev, dec_dev);
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdec_remove(struct platform_device *pdev)
+{
+	struct rockchip_rkvdec_dev *dec_dev = platform_get_drvdata(pdev);
+
+	mpp_dev_common_remove(&dec_dev->mpp_dev);
+
+	return 0;
+}
+
+static const struct of_device_id mpp_rkvdec_dt_match[] = {
+	{ .compatible = "rockchip,video-decoder-v1", .data = &rkvdec_v1_data},
+	{ .compatible = "rockchip,hevc-decoder-v1", .data = &rk_hevcdec_data},
+	{},
+};
+
+static void *rockchip_rkvdec_get_drv_data(struct platform_device *pdev)
+{
+	struct mpp_dev_variant *driver_data = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_node(mpp_rkvdec_dt_match,
+				      pdev->dev.of_node);
+		if (match)
+			driver_data = (struct mpp_dev_variant *)match->data;
+	}
+	return driver_data;
+}
+
+static struct platform_driver rockchip_rkvdec_driver = {
+	.probe = rockchip_mpp_rkvdec_probe,
+	.remove = rockchip_mpp_rkvdec_remove,
+	.driver = {
+		.name = RKVDEC_DRIVER_NAME,
+		.of_match_table = of_match_ptr(mpp_rkvdec_dt_match),
+	},
+};
+
+static int __init mpp_dev_rkvdec_init(void)
+{
+	int ret = platform_driver_register(&rockchip_rkvdec_driver);
+
+	if (ret) {
+		mpp_err("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit mpp_dev_rkvdec_exit(void)
+{
+	platform_driver_unregister(&rockchip_rkvdec_driver);
+}
+
+module_init(mpp_dev_rkvdec_init);
+module_exit(mpp_dev_rkvdec_exit);
+
+MODULE_DEVICE_TABLE(of, mpp_rkvdec_dt_match);
+MODULE_LICENSE("GPL v2");

From 9bc8af1c33a51dc674fc29c58172e3f965fc7997 Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Fri, 17 Nov 2017 04:50:15 +0800
Subject: [PATCH] video: rockchip/mpp_device: add VPU decoder

There are two modules for the different generation of
the VPU decoder. The register of  the VPU decoder
usually have an offset to the VPU base.

Please notice that the encoder of the VPU is supported
in the other module.

The decoder and encoder of the VPU usually share some
hardware resources(Not the RK3328, the encoders at that
platform share the resources), so they will be regarded
as an combo sharing the same mpp service in this design
of the mpp driver.

The Post Processor is not supported now (Only work for
 JPEG decoder). I am planning to move it into the
other module.

Change-Id: Ic5d1f4f6ad9b58bc805e6edeace3a5fa23d74e20
Signed-off-by: ayaka <ayaka@soulik.info>
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 drivers/video/rockchip/vpu/Kconfig         |  14 +
 drivers/video/rockchip/vpu/Makefile        |   4 +
 drivers/video/rockchip/vpu/mpp_dev_vdpu1.c | 615 +++++++++++++++++++++++++++++
 drivers/video/rockchip/vpu/mpp_dev_vdpu2.c | 577 +++++++++++++++++++++++++++
 4 files changed, 1210 insertions(+)
 create mode 100644 drivers/video/rockchip/vpu/mpp_dev_vdpu1.c
 create mode 100644 drivers/video/rockchip/vpu/mpp_dev_vdpu2.c

diff --git a/drivers/video/rockchip/vpu/Kconfig b/drivers/video/rockchip/vpu/Kconfig
index cb1776088d6c..091707cfc440 100644
--- a/drivers/video/rockchip/vpu/Kconfig
+++ b/drivers/video/rockchip/vpu/Kconfig
@@ -21,4 +21,18 @@ config ROCKCHIP_MPP_VDEC_DEVICE
 	default n
 	help
 	  rockchip mpp video decoder and hevc decoder.
+
+config ROCKCHIP_MPP_VDPU1_DEVICE
+	tristate "VPU decoder v1 device driver"
+	depends on ROCKCHIP_MPP_DEVICE
+	default n
+	help
+	  rockchip mpp vpu decoder v1.
+
+config ROCKCHIP_MPP_VDPU2_DEVICE
+	tristate "VPU decoder v2 device driver"
+	depends on ROCKCHIP_MPP_DEVICE
+	default n
+	help
+	  rockchip mpp vpu decoder v2.
 endmenu
diff --git a/drivers/video/rockchip/vpu/Makefile b/drivers/video/rockchip/vpu/Makefile
index 51b90a9426d3..37fc13533200 100644
--- a/drivers/video/rockchip/vpu/Makefile
+++ b/drivers/video/rockchip/vpu/Makefile
@@ -2,7 +2,11 @@
 rk-mpp-service-objs := mpp_service.o
 rk-mpp-device-objs := mpp_dev_common.o mpp_iommu_dma.o
 rk-mpp-vdec-objs := mpp_dev_rkvdec.o
+rk-mpp-vdpu1-objs := mpp_dev_vdpu1.o
+rk-mpp-vdpu2-objs := mpp_dev_vdpu2.o
 
 obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += rk-mpp-service.o
 obj-$(CONFIG_ROCKCHIP_MPP_DEVICE) += rk-mpp-device.o
 obj-$(CONFIG_ROCKCHIP_MPP_VDEC_DEVICE) += rk-mpp-vdec.o
+obj-$(CONFIG_ROCKCHIP_MPP_VDPU1_DEVICE) += rk-mpp-vdpu1.o
+obj-$(CONFIG_ROCKCHIP_MPP_VDPU2_DEVICE) += rk-mpp-vdpu2.o
diff --git a/drivers/video/rockchip/vpu/mpp_dev_vdpu1.c b/drivers/video/rockchip/vpu/mpp_dev_vdpu1.c
new file mode 100644
index 000000000000..4371a1a6080b
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_dev_vdpu1.c
@@ -0,0 +1,615 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *		Randy Li, <ayaka@soulik.info>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <soc/rockchip/pm_domains.h>
+
+#include "mpp_debug.h"
+#include "mpp_dev_common.h"
+
+#define RKVDPU1_DRIVER_NAME		"mpp_vdpu1"
+#define RKVDPU1_NODE_NAME		"vpu-service"
+
+#define RKAVSD1_NODE_NAME		"avsd"
+
+/* The maximum registers number of all the version */
+#define ROCKCHIP_VDPU1_REG_NUM			108
+
+#define RKVDPU1_REG_DEC_INT_EN			0x004
+#define RKVDPU1_REG_DEC_INT_EN_INDEX		(1)
+/* B slice detected, used in 8190 decoder and later */
+#define		RKVDPU1_INT_PIC_INF		BIT(24)
+#define		RKVDPU1_INT_TIMEOUT		BIT(18)
+#define		RKVDPU1_INT_SLICE		BIT(17)
+#define		RKVDPU1_INT_STRM_ERROR		BIT(16)
+#define		RKVDPU1_INT_ASO_ERROR		BIT(15)
+#define		RKVDPU1_INT_BUF_EMPTY		BIT(14)
+#define		RKVDPU1_INT_BUS_ERROR		BIT(13)
+#define		RKVDPU1_DEC_INT			BIT(12)
+#define		RKVDPU1_DEC_INT_RAW		BIT(8)
+#define		RKVDPU1_DEC_IRQ_DIS		BIT(4)
+#define		RKVDPU1_DEC_START		BIT(0)
+
+#define RKVDPU1_REG_DEC_DEV_CTRL		0x008
+#define RKVDPU1_REG_DEC_DEV_CTRL_INDEX		(2)
+/* NOTE: Don't enable it or decoding AVC would meet problem at rk3288 */
+#define		RKVDPU1_CLOCK_GATE_EN		BIT(10)
+
+#define RKVDPU1_REG_SYS_CTRL			0x00c
+#define RKVDPU1_REG_SYS_CTRL_INDEX		(3)
+#define		RKVDPU1_GET_FORMAT(x)		(((x) >> 28) & 0xf)
+#define		RKVDPU1_FMT_H264D		0
+#define		RKVDPU1_FMT_MPEG4D		1
+#define		RKVDPU1_FMT_H263D		2
+#define		RKVDPU1_FMT_JPEGD		3
+#define		RKVDPU1_FMT_VC1D		4
+#define		RKVDPU1_FMT_MPEG2D		5
+#define		RKVDPU1_FMT_MPEG1D		6
+#define		RKVDPU1_FMT_VP6D		7
+#define		RKVDPU1_FMT_RESERVED		8
+#define		RKVDPU1_FMT_VP7D		9
+#define		RKVDPU1_FMT_VP8D		10
+#define		RKVDPU1_FMT_AVSD		11
+
+#define RKVDPU1_REG_STREAM_RLC_BASE		0x030
+#define RKVDPU1_REG_STREAM_RLC_BASE_INDEX	(12)
+
+#define RKVDPU1_REG_DIR_MV_BASE			0x0a4
+#define RKVDPU1_REG_DIR_MV_BASE_INDEX		(41)
+
+#define to_rkvdpu_task(ctx)		\
+		container_of(ctx, struct rkvdpu_task, mpp_task)
+#define to_rkvdpu_dev(dev)		\
+		container_of(dev, struct rockchip_rkvdpu_dev, mpp_dev)
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "bit switch for vdpu1 debug information");
+
+struct vdpu1_dev_data {
+	struct mpp_dev_variant dec_data;
+	bool pp_support;
+};
+
+struct rockchip_rkvdpu_dev {
+	struct rockchip_mpp_dev mpp_dev;
+	struct vdpu1_dev_data *data;
+
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+
+	void *current_task;
+};
+
+struct rkvdpu_task {
+	struct mpp_task mpp_task;
+
+	u32 reg[ROCKCHIP_VDPU1_REG_NUM];
+	u32 idx;
+	struct extra_info_for_iommu ext_inf;
+
+	u32 strm_base;
+	u32 irq_status;
+};
+
+/*
+ * file handle translate information
+ */
+static const char trans_tbl_avsd[] = {
+	12, 13, 14, 15, 16, 17, 40, 41, 45
+};
+
+static const char trans_tbl_default[] = {
+	12, 13, 14, 15, 16, 17, 40, 41
+};
+
+static const char trans_tbl_jpegd[] = {
+	12, 13, 14, 40, 66, 67
+};
+
+static const char trans_tbl_h264d[] = {
+	12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,
+	28, 29, 40
+};
+
+static const char trans_tbl_vc1d[] = {
+	12, 13, 14, 15, 16, 17, 27, 41
+};
+
+static const char trans_tbl_vp6d[] = {
+	12, 13, 14, 18, 27, 40
+};
+
+static const char trans_tbl_vp8d[] = {
+	10, 12, 13, 14, 18, 19, 22, 23, 24, 25, 26, 27, 28, 29, 40
+};
+
+static struct mpp_trans_info trans_rk_vdpu1[] = {
+	[RKVDPU1_FMT_H264D] = {
+		.count = sizeof(trans_tbl_h264d),
+		.table = trans_tbl_h264d,
+	},
+	[RKVDPU1_FMT_MPEG4D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU1_FMT_H263D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU1_FMT_JPEGD] = {
+		.count = sizeof(trans_tbl_jpegd),
+		.table = trans_tbl_jpegd,
+	},
+	[RKVDPU1_FMT_VC1D] = {
+		.count = sizeof(trans_tbl_vc1d),
+		.table = trans_tbl_vc1d,
+	},
+	[RKVDPU1_FMT_MPEG2D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU1_FMT_MPEG1D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU1_FMT_VP6D] = {
+		.count = sizeof(trans_tbl_vp6d),
+		.table = trans_tbl_vp6d,
+	},
+	[RKVDPU1_FMT_RESERVED] = {
+		.count = 0,
+		.table = NULL,
+	},
+	[RKVDPU1_FMT_VP7D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU1_FMT_VP8D] = {
+		.count = sizeof(trans_tbl_vp8d),
+		.table = trans_tbl_vp8d,
+	},
+	[RKVDPU1_FMT_AVSD] = {
+		.count = sizeof(trans_tbl_avsd),
+		.table = trans_tbl_avsd,
+	},
+};
+
+static const struct vdpu1_dev_data vdpu_v1_data = {
+	.dec_data = {
+		/* Exclude the register of the Post Processor */
+		.reg_len = 60,
+		.trans_info = trans_rk_vdpu1,
+		.node_name = RKVDPU1_NODE_NAME,
+	},
+	.pp_support = false,
+};
+
+static const struct vdpu1_dev_data vdpu_pp_v1_data = {
+	.dec_data = {
+		/* Exclude the register of the Performance monitor */
+		.reg_len = 101,
+		.trans_info = trans_rk_vdpu1,
+		.node_name = RKVDPU1_NODE_NAME,
+	},
+	.pp_support = true,
+};
+
+static const struct vdpu1_dev_data vdpu_avs_v1_data = {
+	.dec_data = {
+		/* Exclude the register of the Performance monitor */
+		.reg_len = 101,
+		.trans_info = trans_rk_vdpu1,
+		.node_name = RKAVSD1_NODE_NAME,
+	},
+	.pp_support = true,
+};
+
+static void *rockchip_rkvdpu1_get_drv_data(struct platform_device *pdev);
+
+static void *rockchip_mpp_rkvdpu_alloc_task(struct mpp_session *session,
+					    void __user *src, u32 size)
+{
+	struct rkvdpu_task *task = NULL;
+	u32 reg_len;
+	u32 extinf_len;
+	u32 fmt = 0;
+	u32 dwsize = size / sizeof(u32);
+	int err = -EFAULT;
+
+	mpp_debug_enter();
+
+	task = kzalloc(sizeof(*task), GFP_KERNEL);
+	if (!task)
+		return NULL;
+
+	mpp_dev_task_init(session, &task->mpp_task);
+
+	reg_len = dwsize > ROCKCHIP_VDPU1_REG_NUM ?
+		ROCKCHIP_VDPU1_REG_NUM : dwsize;
+	extinf_len = dwsize > reg_len ? (dwsize - reg_len) * 4 : 0;
+
+	if (copy_from_user(task->reg, src, reg_len * 4)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		err = -EFAULT;
+		goto fail;
+	}
+
+	fmt = RKVDPU1_GET_FORMAT(task->reg[RKVDPU1_REG_SYS_CTRL_INDEX]);
+	if (extinf_len > 0) {
+		if (likely(fmt == RKVDPU1_FMT_JPEGD)) {
+			err = copy_from_user(&task->ext_inf,
+					     (u8 *)src + size
+					     - JPEG_IOC_EXTRA_SIZE,
+					     JPEG_IOC_EXTRA_SIZE);
+		} else {
+			u32 ext_cpy = min_t(size_t, extinf_len,
+					    sizeof(task->ext_inf));
+			err = copy_from_user(&task->ext_inf,
+					     (u32 *)src + reg_len, ext_cpy);
+		}
+
+		if (err) {
+			mpp_err("copy_from_user failed when extra info\n");
+			err = -EFAULT;
+			goto fail;
+		}
+	}
+
+	err = mpp_reg_address_translate(session->mpp, &task->mpp_task, fmt,
+					task->reg);
+	if (err) {
+		mpp_err("error: translate reg address failed.\n");
+
+		if (unlikely(debug & DEBUG_DUMP_ERR_REG))
+			mpp_debug_dump_reg_mem(task->reg,
+					       ROCKCHIP_VDPU1_REG_NUM);
+		goto fail;
+	}
+	/*
+	 * special offset scale case
+	 *
+	 * This translation is for fd + offset translation.
+	 * One register has 32bits. We need to transfer both buffer file
+	 * handle and the start address offset so we packet file handle
+	 * and offset together using below format.
+	 *
+	 *  0~9  bit for buffer file handle range 0 ~ 1023
+	 * 10~31 bit for offset range 0 ~ 4M
+	 *
+	 * But on 4K case the offset can be larger the 4M
+	 */
+	if (likely(fmt == RKVDPU1_FMT_H264D)) {
+		struct mpp_mem_region *mem_region = NULL;
+		dma_addr_t iova = 0;
+		u32 offset = task->reg[RKVDPU1_REG_DIR_MV_BASE_INDEX];
+		int fd = task->reg[RKVDPU1_REG_DIR_MV_BASE_INDEX] & 0x3ff;
+
+		offset = offset >> 10 << 4;
+		mem_region = mpp_dev_task_attach_fd(&task->mpp_task, fd);
+		if (IS_ERR(mem_region)) {
+			err = PTR_ERR(mem_region);
+			goto fail;
+		}
+
+		iova = mem_region->iova;
+		mpp_debug(DEBUG_IOMMU, "DMV[%3d]: %3d => %pad + offset %10d\n",
+			  RKVDPU1_REG_DIR_MV_BASE_INDEX, fd, &iova, offset);
+		task->reg[RKVDPU1_REG_DIR_MV_BASE_INDEX] = iova + offset;
+	}
+
+	task->strm_base = task->reg[RKVDPU1_REG_STREAM_RLC_BASE_INDEX];
+
+	mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
+		  task->ext_inf.cnt, task->ext_inf.magic);
+	mpp_translate_extra_info(&task->mpp_task, &task->ext_inf, task->reg);
+
+	mpp_debug_leave();
+
+	return &task->mpp_task;
+
+fail:
+	mpp_dev_task_finalize(session, &task->mpp_task);
+	kfree(task);
+	return ERR_PTR(err);
+}
+
+static int rockchip_mpp_rkvdpu_prepare(struct rockchip_mpp_dev *mpp_dev,
+				       struct mpp_task *task)
+{
+	return -EINVAL;
+}
+
+static int rockchip_mpp_rkvdpu_run(struct rockchip_mpp_dev *mpp_dev,
+				   struct mpp_task *mpp_task)
+{
+	struct rkvdpu_task *task = NULL;
+	struct rockchip_rkvdpu_dev *dec_dev = NULL;
+
+	mpp_debug_enter();
+
+	task = to_rkvdpu_task(mpp_task);
+	dec_dev = to_rkvdpu_dev(mpp_dev);
+
+	/* FIXME: spin lock here */
+	dec_dev->current_task = task;
+
+	mpp_dev_write_seq(mpp_dev, RKVDPU1_REG_DEC_DEV_CTRL,
+			  &task->reg[RKVDPU1_REG_DEC_DEV_CTRL_INDEX],
+			  mpp_dev->variant->reg_len
+			  - RKVDPU1_REG_DEC_DEV_CTRL_INDEX);
+	/* Flush the registers */
+	wmb();
+	mpp_dev_write(mpp_dev, RKVDPU1_REG_DEC_INT_EN,
+		      task->reg[RKVDPU1_REG_DEC_INT_EN_INDEX]
+		      | RKVDPU1_DEC_START);
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_finish(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task)
+{
+	struct rkvdpu_task *task = to_rkvdpu_task(mpp_task);
+
+	mpp_debug_enter();
+
+	mpp_dev_read_seq(mpp_dev, RKVDPU1_REG_DEC_DEV_CTRL,
+			 &task->reg[RKVDPU1_REG_DEC_DEV_CTRL_INDEX],
+			 mpp_dev->variant->reg_len
+			 - RKVDPU1_REG_DEC_DEV_CTRL);
+	task->reg[RKVDPU1_REG_DEC_INT_EN_INDEX] = task->irq_status;
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_result(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task,
+				      u32 __user *dst, u32 size)
+{
+	struct rkvdpu_task *task = to_rkvdpu_task(mpp_task);
+
+	/* FIXME may overflow the kernel */
+	if (copy_to_user(dst, task->reg, size)) {
+		mpp_err("copy_to_user failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_free_task(struct mpp_session *session,
+					 struct mpp_task *mpp_task)
+{
+	struct rkvdpu_task *task = to_rkvdpu_task(mpp_task);
+
+	mpp_dev_task_finalize(session, mpp_task);
+	kfree(task);
+
+	return 0;
+}
+
+static irqreturn_t mpp_rkvdpu_isr(int irq, void *dev_id)
+{
+	struct rockchip_rkvdpu_dev *dec_dev = dev_id;
+	struct rockchip_mpp_dev *mpp_dev = &dec_dev->mpp_dev;
+	struct rkvdpu_task *task = NULL;
+	struct mpp_task *mpp_task = NULL;
+	u32 irq_status;
+	u32 err_mask;
+
+	irq_status = mpp_dev_read(mpp_dev, RKVDPU1_REG_DEC_INT_EN);
+	if (!(irq_status & RKVDPU1_DEC_INT_RAW))
+		return IRQ_NONE;
+
+	mpp_dev_write(mpp_dev, RKVDPU1_REG_DEC_INT_EN, 0);
+	/* FIXME use a spin lock here */
+	task = (struct rkvdpu_task *)dec_dev->current_task;
+	if (!task) {
+		dev_err(dec_dev->mpp_dev.dev, "no current task\n");
+		return IRQ_HANDLED;
+	}
+
+	mpp_task = &task->mpp_task;
+	mpp_debug_time_diff(mpp_task);
+
+	task->irq_status = irq_status;
+	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n",
+		  task->irq_status);
+
+	err_mask = RKVDPU1_INT_TIMEOUT
+		| RKVDPU1_INT_STRM_ERROR
+		| RKVDPU1_INT_ASO_ERROR
+		| RKVDPU1_INT_BUF_EMPTY
+		| RKVDPU1_INT_BUS_ERROR;
+
+	if (err_mask & task->irq_status)
+		atomic_set(&mpp_dev->reset_request, 1);
+
+	mpp_dev_task_finish(mpp_task->session, mpp_task);
+
+	mpp_debug_leave();
+	return IRQ_HANDLED;
+}
+
+static int rockchip_mpp_rkvdpu_assign_reset(struct rockchip_rkvdpu_dev *dec_dev)
+{
+	struct rockchip_mpp_dev *mpp_dev = &dec_dev->mpp_dev;
+
+	/* TODO: use devm_reset_control_get_share() instead */
+	dec_dev->rst_a = devm_reset_control_get(mpp_dev->dev, "video_a");
+	dec_dev->rst_h = devm_reset_control_get(mpp_dev->dev, "video_h");
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_a)) {
+		mpp_err("No aclk reset resource define\n");
+		dec_dev->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_h)) {
+		mpp_err("No hclk reset resource define\n");
+		dec_dev->rst_h = NULL;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_reset(struct rockchip_mpp_dev *mpp_dev)
+{
+	struct rockchip_rkvdpu_dev *dec = to_rkvdpu_dev(mpp_dev);
+
+	if (dec->rst_a && dec->rst_h) {
+		mpp_debug(DEBUG_RESET, "reset in\n");
+
+		/* Don't skip this or iommu won't work after reset */
+		rockchip_pmu_idle_request(mpp_dev->dev, true);
+		safe_reset(dec->rst_a);
+		safe_reset(dec->rst_h);
+		udelay(5);
+		safe_unreset(dec->rst_h);
+		safe_unreset(dec->rst_a);
+		rockchip_pmu_idle_request(mpp_dev->dev, false);
+
+		mpp_dev_write(mpp_dev, RKVDPU1_REG_DEC_INT_EN, 0);
+		dec->current_task = NULL;
+		mpp_debug(DEBUG_RESET, "reset out\n");
+	}
+
+	return 0;
+}
+
+static struct mpp_dev_ops rkvdpu_ops = {
+	.alloc_task = rockchip_mpp_rkvdpu_alloc_task,
+	.prepare = rockchip_mpp_rkvdpu_prepare,
+	.run = rockchip_mpp_rkvdpu_run,
+	.finish = rockchip_mpp_rkvdpu_finish,
+	.result = rockchip_mpp_rkvdpu_result,
+	.free_task = rockchip_mpp_rkvdpu_free_task,
+	.reset = rockchip_mpp_rkvdpu_reset,
+};
+
+static int rockchip_mpp_rkvdpu_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rockchip_rkvdpu_dev *dec_dev = NULL;
+	struct rockchip_mpp_dev *mpp_dev = NULL;
+	int ret = 0;
+
+	dec_dev = devm_kzalloc(dev, sizeof(struct rockchip_rkvdpu_dev),
+			       GFP_KERNEL);
+	if (!dec_dev)
+		return -ENOMEM;
+
+	dec_dev->data = rockchip_rkvdpu1_get_drv_data(pdev);
+	mpp_dev = &dec_dev->mpp_dev;
+	mpp_dev->variant = &dec_dev->data->dec_data;
+	ret = mpp_dev_common_probe(mpp_dev, pdev, &rkvdpu_ops);
+	if (ret)
+		return ret;
+
+	ret = devm_request_threaded_irq(dev, mpp_dev->irq, NULL, mpp_rkvdpu_isr,
+					IRQF_SHARED | IRQF_ONESHOT,
+					dev_name(dev), dec_dev);
+	if (ret) {
+		dev_err(dev, "register interrupter runtime failed\n");
+		return ret;
+	}
+
+	rockchip_mpp_rkvdpu_assign_reset(dec_dev);
+
+	ret = mpp_dev_register_node(mpp_dev, mpp_dev->variant->node_name, NULL);
+	if (ret)
+		dev_err(dev, "register char device failed: %d\n", ret);
+
+	dev_info(dev, "probing finish\n");
+
+	platform_set_drvdata(pdev, dec_dev);
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_remove(struct platform_device *pdev)
+{
+	struct rockchip_rkvdpu_dev *dec_dev = platform_get_drvdata(pdev);
+
+	mpp_dev_common_remove(&dec_dev->mpp_dev);
+
+	return 0;
+}
+
+static const struct of_device_id mpp_rkvdpu1_dt_match[] = {
+	{ .compatible = "rockchip,vpu-decoder-v1", .data = &vdpu_v1_data},
+	{ .compatible = "rockchip,vpu-decoder-pp-v1", .data = &vdpu_pp_v1_data},
+	{ .compatible = "rockchip,avs-decoder-v1", .data = &vdpu_avs_v1_data},
+	{},
+};
+
+static void *rockchip_rkvdpu1_get_drv_data(struct platform_device *pdev)
+{
+	struct vdpu1_dev_data *driver_data = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_node(mpp_rkvdpu1_dt_match,
+				      pdev->dev.of_node);
+		if (match)
+			driver_data = (struct vdpu1_dev_data *)match->data;
+	}
+	return driver_data;
+}
+
+static struct platform_driver rockchip_rkvdpu1_driver = {
+	.probe = rockchip_mpp_rkvdpu_probe,
+	.remove = rockchip_mpp_rkvdpu_remove,
+	.driver = {
+		.name = RKVDPU1_DRIVER_NAME,
+		.of_match_table = of_match_ptr(mpp_rkvdpu1_dt_match),
+	},
+};
+
+static int __init mpp_dev_rkvdpu1_init(void)
+{
+	int ret = platform_driver_register(&rockchip_rkvdpu1_driver);
+
+	if (ret) {
+		mpp_err("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit mpp_dev_rkvdpu1_exit(void)
+{
+	platform_driver_unregister(&rockchip_rkvdpu1_driver);
+}
+
+module_init(mpp_dev_rkvdpu1_init);
+module_exit(mpp_dev_rkvdpu1_exit);
+
+MODULE_DEVICE_TABLE(of, mpp_rkvdpu1_dt_match);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/video/rockchip/vpu/mpp_dev_vdpu2.c b/drivers/video/rockchip/vpu/mpp_dev_vdpu2.c
new file mode 100644
index 000000000000..b131790f72a3
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_dev_vdpu2.c
@@ -0,0 +1,577 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *		Randy Li, <ayaka@soulik.info>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <soc/rockchip/pm_domains.h>
+
+#include "mpp_debug.h"
+#include "mpp_dev_common.h"
+
+#define RKVDPU2_DRIVER_NAME		"mpp_vdpu2"
+#define RKVDPU2_NODE_NAME		"vpu-service"
+
+/* The maximum registers number of all the version */
+#define ROCKCHIP_VDPU2_REG_NUM		159
+
+/* The first register of the decoder is Reg50(0x000c8) */
+#define RKVDPU2_REG_DEC_CTRL			0x0c8
+#define RKVDPU2_REG_DEC_CTRL_INDEX		(50)
+
+#define RKVDPU2_REG_SYS_CTRL			0x0d4
+#define RKVDPU2_REG_SYS_CTRL_INDEX		(53)
+#define		RKVDPU2_GET_FORMAT(x)		((x) & 0xf)
+#define		RKVDPU2_FMT_H264D		0
+#define		RKVDPU2_FMT_MPEG4D		1
+#define		RKVDPU2_FMT_H263D		2
+#define		RKVDPU2_FMT_JPEGD		3
+#define		RKVDPU2_FMT_VC1D		4
+#define		RKVDPU2_FMT_MPEG2D		5
+#define		RKVDPU2_FMT_MPEG1D		6
+#define		RKVDPU2_FMT_VP6D		7
+#define		RKVDPU2_FMT_RESERVED		8
+#define		RKVDPU2_FMT_VP7D		9
+#define		RKVDPU2_FMT_VP8D		10
+#define		RKVDPU2_FMT_AVSD		11
+
+#define RKVDPU2_REG_DEC_INT_EN			0x0dc
+#define RKVDPU2_REG_DEC_INT_EN_INDEX		(55)
+#define		RKVDPU2_INT_TIMEOUT		BIT(13)
+#define		RKVDPU2_INT_STRM_ERROR		BIT(12)
+#define		RKVDPU2_INT_SLICE		BIT(9)
+#define		RKVDPU2_INT_ASO_ERROR		BIT(8)
+#define		RKVDPU2_INT_BUF_EMPTY		BIT(6)
+#define		RKVDPU2_INT_BUS_ERROR		BIT(5)
+#define		RKVDPU2_DEC_INT			BIT(4)
+#define		RKVDPU2_DEC_IRQ_DIS		BIT(1)
+#define		RKVDPU2_DEC_INT_RAW		BIT(0)
+
+#define RKVDPU2_REG_DEC_DEV_CTRL		0x0e4
+#define RKVDPU2_REG_DEC_DEV_CTRL_INDEX		(57)
+#define		RKVDPU2_DEC_CLOCK_GATE_EN	BIT(4)
+#define		RKVDPU2_DEC_START		BIT(0)
+
+#define RKVDPU2_REG59				0x0ec
+#define RKVDPU2_REG59_INDEX			(59)
+
+#define RKVDPU2_REG_DIR_MV_BASE                 0x0f8
+#define RKVDPU2_REG_DIR_MV_BASE_INDEX           (62)
+
+#define RKVDPU2_REG_STREAM_RLC_BASE		0x100
+#define RKVDPU2_REG_STREAM_RLC_BASE_INDEX	(64)
+
+#define to_rkvdpu_task(ctx)		\
+		container_of(ctx, struct rkvdpu_task, mpp_task)
+#define to_rkvdpu_dev(dev)		\
+		container_of(dev, struct rockchip_rkvdpu_dev, mpp_dev)
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "bit switch for vdpu2 debug information");
+
+struct rockchip_rkvdpu_dev {
+	struct rockchip_mpp_dev mpp_dev;
+
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+
+	void *current_task;
+};
+
+struct rkvdpu_task {
+	struct mpp_task mpp_task;
+
+	u32 reg[ROCKCHIP_VDPU2_REG_NUM];
+	u32 idx;
+	struct extra_info_for_iommu ext_inf;
+
+	u32 strm_base;
+	u32 irq_status;
+};
+
+/*
+ * file handle translate information
+ */
+static const char trans_tbl_default[] = {
+	61, 62, 63, 64, 131, 134, 135, 148
+};
+
+static const char trans_tbl_jpegd[] = {
+	21, 22, 61, 63, 64, 131
+};
+
+static const char trans_tbl_h264d[] = {
+	61, 63, 64, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,
+	98, 99
+};
+
+static const char trans_tbl_vc1d[] = {
+	62, 63, 64, 131, 134, 135, 145, 148
+};
+
+static const char trans_tbl_vp6d[] = {
+	61, 63, 64, 131, 136, 145
+};
+
+static const char trans_tbl_vp8d[] = {
+	61, 63, 64, 131, 136, 137, 140, 141, 142, 143, 144, 145, 146, 147, 149
+};
+
+static struct mpp_trans_info trans_rk_vdpu2[] = {
+	[RKVDPU2_FMT_H264D] = {
+		.count = sizeof(trans_tbl_h264d),
+		.table = trans_tbl_h264d,
+	},
+	[RKVDPU2_FMT_H263D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU2_FMT_MPEG4D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU2_FMT_JPEGD] = {
+		.count = sizeof(trans_tbl_jpegd),
+		.table = trans_tbl_jpegd,
+	},
+	[RKVDPU2_FMT_VC1D] = {
+		.count = sizeof(trans_tbl_vc1d),
+		.table = trans_tbl_vc1d,
+	},
+	[RKVDPU2_FMT_MPEG2D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU2_FMT_MPEG1D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU2_FMT_VP6D] = {
+		.count = sizeof(trans_tbl_vp6d),
+		.table = trans_tbl_vp6d,
+	},
+	[RKVDPU2_FMT_RESERVED] = {
+		.count = 0,
+		.table = NULL,
+	},
+	[RKVDPU2_FMT_VP7D] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVDPU2_FMT_VP8D] = {
+		.count = sizeof(trans_tbl_vp8d),
+		.table = trans_tbl_vp8d,
+	},
+	[RKVDPU2_FMT_AVSD] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+};
+
+static const struct mpp_dev_variant rkvdpu_v2_data = {
+	/* Exclude the register of the Performance counter */
+	.reg_len = 159,
+	.trans_info = trans_rk_vdpu2,
+	.node_name = RKVDPU2_NODE_NAME,
+};
+
+static void *rockchip_rkvdpu2_get_drv_data(struct platform_device *pdev);
+
+static void *rockchip_mpp_rkvdpu_alloc_task(struct mpp_session *session,
+					    void __user *src, u32 size)
+{
+	struct rkvdpu_task *task = NULL;
+	u32 reg_len;
+	u32 extinf_len;
+	u32 fmt = 0;
+	u32 dwsize = size / sizeof(u32);
+	int err = -EFAULT;
+
+	mpp_debug_enter();
+
+	task = kzalloc(sizeof(*task), GFP_KERNEL);
+	if (!task)
+		return NULL;
+
+	mpp_dev_task_init(session, &task->mpp_task);
+
+	reg_len = dwsize > ROCKCHIP_VDPU2_REG_NUM ?
+		ROCKCHIP_VDPU2_REG_NUM : dwsize;
+	extinf_len = dwsize > reg_len ? (dwsize - reg_len) * 4 : 0;
+
+	if (copy_from_user(task->reg, src, reg_len * 4)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		err = -EFAULT;
+		goto fail;
+	}
+
+	fmt = RKVDPU2_GET_FORMAT(task->reg[RKVDPU2_REG_SYS_CTRL_INDEX]);
+	if (extinf_len > 0) {
+		if (likely(fmt == RKVDPU2_FMT_JPEGD)) {
+			err = copy_from_user(&task->ext_inf,
+					     (u8 *)src + size
+					     - JPEG_IOC_EXTRA_SIZE,
+					     JPEG_IOC_EXTRA_SIZE);
+		} else {
+			u32 ext_cpy = min_t(size_t, extinf_len,
+					    sizeof(task->ext_inf));
+			err = copy_from_user(&task->ext_inf,
+					     (u32 *)src + reg_len, ext_cpy);
+		}
+
+		if (err) {
+			mpp_err("copy_from_user failed when extra info\n");
+			err = -EFAULT;
+			goto fail;
+		}
+	}
+
+	err = mpp_reg_address_translate(session->mpp, &task->mpp_task, fmt,
+					task->reg);
+	if (err) {
+		mpp_err("error: translate reg address failed.\n");
+
+		if (unlikely(debug & DEBUG_DUMP_ERR_REG))
+			mpp_debug_dump_reg_mem(task->reg,
+					       ROCKCHIP_VDPU2_REG_NUM);
+		goto fail;
+	}
+
+	if (likely(fmt == RKVDPU2_FMT_H264D)) {
+		struct mpp_mem_region *mem_region = NULL;
+		dma_addr_t iova = 0;
+		u32 offset = task->reg[RKVDPU2_REG_DIR_MV_BASE_INDEX];
+		int fd = task->reg[RKVDPU2_REG_DIR_MV_BASE_INDEX] & 0x3ff;
+
+		offset = offset >> 10 << 4;
+		mem_region = mpp_dev_task_attach_fd(&task->mpp_task, fd);
+		if (IS_ERR(mem_region)) {
+			err = PTR_ERR(mem_region);
+			goto fail;
+		}
+
+		iova = mem_region->iova;
+		mpp_debug(DEBUG_IOMMU, "DMV[%3d]: %3d => %pad + offset %10d\n",
+			  RKVDPU2_REG_DIR_MV_BASE_INDEX, fd, &iova, offset);
+		task->reg[RKVDPU2_REG_DIR_MV_BASE_INDEX] = iova + offset;
+	}
+
+	task->strm_base = task->reg[RKVDPU2_REG_STREAM_RLC_BASE_INDEX];
+
+	mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
+		  task->ext_inf.cnt, task->ext_inf.magic);
+	mpp_translate_extra_info(&task->mpp_task, &task->ext_inf, task->reg);
+
+	mpp_debug_leave();
+
+	return &task->mpp_task;
+
+fail:
+	if (unlikely(debug & DEBUG_DUMP_ERR_REG))
+		mpp_debug_dump_reg_mem(task->reg, ROCKCHIP_VDPU2_REG_NUM);
+
+	mpp_dev_task_finalize(session, &task->mpp_task);
+	kfree(task);
+	return ERR_PTR(err);
+}
+
+static int rockchip_mpp_rkvdpu_prepare(struct rockchip_mpp_dev *mpp_dev,
+				       struct mpp_task *task)
+{
+	return -EINVAL;
+}
+
+static int rockchip_mpp_rkvdpu_run(struct rockchip_mpp_dev *mpp_dev,
+				   struct mpp_task *mpp_task)
+{
+	struct rkvdpu_task *task = NULL;
+	struct rockchip_rkvdpu_dev *dec_dev = NULL;
+
+	mpp_debug_enter();
+
+	task = to_rkvdpu_task(mpp_task);
+	dec_dev = to_rkvdpu_dev(mpp_dev);
+
+	/* FIXME: spin lock here */
+	dec_dev->current_task = task;
+	/* NOTE: Only write the decoder part */
+	mpp_dev_write_seq(mpp_dev, RKVDPU2_REG_DEC_CTRL,
+			  &task->reg[RKVDPU2_REG_DEC_CTRL_INDEX],
+			  RKVDPU2_REG_DEC_DEV_CTRL_INDEX
+			  - RKVDPU2_REG_DEC_CTRL_INDEX);
+
+	mpp_dev_write_seq(mpp_dev, RKVDPU2_REG59,
+			  &task->reg[RKVDPU2_REG59_INDEX],
+			  mpp_dev->variant->reg_len - RKVDPU2_REG59_INDEX);
+	/* Flush the registers */
+	wmb();
+	mpp_dev_write(mpp_dev, RKVDPU2_REG_DEC_DEV_CTRL,
+		      task->reg[RKVDPU2_REG_DEC_DEV_CTRL_INDEX]
+		      | RKVDPU2_DEC_START);
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_finish(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task)
+{
+	struct rkvdpu_task *task = to_rkvdpu_task(mpp_task);
+
+	mpp_debug_enter();
+
+	/* NOTE: Only read the decoder part */
+	mpp_dev_read_seq(mpp_dev, RKVDPU2_REG_DEC_CTRL,
+			 &task->reg[RKVDPU2_REG_DEC_CTRL_INDEX],
+			 mpp_dev->variant->reg_len
+			 - RKVDPU2_REG_DEC_CTRL_INDEX);
+
+	task->reg[RKVDPU2_REG_DEC_INT_EN_INDEX] = task->irq_status;
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_result(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task,
+				      u32 __user *dst, u32 size)
+{
+	struct rkvdpu_task *task = to_rkvdpu_task(mpp_task);
+
+	/* FIXME may overflow the kernel */
+	if (copy_to_user(dst, task->reg, size)) {
+		mpp_err("copy_to_user failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_free_task(struct mpp_session *session,
+					 struct mpp_task *mpp_task)
+{
+	struct rkvdpu_task *task = to_rkvdpu_task(mpp_task);
+
+	mpp_dev_task_finalize(session, mpp_task);
+	kfree(task);
+
+	return 0;
+}
+
+static irqreturn_t mpp_rkvdpu_isr(int irq, void *dev_id)
+{
+	struct rockchip_rkvdpu_dev *dec_dev = dev_id;
+	struct rockchip_mpp_dev *mpp_dev = &dec_dev->mpp_dev;
+	struct rkvdpu_task *task = NULL;
+	struct mpp_task *mpp_task = NULL;
+	u32 irq_status;
+	u32 err_mask;
+
+	irq_status = mpp_dev_read(mpp_dev, RKVDPU2_REG_DEC_INT_EN);
+	if (!(irq_status & RKVDPU2_DEC_INT_RAW))
+		return IRQ_NONE;
+
+	mpp_dev_write(mpp_dev, RKVDPU2_REG_DEC_INT_EN, 0);
+	mpp_dev_write(mpp_dev, RKVDPU2_REG_DEC_DEV_CTRL,
+		      RKVDPU2_DEC_CLOCK_GATE_EN);
+
+	/* FIXME use a spin lock here */
+	task = (struct rkvdpu_task *)dec_dev->current_task;
+	if (!task) {
+		dev_err(dec_dev->mpp_dev.dev, "no current task\n");
+		return IRQ_HANDLED;
+	}
+
+	mpp_task = &task->mpp_task;
+	mpp_debug_time_diff(mpp_task);
+	task->irq_status = irq_status;
+	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n",
+		  task->irq_status);
+
+	err_mask = RKVDPU2_INT_TIMEOUT
+		| RKVDPU2_INT_STRM_ERROR
+		| RKVDPU2_INT_ASO_ERROR
+		| RKVDPU2_INT_BUF_EMPTY
+		| RKVDPU2_INT_BUS_ERROR;
+
+	if (err_mask & task->irq_status)
+		atomic_set(&mpp_dev->reset_request, 1);
+
+	mpp_dev_task_finish(mpp_task->session, mpp_task);
+
+	mpp_debug_leave();
+	return IRQ_HANDLED;
+}
+
+static int rockchip_mpp_rkvdpu_assign_reset(struct rockchip_rkvdpu_dev *dec_dev)
+{
+	struct rockchip_mpp_dev *mpp_dev = &dec_dev->mpp_dev;
+
+	/* TODO: use devm_reset_control_get_share() instead */
+	dec_dev->rst_a = devm_reset_control_get(mpp_dev->dev, "video_a");
+	dec_dev->rst_h = devm_reset_control_get(mpp_dev->dev, "video_h");
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_a)) {
+		mpp_err("No aclk reset resource define\n");
+		dec_dev->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(dec_dev->rst_h)) {
+		mpp_err("No hclk reset resource define\n");
+		dec_dev->rst_h = NULL;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_reset(struct rockchip_mpp_dev *mpp_dev)
+{
+	struct rockchip_rkvdpu_dev *dec = to_rkvdpu_dev(mpp_dev);
+
+	if (dec->rst_a && dec->rst_h) {
+		mpp_debug(DEBUG_RESET, "reset in\n");
+
+		safe_reset(dec->rst_a);
+		safe_reset(dec->rst_h);
+		udelay(5);
+		safe_unreset(dec->rst_h);
+		safe_unreset(dec->rst_a);
+
+		mpp_dev_write(mpp_dev, RKVDPU2_REG_DEC_DEV_CTRL, 0);
+		mpp_dev_write(mpp_dev, RKVDPU2_REG_DEC_INT_EN, 0);
+		dec->current_task = NULL;
+		mpp_debug(DEBUG_RESET, "reset out\n");
+	}
+
+	return 0;
+}
+
+static struct mpp_dev_ops rkvdpu_ops = {
+	.alloc_task = rockchip_mpp_rkvdpu_alloc_task,
+	.prepare = rockchip_mpp_rkvdpu_prepare,
+	.run = rockchip_mpp_rkvdpu_run,
+	.finish = rockchip_mpp_rkvdpu_finish,
+	.result = rockchip_mpp_rkvdpu_result,
+	.free_task = rockchip_mpp_rkvdpu_free_task,
+	.reset = rockchip_mpp_rkvdpu_reset,
+};
+
+static int rockchip_mpp_rkvdpu_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rockchip_rkvdpu_dev *dec_dev = NULL;
+	struct rockchip_mpp_dev *mpp_dev = NULL;
+	int ret = 0;
+
+	dec_dev = devm_kzalloc(dev, sizeof(struct rockchip_rkvdpu_dev),
+			       GFP_KERNEL);
+	if (!dec_dev)
+		return -ENOMEM;
+
+	mpp_dev = &dec_dev->mpp_dev;
+	mpp_dev->variant = rockchip_rkvdpu2_get_drv_data(pdev);
+	ret = mpp_dev_common_probe(mpp_dev, pdev, &rkvdpu_ops);
+	if (ret)
+		return ret;
+
+	ret = devm_request_threaded_irq(dev, mpp_dev->irq, NULL, mpp_rkvdpu_isr,
+					IRQF_SHARED | IRQF_ONESHOT,
+					dev_name(dev), dec_dev);
+	if (ret) {
+		dev_err(dev, "register interrupter runtime failed\n");
+		return ret;
+	}
+
+	rockchip_mpp_rkvdpu_assign_reset(dec_dev);
+
+	ret = mpp_dev_register_node(mpp_dev, mpp_dev->variant->node_name, NULL);
+	if (ret)
+		dev_err(dev, "register char device failed: %d\n", ret);
+
+	dev_info(dev, "probing finish\n");
+
+	platform_set_drvdata(pdev, dec_dev);
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvdpu_remove(struct platform_device *pdev)
+{
+	struct rockchip_rkvdpu_dev *dec_dev = platform_get_drvdata(pdev);
+
+	mpp_dev_common_remove(&dec_dev->mpp_dev);
+
+	return 0;
+}
+
+static const struct of_device_id mpp_rkvdpu2_dt_match[] = {
+	{ .compatible = "rockchip,vpu-decoder-v2", .data = &rkvdpu_v2_data},
+	{},
+};
+
+static void *rockchip_rkvdpu2_get_drv_data(struct platform_device *pdev)
+{
+	struct mpp_dev_variant *driver_data = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_node(mpp_rkvdpu2_dt_match, pdev->dev.of_node);
+		if (match)
+			driver_data = (struct mpp_dev_variant *)match->data;
+	}
+	return driver_data;
+}
+
+static struct platform_driver rockchip_rkvdpu2_driver = {
+	.probe = rockchip_mpp_rkvdpu_probe,
+	.remove = rockchip_mpp_rkvdpu_remove,
+	.driver = {
+		.name = RKVDPU2_DRIVER_NAME,
+		.of_match_table = of_match_ptr(mpp_rkvdpu2_dt_match),
+	},
+};
+
+static int __init mpp_dev_rkvdpu2_init(void)
+{
+	int ret = platform_driver_register(&rockchip_rkvdpu2_driver);
+
+	if (ret) {
+		mpp_err("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit mpp_dev_rkvdpu2_exit(void)
+{
+	platform_driver_unregister(&rockchip_rkvdpu2_driver);
+}
+
+module_init(mpp_dev_rkvdpu2_init);
+module_exit(mpp_dev_rkvdpu2_exit);
+
+MODULE_DEVICE_TABLE(of, mpp_rkvdpu2_dt_match);
+MODULE_LICENSE("GPL v2");

From be2e3960be5757b170d0e581bc3ec6823b94176b Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Thu, 30 Nov 2017 03:25:51 +0800
Subject: [PATCH] video: rockchip/mpp_device: add VPU encoder

It supports the encoder in both VPU1 and VPU2.

TODO:
1. share node

Change-Id: I2d55e89e38df388b25abc30310ada9ec621a5a60
Signed-off-by: ayaka <ayaka@soulik.info>
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 drivers/video/rockchip/vpu/Kconfig         |  14 +
 drivers/video/rockchip/vpu/Makefile        |   4 +
 drivers/video/rockchip/vpu/mpp_dev_vepu.c  | 368 ----------------------
 drivers/video/rockchip/vpu/mpp_dev_vepu.h  |  47 ---
 drivers/video/rockchip/vpu/mpp_dev_vepu1.c | 481 +++++++++++++++++++++++++++++
 drivers/video/rockchip/vpu/mpp_dev_vepu2.c | 478 ++++++++++++++++++++++++++++
 6 files changed, 977 insertions(+), 415 deletions(-)
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_vepu.c
 delete mode 100644 drivers/video/rockchip/vpu/mpp_dev_vepu.h
 create mode 100644 drivers/video/rockchip/vpu/mpp_dev_vepu1.c
 create mode 100644 drivers/video/rockchip/vpu/mpp_dev_vepu2.c

diff --git a/drivers/video/rockchip/vpu/Kconfig b/drivers/video/rockchip/vpu/Kconfig
index 091707cfc440..691ddc3bcd14 100644
--- a/drivers/video/rockchip/vpu/Kconfig
+++ b/drivers/video/rockchip/vpu/Kconfig
@@ -29,10 +29,24 @@ config ROCKCHIP_MPP_VDPU1_DEVICE
 	help
 	  rockchip mpp vpu decoder v1.
 
+config ROCKCHIP_MPP_VEPU1_DEVICE
+	tristate "VPU encoder v1 device driver"
+	depends on ROCKCHIP_MPP_DEVICE
+	default n
+	help
+	  rockchip mpp vpu encoder v1.
+
 config ROCKCHIP_MPP_VDPU2_DEVICE
 	tristate "VPU decoder v2 device driver"
 	depends on ROCKCHIP_MPP_DEVICE
 	default n
 	help
 	  rockchip mpp vpu decoder v2.
+
+config ROCKCHIP_MPP_VEPU2_DEVICE
+	tristate "VPU encoder v2 device driver"
+	depends on ROCKCHIP_MPP_DEVICE
+	default n
+	help
+	  rockchip mpp vpu encoder v2.
 endmenu
diff --git a/drivers/video/rockchip/vpu/Makefile b/drivers/video/rockchip/vpu/Makefile
index 37fc13533200..06a9c58c92cb 100644
--- a/drivers/video/rockchip/vpu/Makefile
+++ b/drivers/video/rockchip/vpu/Makefile
@@ -4,9 +4,13 @@ rk-mpp-device-objs := mpp_dev_common.o mpp_iommu_dma.o
 rk-mpp-vdec-objs := mpp_dev_rkvdec.o
 rk-mpp-vdpu1-objs := mpp_dev_vdpu1.o
 rk-mpp-vdpu2-objs := mpp_dev_vdpu2.o
+rk-mpp-vepu1-objs := mpp_dev_vepu1.o
+rk-mpp-vepu2-objs := mpp_dev_vepu2.o
 
 obj-$(CONFIG_ROCKCHIP_MPP_SERVICE) += rk-mpp-service.o
 obj-$(CONFIG_ROCKCHIP_MPP_DEVICE) += rk-mpp-device.o
 obj-$(CONFIG_ROCKCHIP_MPP_VDEC_DEVICE) += rk-mpp-vdec.o
 obj-$(CONFIG_ROCKCHIP_MPP_VDPU1_DEVICE) += rk-mpp-vdpu1.o
+obj-$(CONFIG_ROCKCHIP_MPP_VEPU1_DEVICE) += rk-mpp-vepu1.o
 obj-$(CONFIG_ROCKCHIP_MPP_VDPU2_DEVICE) += rk-mpp-vdpu2.o
+obj-$(CONFIG_ROCKCHIP_MPP_VEPU2_DEVICE) += rk-mpp-vepu2.o
diff --git a/drivers/video/rockchip/vpu/mpp_dev_vepu.c b/drivers/video/rockchip/vpu/mpp_dev_vepu.c
deleted file mode 100644
index 18e470c46755..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_vepu.c
+++ /dev/null
@@ -1,368 +0,0 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *	   Alpha Lin, alpha.lin@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/mfd/syscon.h>
-#include <linux/types.h>
-#include <linux/of_platform.h>
-#include <linux/regmap.h>
-#include <linux/reset.h>
-#include <linux/rockchip/grf.h>
-#include <linux/slab.h>
-#include <linux/uaccess.h>
-
-#include "vpu_iommu_ops.h"
-#include "mpp_dev_common.h"
-#include "mpp_dev_vepu.h"
-#include "mpp_service.h"
-
-#define to_vepu_ctx(ctx)		\
-		container_of(ctx, struct vepu_ctx, ictx)
-#define to_vepu_dev(dev)		\
-		container_of(dev, struct rockchip_vepu_dev, idev)
-
-#define VEPU_REG_INTERRUPT		0x1b4
-#define VEPU_REG_ENC_START		0x19c
-#define		VEPU_ENC_GET_FORMAT(x)		(((x) >> 4) & 0x3)
-#define		VEPU_ENC_FMT_VP8E		1
-#define		VEPU_ENC_ENABLE			BIT(0)
-
-/*
- * file handle translate information
- */
-static const char trans_tbl_default[] = {
-	77, 78, 56, 57, 63, 64, 48, 49, 50, 81
-};
-
-static const char trans_tbl_vp8e[] = {
-	77, 78, 56, 57, 63, 64, 48, 49, 50, 76, 106, 108, 81, 80, 44, 45, 27
-};
-
-static struct mpp_trans_info trans_vepu[2] = {
-	[0] = {
-		.count = sizeof(trans_tbl_default),
-		.table = trans_tbl_default,
-	},
-	[1] = {
-		.count = sizeof(trans_tbl_vp8e),
-		.table = trans_tbl_vp8e,
-	},
-};
-
-static struct mpp_ctx *rockchip_mpp_vepu_init(struct rockchip_mpp_dev *mpp,
-					      struct mpp_session *session,
-					      void __user *src, u32 size)
-{
-	struct vepu_ctx *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
-	u32 reg_len;
-	u32 extinf_len;
-	u32 fmt = 0;
-	int trans_idx = 0;
-	u32 dwsize = size / sizeof(u32);
-
-	mpp_debug_enter();
-
-	if (!ctx)
-		return NULL;
-
-	mpp_dev_common_ctx_init(mpp, &ctx->ictx);
-
-	ctx->ictx.session = session;
-
-	reg_len = dwsize > ROCKCHIP_VEPU_REG_LEN ?
-		  ROCKCHIP_VEPU_REG_LEN : dwsize;
-	extinf_len = dwsize > reg_len ? (dwsize - reg_len) * 4 : 0;
-
-	if (copy_from_user(ctx->reg, src, reg_len * 4)) {
-		mpp_err("error: copy_from_user failed in reg_init\n");
-		kfree(ctx);
-		return NULL;
-	}
-
-	if (extinf_len > 0) {
-		u32 ext_cpy = min_t(size_t, extinf_len, sizeof(ctx->ext_inf));
-
-		if (copy_from_user(&ctx->ext_inf, (u8 *)src +
-				   reg_len * sizeof(u32),
-				   ext_cpy)) {
-			mpp_err("copy_from_user failed when extra info\n");
-			kfree(ctx);
-			return NULL;
-		}
-	}
-
-	fmt = VEPU_ENC_GET_FORMAT(ctx->reg[VEPU_REG_ENC_START / 4]);
-	if (fmt == VEPU_ENC_FMT_VP8E)
-		trans_idx = 1;
-
-	if (mpp_reg_address_translate(mpp, ctx->reg, &ctx->ictx,
-				      trans_idx) < 0) {
-		mpp_err("error: translate reg address failed.\n");
-
-		if (unlikely(mpp_dev_debug & DEBUG_DUMP_ERR_REG))
-			mpp_dump_reg_mem(ctx->reg, ROCKCHIP_VEPU_REG_LEN);
-
-		mpp_dev_common_ctx_deinit(mpp, &ctx->ictx);
-		kfree(ctx);
-
-		return NULL;
-	}
-
-	mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
-		  ctx->ext_inf.cnt, ctx->ext_inf.magic);
-
-	mpp_translate_extra_info(&ctx->ictx, &ctx->ext_inf, ctx->reg);
-
-	mpp_debug_leave();
-
-	return &ctx->ictx;
-}
-
-static int rockchip_mpp_vepu_reset_init(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-
-	mpp_debug(DEBUG_RESET, "reset init in:\n");
-	enc->rst_a = devm_reset_control_get(mpp->dev, "video_a");
-	enc->rst_h = devm_reset_control_get(mpp->dev, "video_h");
-
-	if (IS_ERR_OR_NULL(enc->rst_a)) {
-		mpp_err("No aclk reset resource define\n");
-		enc->rst_a = NULL;
-	}
-
-	if (IS_ERR_OR_NULL(enc->rst_h)) {
-		mpp_err("No hclk reset resource define\n");
-		enc->rst_h = NULL;
-	}
-
-	return 0;
-}
-
-static int rockchip_mpp_vepu_reset(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-
-	if (enc->rst_a && enc->rst_h) {
-		mpp_debug(DEBUG_RESET, "reset in\n");
-		reset_control_assert(enc->rst_a);
-		reset_control_assert(enc->rst_h);
-
-		udelay(1);
-
-		reset_control_deassert(enc->rst_a);
-		reset_control_deassert(enc->rst_h);
-		mpp_debug(DEBUG_RESET, "reset out\n");
-	}
-	return 0;
-}
-
-static int rockchip_mpp_vepu_run(struct rockchip_mpp_dev *mpp)
-{
-	struct vepu_ctx *ctx =
-			       to_vepu_ctx(mpp_srv_get_current_ctx(mpp->srv));
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-	int i;
-
-	mpp_debug_enter();
-
-	/*
-	 * before encoding running, we have to switch grf ctrl bit to ensure
-	 * ip inner-sram controlled by vepu
-	 */
-#ifdef CONFIG_MFD_SYSCON
-	if (enc->grf) {
-		u32 raw;
-		u32 bits = BIT(enc->mode_bit);
-
-		regmap_read(enc->grf, enc->mode_ctrl, &raw);
-		regmap_write(enc->grf, enc->mode_ctrl,
-			     (raw & (~bits)) | (bits << 16));
-	}
-#endif
-
-	/*
-	 * NOTE: encoder need to setup mode first
-	 */
-	mpp_write(mpp,
-		  ctx->reg[VEPU_REG_ENC_START / 4] & (~VEPU_ENC_ENABLE),
-		  VEPU_REG_ENC_START);
-
-	for (i = 0; i < ROCKCHIP_VEPU_REG_LEN; i++) {
-		if (i * 4 != VEPU_REG_ENC_START)
-			mpp_write_relaxed(mpp, ctx->reg[i], i * 4);
-	}
-
-	mpp_write(mpp, ctx->reg[VEPU_REG_ENC_START / 4], VEPU_REG_ENC_START);
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static int rockchip_mpp_vepu_done(struct rockchip_mpp_dev *mpp)
-{
-	struct mpp_ctx *ictx = mpp_srv_get_current_ctx(mpp->srv);
-	struct vepu_ctx *ctx;
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-	int i;
-
-	mpp_debug_enter();
-
-	if (IS_ERR_OR_NULL(ictx)) {
-		mpp_err("Invaidate context to save result\n");
-		return -1;
-	}
-
-	ctx = to_vepu_ctx(ictx);
-
-	for (i = 0; i < ROCKCHIP_VEPU_REG_LEN; i++)
-		ctx->reg[i] = mpp_read(mpp, i * 4);
-
-	ctx->reg[VEPU_REG_INTERRUPT / 4] = enc->irq_status;
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static int rockchip_mpp_vepu_irq(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-
-	enc->irq_status = mpp_read(mpp, VEPU_REG_INTERRUPT);
-
-	mpp_debug_enter();
-
-	if (enc->irq_status == 0)
-		return -1;
-
-	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n", enc->irq_status);
-	mpp_write(mpp, 0, VEPU_REG_INTERRUPT);
-
-	mpp_debug_leave();
-
-	return 0;
-}
-
-static int rockchip_mpp_vepu_result(struct rockchip_mpp_dev *mpp,
-				    struct mpp_ctx *ictx, u32 __user *dst)
-{
-	struct vepu_ctx *ctx = to_vepu_ctx(ictx);
-
-	if (copy_to_user(dst, ctx->reg, ROCKCHIP_VEPU_REG_LEN * 4)) {
-		mpp_err("copy_to_user failed\n");
-		return -1;
-	}
-
-	return 0;
-}
-
-struct mpp_dev_ops vepu_ops = {
-	.init = rockchip_mpp_vepu_init,
-	.run = rockchip_mpp_vepu_run,
-	.done = rockchip_mpp_vepu_done,
-	.irq = rockchip_mpp_vepu_irq,
-	.result = rockchip_mpp_vepu_result,
-};
-
-static void rockchip_mpp_vepu_power_on(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-
-	if (enc->aclk)
-		clk_prepare_enable(enc->aclk);
-	if (enc->hclk)
-		clk_prepare_enable(enc->hclk);
-	if (enc->cclk)
-		clk_prepare_enable(enc->cclk);
-}
-
-static void rockchip_mpp_vepu_power_off(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-
-	if (enc->hclk)
-		clk_disable_unprepare(enc->hclk);
-	if (enc->aclk)
-		clk_disable_unprepare(enc->aclk);
-	if (enc->cclk)
-		clk_disable_unprepare(enc->cclk);
-}
-
-static int rockchip_mpp_vepu_probe(struct rockchip_mpp_dev *mpp)
-{
-	struct rockchip_vepu_dev *enc = to_vepu_dev(mpp);
-	struct device_node *np = mpp->dev->of_node;
-
-	enc->idev.ops = &vepu_ops;
-
-	enc->aclk = devm_clk_get(mpp->dev, "aclk_vcodec");
-	if (IS_ERR_OR_NULL(enc->aclk)) {
-		dev_err(mpp->dev, "failed on clk_get aclk\n");
-		goto fail;
-	}
-
-	enc->hclk = devm_clk_get(mpp->dev, "hclk_vcodec");
-	if (IS_ERR_OR_NULL(enc->hclk)) {
-		dev_err(mpp->dev, "failed on clk_get hclk\n");
-		goto fail;
-	}
-
-	enc->cclk = devm_clk_get(mpp->dev, "clk_core");
-	if (IS_ERR_OR_NULL(enc->cclk)) {
-		dev_err(mpp->dev, "failed on clk_get cclk\n");
-		goto fail;
-	}
-
-	if (of_property_read_bool(np, "mode_ctrl")) {
-		of_property_read_u32(np, "mode_bit", &enc->mode_bit);
-		of_property_read_u32(np, "mode_ctrl", &enc->mode_ctrl);
-
-#ifdef COFNIG_MFD_SYSCON
-		enc->grf = syscon_regmap_lookup_by_phandle(np, "rockchip,grf");
-		if (IS_ERR_OR_NULL(enc->grf)) {
-			enc->grf = NULL;
-			mpp_err("can't find vpu grf property\n");
-			goto fail;
-		}
-#endif
-	}
-
-	rockchip_mpp_vepu_reset_init(mpp);
-
-	return 0;
-
-fail:
-	return -1;
-}
-
-static void rockchip_mpp_vepu_remove(struct rockchip_mpp_dev *mpp)
-{
-}
-
-const struct rockchip_mpp_dev_variant vepu_variant = {
-	.data_len = sizeof(struct rockchip_vepu_dev),
-	.reg_len = ROCKCHIP_VEPU_REG_LEN,
-	.trans_info = trans_vepu,
-	.mmu_dev_dts_name = NULL,
-	.hw_probe = rockchip_mpp_vepu_probe,
-	.hw_remove = rockchip_mpp_vepu_remove,
-	.power_on = rockchip_mpp_vepu_power_on,
-	.power_off = rockchip_mpp_vepu_power_off,
-	.reset = rockchip_mpp_vepu_reset,
-};
-EXPORT_SYMBOL(vepu_variant);
diff --git a/drivers/video/rockchip/vpu/mpp_dev_vepu.h b/drivers/video/rockchip/vpu/mpp_dev_vepu.h
deleted file mode 100644
index 8bfbe5ab2d8b..000000000000
--- a/drivers/video/rockchip/vpu/mpp_dev_vepu.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/**
- * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
- *	   Alpha Lin, alpha.lin@rock-chips.com
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- */
-
-#ifndef __ROCKCHIP_MPP_DEV_VEPU_H
-#define __ROCKCHIP_MPP_DEV_VEPU_H
-
-#define ROCKCHIP_VEPU_REG_LEN		184
-
-struct regmap;
-
-struct rockchip_vepu_dev {
-	struct rockchip_mpp_dev idev;
-
-	u32 irq_status;
-
-	struct clk *aclk;
-	struct clk *hclk;
-	struct clk *cclk;
-
-	struct reset_control *rst_a;
-	struct reset_control *rst_h;
-
-	u32 mode_bit;
-	u32 mode_ctrl;
-	struct regmap *grf;
-};
-
-struct vepu_ctx {
-	struct mpp_ctx ictx;
-
-	u32 reg[ROCKCHIP_VEPU_REG_LEN];
-	struct extra_info_for_iommu ext_inf;
-};
-
-#endif
diff --git a/drivers/video/rockchip/vpu/mpp_dev_vepu1.c b/drivers/video/rockchip/vpu/mpp_dev_vepu1.c
new file mode 100644
index 000000000000..64619092c792
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_dev_vepu1.c
@@ -0,0 +1,481 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *		Randy Li, <ayaka@soulik.info>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <soc/rockchip/pm_domains.h>
+
+#include "mpp_debug.h"
+#include "mpp_dev_common.h"
+
+#define RKVEPU1_DRIVER_NAME		"mpp_vepu1"
+#define RKVEPU1_NODE_NAME		"vepu"
+
+/* The maximum registers number of all the version */
+#define ROCKCHIP_VEPU1_REG_NUM			(164)
+
+#define RKVEPU1_REG_INT				0x004
+#define RKVEPU1_REG_INT_INDEX			(1)
+#define		RKVEPU1_INT_SLICE		BIT(8)
+#define		RKVEPU1_INT_TIMEOUT		BIT(6)
+#define		RKVEPU1_INT_BUF_FULL		BIT(5)
+#define		RKVEPU1_INT_RESET		BIT(4)
+#define		RKVEPU1_INT_BUS_ERROR		BIT(3)
+#define		RKVEPU1_INT_RDY			BIT(2)
+#define		RKVEPU1_IRQ_DIS			BIT(1)
+#define		RKVEPU1_INT_RAW			BIT(0)
+
+#define RKVEPU1_REG_AXI_CTRL			0x008
+#define RKVEPU1_REG_AXI_CTRL_INDEX		(2)
+#define		RKVEPU1_CLOCK_GATE_EN		BIT(4)
+
+#define RKVEPU1_REG_ENC_CTRL			0x038
+#define RKVEPU1_REG_ENC_CTRL_INDEX		(14)
+#define		RKVEPU1_INT_TIMEOUT_EN		BIT(31)
+#define		RKVEPU1_INT_SLICE_EN		BIT(28)
+#define		RKVEPU1_GET_FORMAT(x)		(((x) >> 1) & 0x3)
+#define		RKVEPU1_FMT_RESERVED		(0)
+#define		RKVEPU1_FMT_VP8E		(1)
+#define		RKVEPU1_FMT_JPEGE		(2)
+#define		RKVEPU1_FMT_H264E		(3)
+#define		RKVEPU1_ENC_START		BIT(0)
+
+#define RKVEPU1_REG_INPUT_CTRL			0x03c
+#define RKVEPU1_REG_INPUT_CTRL_INDEX		(15)
+
+#define to_rkvepu_task(ctx)		\
+		container_of(ctx, struct rkvepu_task, mpp_task)
+#define to_rkvepu_dev(dev)		\
+		container_of(dev, struct rockchip_rkvepu_dev, mpp_dev)
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "bit switch for vepu1 debug information");
+
+struct rockchip_rkvepu_dev {
+	struct rockchip_mpp_dev mpp_dev;
+
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+
+	void *current_task;
+};
+
+struct rkvepu_task {
+	struct mpp_task mpp_task;
+
+	u32 reg[ROCKCHIP_VEPU1_REG_NUM];
+	u32 idx;
+	struct extra_info_for_iommu ext_inf;
+
+	u32 strm_base;
+	u32 irq_status;
+};
+
+/*
+ * file handle translate information
+ */
+static const char trans_tbl_default[] = {
+	5, 6, 7, 8, 9, 10, 11, 12, 13, 51
+};
+
+static const char trans_tbl_vp8e[] = {
+	5, 6, 7, 8, 9, 10, 11, 12, 13, 16, 17, 26, 51, 52, 58, 59
+};
+
+static struct mpp_trans_info trans_rk_vepu1[] = {
+	[RKVEPU1_FMT_RESERVED] = {
+		.count = 0,
+		.table = NULL,
+	},
+	[RKVEPU1_FMT_VP8E] = {
+		.count = sizeof(trans_tbl_vp8e),
+		.table = trans_tbl_vp8e,
+	},
+	[RKVEPU1_FMT_JPEGE] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVEPU1_FMT_H264E] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+};
+
+static const struct mpp_dev_variant rkvepu_v1_data = {
+	.reg_len = ROCKCHIP_VEPU1_REG_NUM,
+	.trans_info = trans_rk_vepu1,
+	.node_name = RKVEPU1_NODE_NAME,
+};
+
+static void *rockchip_rkvepu1_get_drv_data(struct platform_device *pdev);
+
+static void *rockchip_mpp_rkvepu_alloc_task(struct mpp_session *session,
+					    void __user *src, u32 size)
+{
+	struct rkvepu_task *task = NULL;
+	u32 reg_len;
+	u32 extinf_len;
+	u32 fmt = 0;
+	u32 dwsize = size / sizeof(u32);
+	int err = -EFAULT;
+
+	mpp_debug_enter();
+
+	task = kzalloc(sizeof(*task), GFP_KERNEL);
+	if (!task)
+		return NULL;
+
+	mpp_dev_task_init(session, &task->mpp_task);
+
+	reg_len = dwsize > ROCKCHIP_VEPU1_REG_NUM ?
+		ROCKCHIP_VEPU1_REG_NUM : dwsize;
+	extinf_len = dwsize > reg_len ? (dwsize - reg_len) * 4 : 0;
+
+	if (copy_from_user(task->reg, src, reg_len * 4)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		err = -EFAULT;
+		goto fail;
+	}
+
+	fmt = RKVEPU1_GET_FORMAT(task->reg[RKVEPU1_REG_ENC_CTRL_INDEX]);
+	if (extinf_len > 0) {
+		if (likely(fmt == RKVEPU1_FMT_JPEGE)) {
+			err = copy_from_user(&task->ext_inf,
+					     (u8 *)src + size
+					     - JPEG_IOC_EXTRA_SIZE,
+					     JPEG_IOC_EXTRA_SIZE);
+		} else {
+			u32 ext_cpy = min_t(size_t, extinf_len,
+					    sizeof(task->ext_inf));
+			err = copy_from_user(&task->ext_inf,
+					     (u32 *)src + reg_len, ext_cpy);
+		}
+
+		if (err) {
+			mpp_err("copy_from_user failed when extra info\n");
+			err = -EFAULT;
+			goto fail;
+		}
+	}
+
+	err = mpp_reg_address_translate(session->mpp, &task->mpp_task, fmt,
+					task->reg);
+	if (err) {
+		mpp_err("error: translate reg address failed.\n");
+
+		if (unlikely(debug & DEBUG_DUMP_ERR_REG))
+			mpp_debug_dump_reg_mem(task->reg,
+					       ROCKCHIP_VEPU1_REG_NUM);
+		goto fail;
+	}
+
+	mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
+		  task->ext_inf.cnt, task->ext_inf.magic);
+	mpp_translate_extra_info(&task->mpp_task, &task->ext_inf, task->reg);
+
+	mpp_debug_leave();
+
+	return &task->mpp_task;
+
+fail:
+	mpp_dev_task_finalize(session, &task->mpp_task);
+	kfree(task);
+	return ERR_PTR(err);
+}
+
+static int rockchip_mpp_rkvepu_prepare(struct rockchip_mpp_dev *mpp_dev,
+				       struct mpp_task *task)
+{
+	return -EINVAL;
+}
+
+static int rockchip_mpp_rkvepu_run(struct rockchip_mpp_dev *mpp_dev,
+				   struct mpp_task *mpp_task)
+{
+	struct rkvepu_task *task = NULL;
+	struct rockchip_rkvepu_dev *enc_dev = NULL;
+
+	mpp_debug_enter();
+
+	task = to_rkvepu_task(mpp_task);
+	enc_dev = to_rkvepu_dev(mpp_dev);
+
+	/* FIXME: spin lock here */
+	enc_dev->current_task = task;
+
+	mpp_dev_write_seq(mpp_dev, RKVEPU1_REG_AXI_CTRL,
+			  &task->reg[RKVEPU1_REG_AXI_CTRL_INDEX],
+			  RKVEPU1_REG_ENC_CTRL_INDEX
+			  - RKVEPU1_REG_AXI_CTRL_INDEX);
+
+	mpp_dev_write_seq(mpp_dev, RKVEPU1_REG_INPUT_CTRL,
+			  &task->reg[RKVEPU1_REG_INPUT_CTRL_INDEX],
+			  mpp_dev->variant->reg_len
+			  - RKVEPU1_REG_INPUT_CTRL_INDEX);
+	/* Flush the registers */
+	wmb();
+	mpp_dev_write(mpp_dev, RKVEPU1_REG_ENC_CTRL,
+		      task->reg[RKVEPU1_REG_ENC_CTRL_INDEX]
+		      | RKVEPU1_ENC_START);
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_finish(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task)
+{
+	struct rkvepu_task *task = to_rkvepu_task(mpp_task);
+
+	mpp_debug_enter();
+
+	task->reg[RKVEPU1_REG_INT_INDEX] = task->irq_status;
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_result(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task,
+				      u32 __user *dst, u32 size)
+{
+	struct rkvepu_task *task = to_rkvepu_task(mpp_task);
+
+	/* FIXME may overflow the kernel */
+	if (copy_to_user(dst, task->reg, size)) {
+		mpp_err("copy_to_user failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_free_task(struct mpp_session *session,
+					 struct mpp_task *mpp_task)
+{
+	struct rkvepu_task *task = to_rkvepu_task(mpp_task);
+
+	mpp_dev_task_finalize(session, mpp_task);
+	kfree(task);
+
+	return 0;
+}
+
+static irqreturn_t mpp_rkvepu_isr(int irq, void *dev_id)
+{
+	struct rockchip_rkvepu_dev *enc_dev = dev_id;
+	struct rockchip_mpp_dev *mpp_dev = &enc_dev->mpp_dev;
+	struct rkvepu_task *task = NULL;
+	struct mpp_task *mpp_task = NULL;
+	u32 irq_status;
+	u32 err_mask;
+
+	irq_status = mpp_dev_read(mpp_dev, RKVEPU1_REG_INT);
+	if (!(irq_status & RKVEPU1_INT_RAW))
+		return IRQ_NONE;
+
+	mpp_dev_write(mpp_dev, RKVEPU1_REG_INT, 0);
+	/* FIXME use a spin lock here */
+	task = (struct rkvepu_task *)enc_dev->current_task;
+	if (!task) {
+		dev_err(enc_dev->mpp_dev.dev, "no current task\n");
+		return IRQ_HANDLED;
+	}
+
+	mpp_task = &task->mpp_task;
+	mpp_debug_time_diff(mpp_task);
+
+	task->irq_status = irq_status;
+	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n",
+		  task->irq_status);
+
+	err_mask = RKVEPU1_INT_TIMEOUT
+		| RKVEPU1_INT_BUF_FULL
+		| RKVEPU1_INT_BUS_ERROR;
+
+	if (err_mask & task->irq_status)
+		atomic_set(&mpp_dev->reset_request, 1);
+
+	mpp_dev_task_finish(mpp_task->session, mpp_task);
+
+	mpp_debug_leave();
+	return IRQ_HANDLED;
+
+	return IRQ_NONE;
+}
+
+static int rockchip_mpp_rkvepu_assign_reset(struct rockchip_rkvepu_dev *enc_dev)
+{
+	struct rockchip_mpp_dev *mpp_dev = &enc_dev->mpp_dev;
+
+	/* TODO: use devm_reset_control_get_share() instead */
+	enc_dev->rst_a = devm_reset_control_get(mpp_dev->dev, "video_a");
+	enc_dev->rst_h = devm_reset_control_get(mpp_dev->dev, "video_h");
+
+	if (IS_ERR_OR_NULL(enc_dev->rst_a)) {
+		mpp_err("No aclk reset resource define\n");
+		enc_dev->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(enc_dev->rst_h)) {
+		mpp_err("No hclk reset resource define\n");
+		enc_dev->rst_h = NULL;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_reset(struct rockchip_mpp_dev *mpp_dev)
+{
+	struct rockchip_rkvepu_dev *enc = to_rkvepu_dev(mpp_dev);
+
+	if (enc->rst_a && enc->rst_h) {
+		mpp_debug(DEBUG_RESET, "reset in\n");
+
+		/* Don't skip this or iommu won't work after reset */
+		rockchip_pmu_idle_request(mpp_dev->dev, true);
+		safe_reset(enc->rst_a);
+		safe_reset(enc->rst_h);
+		udelay(5);
+		safe_unreset(enc->rst_h);
+		safe_unreset(enc->rst_a);
+		rockchip_pmu_idle_request(mpp_dev->dev, false);
+
+		mpp_dev_write(mpp_dev, RKVEPU1_REG_ENC_CTRL, 0);
+		enc->current_task = NULL;
+		mpp_debug(DEBUG_RESET, "reset out\n");
+	}
+
+	return 0;
+}
+
+static struct mpp_dev_ops rkvepu_ops = {
+	.alloc_task = rockchip_mpp_rkvepu_alloc_task,
+	.prepare = rockchip_mpp_rkvepu_prepare,
+	.run = rockchip_mpp_rkvepu_run,
+	.finish = rockchip_mpp_rkvepu_finish,
+	.result = rockchip_mpp_rkvepu_result,
+	.free_task = rockchip_mpp_rkvepu_free_task,
+	.reset = rockchip_mpp_rkvepu_reset,
+};
+
+static int rockchip_mpp_rkvepu_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rockchip_rkvepu_dev *enc_dev = NULL;
+	struct rockchip_mpp_dev *mpp_dev = NULL;
+	int ret = 0;
+
+	enc_dev = devm_kzalloc(dev, sizeof(struct rockchip_rkvepu_dev),
+			       GFP_KERNEL);
+	if (!enc_dev)
+		return -ENOMEM;
+
+	mpp_dev = &enc_dev->mpp_dev;
+	mpp_dev->variant = rockchip_rkvepu1_get_drv_data(pdev);
+	ret = mpp_dev_common_probe(mpp_dev, pdev, &rkvepu_ops);
+	if (ret)
+		return ret;
+
+	ret = devm_request_threaded_irq(dev, mpp_dev->irq, NULL, mpp_rkvepu_isr,
+					IRQF_SHARED | IRQF_ONESHOT,
+					dev_name(dev), enc_dev);
+	if (ret) {
+		dev_err(dev, "register interrupter runtime failed\n");
+		return ret;
+	}
+
+	rockchip_mpp_rkvepu_assign_reset(enc_dev);
+
+	ret = mpp_dev_register_node(mpp_dev, mpp_dev->variant->node_name, NULL);
+	if (ret)
+		dev_err(dev, "register char device failed: %d\n", ret);
+
+	dev_info(dev, "probing finish\n");
+
+	platform_set_drvdata(pdev, enc_dev);
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_remove(struct platform_device *pdev)
+{
+	struct rockchip_rkvepu_dev *enc_dev = platform_get_drvdata(pdev);
+
+	mpp_dev_common_remove(&enc_dev->mpp_dev);
+
+	return 0;
+}
+
+static const struct of_device_id mpp_rkvepu1_dt_match[] = {
+	{ .compatible = "rockchip,vpu-encoder-v1", .data = &rkvepu_v1_data},
+	{},
+};
+
+static void *rockchip_rkvepu1_get_drv_data(struct platform_device *pdev)
+{
+	struct mpp_dev_variant *driver_data = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_node(mpp_rkvepu1_dt_match, pdev->dev.of_node);
+		if (match)
+			driver_data = (struct mpp_dev_variant *)match->data;
+	}
+	return driver_data;
+}
+
+static struct platform_driver rockchip_rkvepu1_driver = {
+	.probe = rockchip_mpp_rkvepu_probe,
+	.remove = rockchip_mpp_rkvepu_remove,
+	.driver = {
+		.name = RKVEPU1_DRIVER_NAME,
+		.of_match_table = of_match_ptr(mpp_rkvepu1_dt_match),
+	},
+};
+
+static int __init mpp_dev_rkvepu1_init(void)
+{
+	int ret = platform_driver_register(&rockchip_rkvepu1_driver);
+
+	if (ret) {
+		mpp_err("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit mpp_dev_rkvepu1_exit(void)
+{
+	platform_driver_unregister(&rockchip_rkvepu1_driver);
+}
+
+module_init(mpp_dev_rkvepu1_init);
+module_exit(mpp_dev_rkvepu1_exit);
+
+MODULE_DEVICE_TABLE(of, mpp_rkvepu1_dt_match);
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/video/rockchip/vpu/mpp_dev_vepu2.c b/drivers/video/rockchip/vpu/mpp_dev_vepu2.c
new file mode 100644
index 000000000000..48ec401145d5
--- /dev/null
+++ b/drivers/video/rockchip/vpu/mpp_dev_vepu2.c
@@ -0,0 +1,478 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ *		Randy Li, <ayaka@soulik.info>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <asm/cacheflush.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/of_platform.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <soc/rockchip/pm_domains.h>
+
+#include "mpp_debug.h"
+#include "mpp_dev_common.h"
+
+#define RKVEPU2_DRIVER_NAME		"mpp_vepu2"
+#define RKVEPU2_NODE_NAME		"vepu"
+
+/* The maximum registers number of all the version */
+#define ROCKCHIP_VEPU2_REG_NUM			(184)
+
+#define RKVEPU2_REG_ENC_CTRL			0x19c
+#define RKVEPU2_REG_ENC_CTRL_INDEX		(103)
+#define		RKVEPU2_GET_FORMAT(x)		(((x) >> 4) & 0x3)
+#define		RKVEPU2_FMT_RESERVED		(0)
+#define		RKVEPU2_FMT_VP8E		(1)
+#define		RKVEPU2_FMT_JPEGE		(2)
+#define		RKVEPU2_FMT_H264E		(3)
+#define		RKVEPU2_ENC_START		BIT(0)
+
+#define RKVEPU2_REG_MB_CTRL			0x1a0
+#define RKVEPU2_REG_MB_CTRL_INDEX		(104)
+
+#define RKVEPU2_REG_INT				0x1b4
+#define RKVEPU2_REG_INT_INDEX			(109)
+#define		RKVEPU2_MV_SAD_WR_EN		BIT(24)
+#define		RKVEPU2_ROCON_WRITE_DIS		BIT(20)
+#define		RKVEPU1_INT_SLICE_EN		BIT(16)
+#define		RKVEPU2_CLOCK_GATE_EN		BIT(12)
+#define		RKVEPU2_INT_TIMEOUT_EN		BIT(10)
+#define		RKVEPU2_INT_CLEAR		BIT(9)
+#define		RKVEPU2_IRQ_DIS			BIT(8)
+#define		RKVEPU2_INT_TIMEOUT		BIT(6)
+#define		RKVEPU2_INT_BUF_FULL		BIT(5)
+#define		RKVEPU2_INT_BUS_ERROR		BIT(4)
+#define		RKVEPU2_INT_SLICE		BIT(2)
+#define		RKVEPU2_INT_RDY			BIT(1)
+#define		RKVEPU2_INT_RAW			BIT(0)
+
+#define RKVPUE2_REG_DMV_4P_1P(i)		(0x1e0 + ((i) << 4))
+#define RKVPUE2_REG_DMV_4P_1P_INDEX(i)		(120 + (i))
+
+#define to_rkvepu_task(ctx)		\
+		container_of(ctx, struct rkvepu_task, mpp_task)
+#define to_rkvepu_dev(dev)		\
+		container_of(dev, struct rockchip_rkvepu_dev, mpp_dev)
+
+static int debug;
+module_param(debug, int, 0644);
+MODULE_PARM_DESC(debug, "bit switch for vepu1 debug information");
+
+struct rockchip_rkvepu_dev {
+	struct rockchip_mpp_dev mpp_dev;
+
+	struct reset_control *rst_a;
+	struct reset_control *rst_h;
+
+	void *current_task;
+};
+
+struct rkvepu_task {
+	struct mpp_task mpp_task;
+
+	u32 reg[ROCKCHIP_VEPU2_REG_NUM];
+	u32 idx;
+	struct extra_info_for_iommu ext_inf;
+
+	u32 strm_base;
+	u32 irq_status;
+};
+
+/*
+ * file handle translate information
+ */
+static const char trans_tbl_default[] = {
+	48, 49, 50, 56, 57, 63, 64, 77, 78, 81
+};
+
+static struct mpp_trans_info trans_rk_vepu2[] = {
+	[RKVEPU2_FMT_RESERVED] = {
+		.count = 0,
+		.table = NULL,
+	},
+	[RKVEPU2_FMT_VP8E] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVEPU2_FMT_JPEGE] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+	[RKVEPU2_FMT_H264E] = {
+		.count = sizeof(trans_tbl_default),
+		.table = trans_tbl_default,
+	},
+};
+
+static const struct mpp_dev_variant rkvepu_v2_data = {
+	.reg_len = ROCKCHIP_VEPU2_REG_NUM,
+	.trans_info = trans_rk_vepu2,
+	.node_name = RKVEPU2_NODE_NAME,
+};
+
+static void *rockchip_rkvepu2_get_drv_data(struct platform_device *pdev);
+
+static void *rockchip_mpp_rkvepu_alloc_task(struct mpp_session *session,
+					    void __user *src, u32 size)
+{
+	struct rkvepu_task *task = NULL;
+	u32 reg_len;
+	u32 extinf_len;
+	u32 fmt = 0;
+	u32 dwsize = size / sizeof(u32);
+	int err = -EFAULT;
+
+	mpp_debug_enter();
+
+	task = kzalloc(sizeof(*task), GFP_KERNEL);
+	if (!task)
+		return NULL;
+
+	mpp_dev_task_init(session, &task->mpp_task);
+
+	reg_len = dwsize > ROCKCHIP_VEPU2_REG_NUM ?
+		ROCKCHIP_VEPU2_REG_NUM : dwsize;
+	extinf_len = dwsize > reg_len ? (dwsize - reg_len) * 4 : 0;
+
+	if (copy_from_user(task->reg, src, reg_len * 4)) {
+		mpp_err("error: copy_from_user failed in reg_init\n");
+		err = -EFAULT;
+		goto fail;
+	}
+
+	fmt = RKVEPU2_GET_FORMAT(task->reg[RKVEPU2_REG_ENC_CTRL_INDEX]);
+	if (extinf_len > 0) {
+		if (likely(fmt == RKVEPU2_FMT_JPEGE)) {
+			err = copy_from_user(&task->ext_inf,
+					     (u8 *)src + size
+					     - JPEG_IOC_EXTRA_SIZE,
+					     JPEG_IOC_EXTRA_SIZE);
+		} else {
+			u32 ext_cpy = min_t(size_t, extinf_len,
+					    sizeof(task->ext_inf));
+			err = copy_from_user(&task->ext_inf,
+					     (u32 *)src + reg_len, ext_cpy);
+		}
+
+		if (err) {
+			mpp_err("copy_from_user failed when extra info\n");
+			err = -EFAULT;
+			goto fail;
+		}
+	}
+
+	err = mpp_reg_address_translate(session->mpp, &task->mpp_task, fmt,
+					task->reg);
+	if (err) {
+		mpp_err("error: translate reg address failed.\n");
+
+		if (unlikely(debug & DEBUG_DUMP_ERR_REG))
+			mpp_debug_dump_reg_mem(task->reg,
+					       ROCKCHIP_VEPU2_REG_NUM);
+		goto fail;
+	}
+
+	mpp_debug(DEBUG_SET_REG, "extra info cnt %u, magic %08x",
+		  task->ext_inf.cnt, task->ext_inf.magic);
+	mpp_translate_extra_info(&task->mpp_task, &task->ext_inf, task->reg);
+
+	mpp_debug_leave();
+
+	return &task->mpp_task;
+
+fail:
+	mpp_dev_task_finalize(session, &task->mpp_task);
+	kfree(task);
+	return ERR_PTR(err);
+}
+
+static int rockchip_mpp_rkvepu_prepare(struct rockchip_mpp_dev *mpp_dev,
+				       struct mpp_task *task)
+{
+	return -EINVAL;
+}
+
+static int rockchip_mpp_rkvepu_run(struct rockchip_mpp_dev *mpp_dev,
+				   struct mpp_task *mpp_task)
+{
+	struct rkvepu_task *task = NULL;
+	struct rockchip_rkvepu_dev *enc_dev = NULL;
+
+	mpp_debug_enter();
+
+	task = to_rkvepu_task(mpp_task);
+	enc_dev = to_rkvepu_dev(mpp_dev);
+
+	/* FIXME: spin lock here */
+	enc_dev->current_task = task;
+
+	mpp_dev_write_seq(mpp_dev, 0, &task->reg[0],
+			  RKVEPU2_REG_ENC_CTRL_INDEX);
+
+	mpp_dev_write_seq(mpp_dev, RKVEPU2_REG_MB_CTRL,
+			  &task->reg[RKVEPU2_REG_MB_CTRL_INDEX],
+			  ROCKCHIP_VEPU2_REG_NUM
+			  - RKVEPU2_REG_MB_CTRL_INDEX);
+	/* Flush the registers */
+	wmb();
+	mpp_dev_write(mpp_dev, RKVEPU2_REG_ENC_CTRL,
+		      task->reg[RKVEPU2_REG_ENC_CTRL_INDEX]
+		      | RKVEPU2_ENC_START);
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_finish(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task)
+{
+	struct rkvepu_task *task = to_rkvepu_task(mpp_task);
+
+	mpp_debug_enter();
+
+	task->reg[RKVEPU2_REG_INT_INDEX] = task->irq_status;
+
+	mpp_debug_leave();
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_result(struct rockchip_mpp_dev *mpp_dev,
+				      struct mpp_task *mpp_task,
+				      u32 __user *dst, u32 size)
+{
+	struct rkvepu_task *task = to_rkvepu_task(mpp_task);
+
+	/* FIXME may overflow the kernel */
+	if (copy_to_user(dst, task->reg, size)) {
+		mpp_err("copy_to_user failed\n");
+		return -EIO;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_free_task(struct mpp_session *session,
+					 struct mpp_task *mpp_task)
+{
+	struct rkvepu_task *task = to_rkvepu_task(mpp_task);
+
+	mpp_dev_task_finalize(session, mpp_task);
+	kfree(task);
+
+	return 0;
+}
+
+static irqreturn_t mpp_rkvepu_isr(int irq, void *dev_id)
+{
+	struct rockchip_rkvepu_dev *enc_dev = dev_id;
+	struct rockchip_mpp_dev *mpp_dev = &enc_dev->mpp_dev;
+	struct rkvepu_task *task = NULL;
+	struct mpp_task *mpp_task = NULL;
+	u32 irq_status;
+	u32 err_mask;
+
+	irq_status = mpp_dev_read(mpp_dev, RKVEPU2_REG_INT);
+	if (!(irq_status & RKVEPU2_INT_RAW))
+		return IRQ_NONE;
+
+	mpp_dev_write(mpp_dev, RKVEPU2_REG_INT, RKVEPU2_INT_CLEAR
+		      | RKVEPU2_CLOCK_GATE_EN);
+	/* FIXME use a spin lock here */
+	task = (struct rkvepu_task *)enc_dev->current_task;
+	if (!task) {
+		dev_err(enc_dev->mpp_dev.dev, "no current task\n");
+		return IRQ_HANDLED;
+	}
+
+	mpp_task = &task->mpp_task;
+	mpp_debug_time_diff(mpp_task);
+
+	task->irq_status = irq_status;
+	mpp_debug(DEBUG_IRQ_STATUS, "irq_status: %08x\n",
+		  task->irq_status);
+
+	err_mask = RKVEPU2_INT_TIMEOUT
+		| RKVEPU2_INT_BUF_FULL
+		| RKVEPU2_INT_BUS_ERROR;
+
+	if (err_mask & task->irq_status)
+		atomic_set(&mpp_dev->reset_request, 1);
+
+	mpp_dev_task_finish(mpp_task->session, mpp_task);
+
+	mpp_debug_leave();
+	return IRQ_HANDLED;
+
+	return IRQ_NONE;
+}
+
+static int rockchip_mpp_rkvepu_assign_reset(struct rockchip_rkvepu_dev *enc_dev)
+{
+	struct rockchip_mpp_dev *mpp_dev = &enc_dev->mpp_dev;
+
+	/* TODO: use devm_reset_control_get_share() instead */
+	enc_dev->rst_a = devm_reset_control_get(mpp_dev->dev, "video_a");
+	enc_dev->rst_h = devm_reset_control_get(mpp_dev->dev, "video_h");
+
+	if (IS_ERR_OR_NULL(enc_dev->rst_a)) {
+		mpp_err("No aclk reset resource define\n");
+		enc_dev->rst_a = NULL;
+	}
+
+	if (IS_ERR_OR_NULL(enc_dev->rst_h)) {
+		mpp_err("No hclk reset resource define\n");
+		enc_dev->rst_h = NULL;
+	}
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_reset(struct rockchip_mpp_dev *mpp_dev)
+{
+	struct rockchip_rkvepu_dev *enc = to_rkvepu_dev(mpp_dev);
+
+	if (enc->rst_a && enc->rst_h) {
+		mpp_debug(DEBUG_RESET, "reset in\n");
+
+		/* Don't skip this or iommu won't work after reset */
+		rockchip_pmu_idle_request(mpp_dev->dev, true);
+		safe_reset(enc->rst_a);
+		safe_reset(enc->rst_h);
+		udelay(5);
+		safe_unreset(enc->rst_h);
+		safe_unreset(enc->rst_a);
+		rockchip_pmu_idle_request(mpp_dev->dev, false);
+
+		mpp_dev_write(mpp_dev, RKVEPU2_REG_INT, RKVEPU2_INT_CLEAR);
+		enc->current_task = NULL;
+		mpp_debug(DEBUG_RESET, "reset out\n");
+	}
+
+	return 0;
+}
+
+static struct mpp_dev_ops rkvepu_ops = {
+	.alloc_task = rockchip_mpp_rkvepu_alloc_task,
+	.prepare = rockchip_mpp_rkvepu_prepare,
+	.run = rockchip_mpp_rkvepu_run,
+	.finish = rockchip_mpp_rkvepu_finish,
+	.result = rockchip_mpp_rkvepu_result,
+	.free_task = rockchip_mpp_rkvepu_free_task,
+	.reset = rockchip_mpp_rkvepu_reset,
+};
+
+static int rockchip_mpp_rkvepu_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct rockchip_rkvepu_dev *enc_dev = NULL;
+	struct rockchip_mpp_dev *mpp_dev = NULL;
+	int ret = 0;
+
+	enc_dev = devm_kzalloc(dev, sizeof(struct rockchip_rkvepu_dev),
+			       GFP_KERNEL);
+	if (!enc_dev)
+		return -ENOMEM;
+
+	mpp_dev = &enc_dev->mpp_dev;
+	mpp_dev->variant = rockchip_rkvepu2_get_drv_data(pdev);
+	ret = mpp_dev_common_probe(mpp_dev, pdev, &rkvepu_ops);
+	if (ret)
+		return ret;
+
+	ret = devm_request_threaded_irq(dev, mpp_dev->irq, NULL, mpp_rkvepu_isr,
+					IRQF_SHARED | IRQF_ONESHOT,
+					dev_name(dev), enc_dev);
+	if (ret) {
+		dev_err(dev, "register interrupter runtime failed\n");
+		return ret;
+	}
+
+	rockchip_mpp_rkvepu_assign_reset(enc_dev);
+
+	ret = mpp_dev_register_node(mpp_dev, mpp_dev->variant->node_name, NULL);
+	if (ret)
+		dev_err(dev, "register char device failed: %d\n", ret);
+
+	dev_info(dev, "probing finish\n");
+
+	platform_set_drvdata(pdev, enc_dev);
+
+	return 0;
+}
+
+static int rockchip_mpp_rkvepu_remove(struct platform_device *pdev)
+{
+	struct rockchip_rkvepu_dev *enc_dev = platform_get_drvdata(pdev);
+
+	mpp_dev_common_remove(&enc_dev->mpp_dev);
+
+	return 0;
+}
+
+static const struct of_device_id mpp_rkvepu2_dt_match[] = {
+	{ .compatible = "rockchip,vpu-encoder-v2", .data = &rkvepu_v2_data},
+	{},
+};
+
+static void *rockchip_rkvepu2_get_drv_data(struct platform_device *pdev)
+{
+	struct mpp_dev_variant *driver_data = NULL;
+
+	if (pdev->dev.of_node) {
+		const struct of_device_id *match;
+
+		match = of_match_node(mpp_rkvepu2_dt_match, pdev->dev.of_node);
+		if (match)
+			driver_data = (struct mpp_dev_variant *)match->data;
+	}
+	return driver_data;
+}
+
+static struct platform_driver rockchip_rkvepu2_driver = {
+	.probe = rockchip_mpp_rkvepu_probe,
+	.remove = rockchip_mpp_rkvepu_remove,
+	.driver = {
+		.name = RKVEPU2_DRIVER_NAME,
+		.of_match_table = of_match_ptr(mpp_rkvepu2_dt_match),
+	},
+};
+
+static int __init mpp_dev_rkvepu2_init(void)
+{
+	int ret = platform_driver_register(&rockchip_rkvepu2_driver);
+
+	if (ret) {
+		mpp_err("Platform device register failed (%d).\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static void __exit mpp_dev_rkvepu2_exit(void)
+{
+	platform_driver_unregister(&rockchip_rkvepu2_driver);
+}
+
+module_init(mpp_dev_rkvepu2_init);
+module_exit(mpp_dev_rkvepu2_exit);
+
+MODULE_DEVICE_TABLE(of, mpp_rkvepu2_dt_match);
+MODULE_LICENSE("GPL v2");

From 4757898c329b98012acf0ad6bdc16901042a0949 Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Sat, 2 Jun 2018 03:49:25 +0800
Subject: [PATCH] regulator: fan53555: add SYR83x

Signed-off-by: ayaka <ayaka@soulik.info>
---
 drivers/regulator/fan53555.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/drivers/regulator/fan53555.c b/drivers/regulator/fan53555.c
index 74e5ae2bc0d2..6b0854a3cae3 100644
--- a/drivers/regulator/fan53555.c
+++ b/drivers/regulator/fan53555.c
@@ -78,6 +78,7 @@ enum {
 
 enum {
 	SILERGY_SYR82X = 8,
+	SILERGY_SYR83X = 9,
 };
 
 struct fan53555_device_info {
@@ -323,6 +324,7 @@ static int fan53555_voltages_setup_silergy(struct fan53555_device_info *di)
 	/* Init voltage range and step */
 	switch (di->chip_id) {
 	case SILERGY_SYR82X:
+	case SILERGY_SYR83X:
 		di->vsel_min = 712500;
 		di->vsel_step = 12500;
 		break;

From f93ca9dd267d86c1283bca67e25b1ecd7b7a1bd0 Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Thu, 11 Jan 2018 17:21:47 +0800
Subject: [PATCH] [TEST]: ARM64: dts: rockchip: disable vop iommus auto loading

Change-Id: Ia16abca567c9229ac04c09201766f0870e2c446e
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 arch/arm/boot/dts/rk3036.dtsi            | 1 +
 arch/arm/boot/dts/rk3288.dtsi            | 2 ++
 arch/arm64/boot/dts/rockchip/rk3328.dtsi | 1 +
 arch/arm64/boot/dts/rockchip/rk3399.dtsi | 2 ++
 4 files changed, 6 insertions(+)

diff --git a/arch/arm/boot/dts/rk3036.dtsi b/arch/arm/boot/dts/rk3036.dtsi
index 71dd58b2ec84..d1b3f0eea9ed 100644
--- a/arch/arm/boot/dts/rk3036.dtsi
+++ b/arch/arm/boot/dts/rk3036.dtsi
@@ -325,6 +325,7 @@
 		resets = <&cru SRST_LCDC1_A>, <&cru SRST_LCDC1_H>, <&cru SRST_LCDC1_D>;
 		reset-names = "axi", "ahb", "dclk";
 		iommus = <&vop_mmu>;
+		deferred_attach;
 		status = "disabled";
 
 		vop_out: port {
diff --git a/arch/arm/boot/dts/rk3288.dtsi b/arch/arm/boot/dts/rk3288.dtsi
index 87754891b032..4142a5fd991e 100644
--- a/arch/arm/boot/dts/rk3288.dtsi
+++ b/arch/arm/boot/dts/rk3288.dtsi
@@ -1303,6 +1303,7 @@
 		resets = <&cru SRST_LCDC0_AXI>, <&cru SRST_LCDC0_AHB>, <&cru SRST_LCDC0_DCLK>;
 		reset-names = "axi", "ahb", "dclk";
 		iommus = <&vopb_mmu>;
+		deferred_attach;
 		status = "disabled";
 
 		vopb_out: port {
@@ -1360,6 +1361,7 @@
 		resets = <&cru SRST_LCDC1_AXI>, <&cru SRST_LCDC1_AHB>, <&cru SRST_LCDC1_DCLK>;
 		reset-names = "axi", "ahb", "dclk";
 		iommus = <&vopl_mmu>;
+		deferred_attach;
 		status = "disabled";
 
 		vopl_out: port {
diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
index 3894ad55ad04..066c404356a0 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
@@ -968,6 +968,7 @@
 		resets = <&cru SRST_VOP_A>, <&cru SRST_VOP_H>, <&cru SRST_VOP_D>;
 		reset-names = "axi", "ahb", "dclk";
 		iommus = <&vop_mmu>;
+		deferred_attach;
 		status = "disabled";
 
 		vop_out: port {
diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
index 7e2f45515622..47c103a9dfab 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
@@ -1763,6 +1763,7 @@
 		reset-names = "axi", "ahb", "dclk";
 		power-domains = <&power RK3399_PD_VOPL>;
 		iommus = <&vopl_mmu>;
+		deferred_attach;
 		status = "disabled";
 
 		vopl_out: port {
@@ -1833,6 +1834,7 @@
 		power-domains = <&power RK3399_PD_VOPB>;
 		iommus = <&vopb_mmu>;
 		status = "disabled";
+		deferred_attach;
 
 		vopb_out: port {
 			#address-cells = <1>;

From dd42a55862c735bff348014980e8e92da863d19e Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Thu, 2 Nov 2017 11:27:30 +0800
Subject: [PATCH] ARM64: dts: rockchip: use new video driver for rk3399

The decoders now use the new mpp driver.

Change-Id: I0ca75ff12dad490da8c28e8642c5d9f5727df250
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 arch/arm64/boot/dts/rockchip/rk3399.dtsi | 55 +++++++++++++++++++++-----------
 1 file changed, 36 insertions(+), 19 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
index 47c103a9dfab..8da2fdfc016a 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
@@ -1312,24 +1312,38 @@
 		status = "disabled";
 	};
 
-	vpu: vpu_service@ff650000 {
-		compatible = "rockchip,vpu_service";
-		rockchip,grf = <&grf>;
+	vpu_service: vpu-srv {
+		compatible = "rockchip,mpp-service";
+		status = "disabled";
+	};
+
+	vepu: vpu-encoder@ff650000 {
+		compatible = "rockchip,vpu-encoder-v2";
+		reg = <0x0 0xff650000 0x0 0x400>;
+		interrupts = <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH 0>;
+		interrupt-names = "irq_enc";
+		clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		resets = <&cru SRST_H_VCODEC>, <&cru SRST_A_VCODEC>;
+		reset-names = "video_h", "video_a";
+		iommus = <&vpu_mmu>;
+		power-domains = <&power RK3399_PD_VCODEC>;
+		rockchip,srv = <&vpu_service>;
+		status = "disabled";
+	};
+
+	vdpu: vpu-decoder@ff650400 {
+		compatible = "rockchip,vpu-decoder-v2";
+		reg = <0x0 0xff650400 0x0 0x400>;
+		interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH 0>;
+		interrupt-names = "irq_dec";
 		iommus = <&vpu_mmu>;
-		iommu_enabled = <1>;
-		reg = <0x0 0xff650000 0x0 0x800>;
-		interrupts = <GIC_SPI 113 IRQ_TYPE_LEVEL_HIGH 0>,
-			     <GIC_SPI 114 IRQ_TYPE_LEVEL_HIGH 0>;
-		interrupt-names = "irq_dec", "irq_enc";
 		clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
 		clock-names = "aclk_vcodec", "hclk_vcodec";
 		resets = <&cru SRST_H_VCODEC>, <&cru SRST_A_VCODEC>;
 		reset-names = "video_h", "video_a";
 		power-domains = <&power RK3399_PD_VCODEC>;
-		name = "vpu_service";
-		dev_mode = <0>;
-		/* 0 means ion, 1 means drm */
-		allocator = <1>;
+		rockchip,srv = <&vpu_service>;
 		status = "disabled";
 	};
 
@@ -1342,13 +1356,18 @@
 		clock-names = "aclk", "hclk";
 		power-domains = <&power RK3399_PD_VCODEC>;
 		#iommu-cells = <0>;
+		status = "disabled";
 	};
 
-	rkvdec: rkvdec@ff660000 {
-		compatible = "rockchip,rkvdec";
+	rkvdec_srv: rkvdec-srv {
+		compatible = "rockchip,mpp-service";
+		status = "disabled";
+	};
+
+	rkvdec: video-decoder@ff660000 {
+		compatible = "rockchip,video-decoder-v1";
 		rockchip,grf = <&grf>;
 		iommus = <&vdec_mmu>;
-		iommu_enabled = <1>;
 		reg = <0x0 0xff660000 0x0 0x400>;
 		interrupts = <GIC_SPI 116 IRQ_TYPE_LEVEL_HIGH 0>;
 		interrupt-names = "irq_dec";
@@ -1362,10 +1381,7 @@
 		reset-names = "video_h", "video_a", "video_core", "video_cabac",
 				"niu_a", "niu_h";
 		power-domains = <&power RK3399_PD_VDU>;
-		dev_mode = <2>;
-		name = "rkvdec";
-		/* 0 means ion, 1 means drm */
-		allocator = <1>;
+		rockchip,srv = <&rkvdec_srv>;
 		status = "disabled";
 	};
 
@@ -1378,6 +1394,7 @@
 		clock-names = "aclk", "hclk";
 		power-domains = <&power RK3399_PD_VDU>;
 		#iommu-cells = <0>;
+		status = "disabled";
 	};
 
 	iep: iep@ff670000 {

From 10aeb57811bed4226cee5a72e6565a837863fd83 Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Wed, 24 Jan 2018 01:53:11 +0800
Subject: [PATCH] [WIP]: ARM64: dts: rockchip: enable new video driver for
 rk3399

We need to rewrite the firefly board device tree files.

Change-Id: I96e38ff6761b4bc14472574974d2d105def2b1ba
Signed-off-by: ayaka <ayaka@soulik.info>
---
 .../boot/dts/rockchip/rk3399-android-6.0.dtsi      | 30 ++++++++++++----------
 arch/arm64/boot/dts/rockchip/rk3399-android.dtsi   | 18 ++++++++++++-
 .../dts/rockchip/rk3399-excavator-sapphire.dtsi    | 28 ++++++++++++++++++++
 .../boot/dts/rockchip/rk3399-firefly-android.dts   |  8 ------
 .../boot/dts/rockchip/rk3399-firefly-linux.dts     |  8 ------
 .../rockchip/rk3399-sapphire-excavator-linux.dts   | 12 ---------
 .../boot/dts/rockchip/rk3399-videostrong-linux.dts | 26 +++++++++++++++----
 7 files changed, 83 insertions(+), 47 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-android-6.0.dtsi b/arch/arm64/boot/dts/rockchip/rk3399-android-6.0.dtsi
index f43c56038a61..93b9cfa00a70 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-android-6.0.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399-android-6.0.dtsi
@@ -473,28 +473,32 @@
 	};
 };
 
-&vpu {
+&rkvdec {
 	status = "okay";
-	/delete-property/ iommus;
-	/* 0 means ion, 1 means drm */
-	allocator = <0>;
 };
 
-&vpu_mmu {
-	dbgname = "vpu";
-	compatible = "rockchip,vpu_mmu";
+&rkvdec_srv {
+	status = "okay";
 };
 
-&rkvdec {
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vpu_service {
+	status = "okay";
+};
+
+&vpu_mmu {
 	status = "okay";
-	/delete-property/ iommus;
-	/* 0 means ion, 1 means drm */
-	allocator = <0>;
 };
 
 &vdec_mmu {
-	dbgname = "vdec";
-	compatible = "rockchip,vdec_mmu";
+	status = "okay";
 };
 
 &iep {
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-android.dtsi b/arch/arm64/boot/dts/rockchip/rk3399-android.dtsi
index 3e917c077f79..7b64b887535b 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-android.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399-android.dtsi
@@ -366,6 +366,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &usbdrd_dwc3_0 {
 	dr_mode = "otg";
 };
@@ -378,7 +382,19 @@
 	status = "okay";
 };
 
-&vpu {
+&vdec_mmu {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vpu_service {
 	status = "okay";
 };
 
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-excavator-sapphire.dtsi b/arch/arm64/boot/dts/rockchip/rk3399-excavator-sapphire.dtsi
index c406e54b4a87..db6678f76d9c 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-excavator-sapphire.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399-excavator-sapphire.dtsi
@@ -220,6 +220,14 @@
 	status = "okay";
 };
 
+&rkvdec {
+	status = "okay";
+};
+
+&rkvdec_srv {
+	status = "okay";
+};
+
 &rockchip_suspend {
 	status = "okay";
 	rockchip,sleep-debug-en = <1>;
@@ -264,3 +272,23 @@
 		};
 	};
 };
+
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vpu_service {
+	status = "okay";
+};
+
+&vpu_mmu {
+	status = "okay";
+};
+
+&vdec_mmu {
+	status = "okay";
+};
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-firefly-android.dts b/arch/arm64/boot/dts/rockchip/rk3399-firefly-android.dts
index f2d5c4bfc028..454812d26bb3 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-firefly-android.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-firefly-android.dts
@@ -929,10 +929,6 @@
 	status = "okay";
 };
 
-&rkvdec {
-	status = "okay";
-};
-
 &rockchip_suspend {
 	rockchip,power-ctrl =
 		<&gpio1 18 GPIO_ACTIVE_LOW>,
@@ -1095,7 +1091,3 @@
 &vopl_mmu {
 	status = "okay";
 };
-
-&vpu {
-	status = "okay";
-};
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts b/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts
index c3e076f7ff89..a047e220fdd7 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-firefly-linux.dts
@@ -898,10 +898,6 @@
 	pinctrl-0 = <&pwm2_pin_pull_down>;
 };
 
-&rkvdec {
-	status = "okay";
-};
-
 &rockchip_suspend {
 	rockchip,power-ctrl =
 		<&gpio1 18 GPIO_ACTIVE_LOW>,
@@ -1077,7 +1073,3 @@
 &vopl_mmu {
 	status = "okay";
 };
-
-&vpu {
-	status = "okay";
-};
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-sapphire-excavator-linux.dts b/arch/arm64/boot/dts/rockchip/rk3399-sapphire-excavator-linux.dts
index 10a7f4f7a96e..8ee0697295c8 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-sapphire-excavator-linux.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-sapphire-excavator-linux.dts
@@ -164,18 +164,6 @@
 	vref-supply = <&vccadc_ref>;
 };
 
-&vpu {
-	status = "okay";
-	/* 0 means ion, 1 means drm */
-	//allocator = <0>;
-};
-
-&rkvdec {
-	status = "okay";
-	/* 0 means ion, 1 means drm */
-	//allocator = <0>;
-};
-
 &backlight {
 	status = "okay";
 	enable-gpios = <&gpio1 13 GPIO_ACTIVE_HIGH>;
diff --git a/arch/arm64/boot/dts/rockchip/rk3399-videostrong-linux.dts b/arch/arm64/boot/dts/rockchip/rk3399-videostrong-linux.dts
index 0d0bad8561cf..b4f3ef3bbfef 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-videostrong-linux.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-videostrong-linux.dts
@@ -207,8 +207,10 @@
 
 &rkvdec {
 	status = "okay";
-	/* 0 means ion, 1 means drm */
-	//allocator = <0>;
+};
+
+&rkvdec_srv {
+	status = "okay";
 };
 
 &rockchip_suspend {
@@ -254,10 +256,24 @@
 	status = "okay";
 };
 
-&vpu {
+&vdec_mmu {
+	status = "okay";
+};
+
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vpu_service {
+	status = "okay";
+};
+
+&vpu_mmu {
 	status = "okay";
-	/* 0 means ion, 1 means drm */
-	//allocator = <0>;
 };
 
 &vopb {

From da42796adfffab357707f10a17aab98302934ed8 Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Sat, 11 Nov 2017 23:47:46 +0800
Subject: [PATCH] ARM: dts: rockchip: use new driver for rk3288

Change-Id: If2b63b8a05d61f7463172bc9c9f77fbf0044bf45
Signed-off-by: ayaka <ayaka@soulik.info>
---
 arch/arm/boot/dts/rk3288.dtsi | 60 +++++++++++++++++++++++++++++++++++--------
 1 file changed, 49 insertions(+), 11 deletions(-)

diff --git a/arch/arm/boot/dts/rk3288.dtsi b/arch/arm/boot/dts/rk3288.dtsi
index 4142a5fd991e..607c88336834 100644
--- a/arch/arm/boot/dts/rk3288.dtsi
+++ b/arch/arm/boot/dts/rk3288.dtsi
@@ -1611,6 +1611,39 @@
 		status = "disabled";
 	};
 
+	vepu: video-encoder@ff9a0000 {
+		compatible = "rockchip,vpu-encoder-v1";
+		reg = <0x0 0xff9a0000 0x0 0x400>;
+		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_enc";
+		clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		power-domains = <&power RK3288_PD_VIDEO>;
+		resets = <&cru SRST_VCODEC_AXI>, <&cru SRST_VCODEC_AHB>;
+		reset-names = "video_a", "video_h";
+		rockchip,srv = <&vpu_service>;
+		iommus = <&vpu_mmu>;
+		status = "disabled";
+	};
+
+	vdpu: video-decoder@ff9a0400 {
+		compatible = "rockchip,vpu-decoder-pp-v1";
+		reg = <0x0 0xff9a0400 0x0 0x400>;
+		interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_dec";
+		clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		assigned-clocks = <&cru ACLK_VCODEC>, <&cru HCLK_VCODEC>;
+		assigned-clock-rates = <300000000>, <75000000>;
+		power-domains = <&power RK3288_PD_VIDEO>;
+		resets = <&cru SRST_VCODEC_AXI>, <&cru SRST_VCODEC_AHB>;
+		reset-names = "video_a", "video_h";
+		rockchip,srv = <&vpu_service>;
+		iommus = <&vpu_mmu>;
+		status = "disabled";
+	};
+
+	/*
 	vpu_service: vpu-service@ff9a0000 {
 		compatible = "rockchip,vpu_service";
 		reg = <0x0 0xff9a0000 0x0 0x800>;
@@ -1626,9 +1659,9 @@
 		iommus = <&vpu_mmu>;
 		iommu_enabled = <1>;
 		status = "disabled";
-		/* 0 means ion, 1 means drm */
 		allocator = <1>;
 	};
+	*/
 
 	vpu_mmu: iommu@ff9a0800 {
 		compatible = "rockchip,iommu";
@@ -1641,14 +1674,18 @@
 		#iommu-cells = <0>;
 	};
 
-	hevc_service: hevc-service@ff9c0000 {
-		compatible = "rockchip,hevc_service";
+	vpu_service: mpp-vpu-srv {
+		compatible = "rockchip,mpp-service";
+		status = "disabled";
+	};
+
+	hevc: hevc-decoder@ff9c0000 {
+		compatible = "rockchip,hevc-decoder-v1";
 		reg = <0x0 0xff9c0000 0x0 0x400>;
 		interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
 		interrupt-names = "irq_dec";
 		clocks = <&cru ACLK_HEVC>, <&cru HCLK_HEVC>,
-			<&cru SCLK_HEVC_CORE>,
-			<&cru SCLK_HEVC_CABAC>;
+			<&cru SCLK_HEVC_CORE>, <&cru SCLK_HEVC_CABAC>;
 		clock-names = "aclk_vcodec", "hclk_vcodec", "clk_core",
 			"clk_cabac";
 		/*
@@ -1660,16 +1697,12 @@
 				  <&cru SCLK_HEVC_CABAC>;
 		assigned-clock-rates = <400000000>, <100000000>,
 				       <300000000>, <300000000>;
-
 		resets = <&cru SRST_HEVC>;
-		reset-names = "video";
+		reset-names = "video_core";
 		power-domains = <&power RK3288_PD_HEVC>;
-		rockchip,grf = <&grf>;
 		iommus = <&hevc_mmu>;
-		iommu_enabled = <1>;
+		rockchip,srv = <&hevc_service>;
 		status = "disabled";
-		/* 0 means ion, 1 means drm */
-		allocator = <1>;
 	};
 
 	hevc_mmu: iommu@ff9c0440 {
@@ -1686,6 +1719,11 @@
 		#iommu-cells = <0>;
 	};
 
+	hevc_service: mpp-srv {
+		compatible = "rockchip,mpp-service";
+		status = "disabled";
+	};
+
 	gpu: gpu@ffa30000 {
 		compatible = "arm,malit764",
 			     "arm,malit76x",

From 06061b60dd57609a6e2890fe5a51a2e5d39c9881 Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Mon, 13 Nov 2017 14:56:39 +0800
Subject: [PATCH] ARM: dts: rockchip: use new video driver for firefly rk3288

Change-Id: I4d65a47ea4bcb1cc82e1bb24dd240c7b5b47fe75
Signed-off-by: ayaka <ayaka@soulik.info>
---
 arch/arm/boot/dts/rk3288-firefly-reload.dts | 16 ++++++++++++++++
 arch/arm/boot/dts/rk3288-firefly.dtsi       | 13 ++++++++++++-
 2 files changed, 28 insertions(+), 1 deletion(-)

diff --git a/arch/arm/boot/dts/rk3288-firefly-reload.dts b/arch/arm/boot/dts/rk3288-firefly-reload.dts
index 223bb61610a3..30daead76ed5 100644
--- a/arch/arm/boot/dts/rk3288-firefly-reload.dts
+++ b/arch/arm/boot/dts/rk3288-firefly-reload.dts
@@ -355,6 +355,14 @@
 	status = "okay";
 };
 
+&hevc {
+	status = "okay";
+};
+
+&hevc_service {
+	status = "okay";
+};
+
 &gmac {
 	phy-supply = <&vcc_phy>;
 	snps,reset-gpio = <&gpio4 7 0>;
@@ -629,6 +637,14 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
 &vpu_service {
 	status = "okay";
 };
diff --git a/arch/arm/boot/dts/rk3288-firefly.dtsi b/arch/arm/boot/dts/rk3288-firefly.dtsi
index b8f6d4364172..66fafd185d37 100644
--- a/arch/arm/boot/dts/rk3288-firefly.dtsi
+++ b/arch/arm/boot/dts/rk3288-firefly.dtsi
@@ -359,9 +359,12 @@
 	status = "okay";
 };
 
-&hevc_service {
+&hevc {
 	status = "okay";
+};
 
+&hevc_service {
+	status = "okay";
 };
 
 &i2c0 {
@@ -762,6 +765,14 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
 &vopb {
 	status = "okay";
 };

From 7d6d1cf66a069b98f5d3191944bffefa47092c7b Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Tue, 21 Nov 2017 11:07:52 +0800
Subject: [PATCH] ARM: dts: rockchip: enable new media driver for miniarm

Change-Id: I18f5614fda2312826e59f2dfaf9cd7c06e61d619
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 arch/arm/boot/dts/rk3288-miniarm.dts | 12 ++++++++++++
 1 file changed, 12 insertions(+)

diff --git a/arch/arm/boot/dts/rk3288-miniarm.dts b/arch/arm/boot/dts/rk3288-miniarm.dts
index b999669c3ec7..c64bbb7da670 100644
--- a/arch/arm/boot/dts/rk3288-miniarm.dts
+++ b/arch/arm/boot/dts/rk3288-miniarm.dts
@@ -248,6 +248,10 @@
 	};
 };
 
+&hevc {
+	status = "okay";
+};
+
 &hevc_service {
 	status = "okay";
 };
@@ -653,6 +657,14 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
 &vopb_mmu {
 	status = "okay";
 };

From 9d61cd18ed85aa86ef72e6d92b587ffc99171671 Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Wed, 29 Nov 2017 11:32:45 +0800
Subject: [PATCH] [WIP]: ARM64: dts: rockchip: use the new video driver for
 rk3328

The encoders and avsd decoder are not verified.

Change-Id: Ie6883ee91e2eb7ce2eddafa1d6b42e2712cb1df6
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 arch/arm64/boot/dts/rockchip/rk3328.dtsi | 100 ++++++++++++++-----------------
 1 file changed, 45 insertions(+), 55 deletions(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3328.dtsi b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
index 066c404356a0..ff68946561fa 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3328.dtsi
@@ -761,17 +761,39 @@
 		*/
 	};
 
-	vdpu: vpu_service@ff350000 {
-		compatible = "vpu,sub";
-		iommu_enabled = <1>;
+	vpu_service: vdpu-srv {
+		compatible = "rockchip,mpp-service";
+		status = "disabled";
+	};
+
+	vdpu: vpu-decoder@ff350000 {
+		compatible = "rockchip,vpu-decoder-v2";
+		reg = <0x0 0xff350400 0x0 0x400>;
+		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "irq_dec";
+		resets = <&cru SRST_VCODEC_A>, <&cru SRST_VCODEC_H>;
+		reset-names = "video_a", "video_h";
+		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
 		iommus = <&vpu_mmu>;
-		allocator = <1>;
-		reg = <0x0 0xff350000 0x0 0x800>;
+		power-domains = <&power RK3328_PD_VPU>;
+		rockchip,srv = <&vpu_service>;
+		status = "disabled";
+	};
+
+	avsd: avs-decoder@ff351000 {
+		compatible = "rockchip,avs-decoder-v1";
+		reg = <0x0 0xff351000 0x0 0x200>;
 		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
 		interrupt-names = "irq_dec";
-		dev_mode = <0>;
+		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
+		clock-names = "aclk_vcodec", "hclk_vcodec";
+		resets = <&cru SRST_VCODEC_A>, <&cru SRST_VCODEC_H>;
+		reset-names = "video_a", "video_h";
 		power-domains = <&power RK3328_PD_VPU>;
-		name = "vpu_service";
+		iommus = <&vpu_mmu>;
+		rockchip,srv = <&vpu_service>;
+		status = "disabled";
 	};
 
 	vpu_mmu: iommu@ff350800 {
@@ -783,39 +805,16 @@
 		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
 		power-domains = <&power RK3328_PD_VPU>;
 		#iommu-cells = <0>;
+		status = "disabled";
 	};
 
-	avsd: avsd@ff351000 {
-		compatible = "vpu,sub";
-		iommu_enabled = <1>;
-		iommus = <&vpu_mmu>;
-		allocator = <1>;
-		reg = <0x0 0xff351000 0x0 0x200>;
-		interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
-		interrupt-names = "irq_dec";
-		power-domains = <&power RK3328_PD_VPU>;
-		dev_mode = <0>;
-		name = "avsd";
-	};
-
-	vpu_service: vpu_combo {
-		compatible = "rockchip,rk3328-vpu-combo", "rockchip,vpu_combo";
-		rockchip,grf = <&grf>;
-		subcnt = <2>;
-		rockchip,sub = <&vdpu>, <&avsd>;
-		clocks = <&cru ACLK_VPU>, <&cru HCLK_VPU>;
-		clock-names = "aclk_vcodec", "hclk_vcodec";
-		resets = <&cru SRST_VCODEC_A>, <&cru SRST_VCODEC_H>;
-		reset-names = "video_a", "video_h";
-		mode_bit = <0>;
-		mode_ctrl = <0>;
-		name = "vpu_combo";
-		power-domains = <&power RK3328_PD_VPU>;
+	rkvdec_srv: rkvdec-srv {
+		compatible = "rockchip,mpp-service";
 		status = "disabled";
 	};
 
 	rkvdec: rkvdec@ff36000 {
-		compatible = "rockchip,rk3328-rkvdec", "rockchip,rkvdec";
+		compatible = "rockchip,video-decoder-v1";
 		reg = <0x0 0xff360000 0x0 0x400>;
 		interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
 		interrupt-names = "irq_dec";
@@ -828,16 +827,15 @@
 			<&cru SRST_VDEC_CABAC>, <&cru SRST_VDEC_CORE>;
 		reset-names = "video_a", "video_h", "niu_a", "niu_h",
 			"video_cabac", "video_core";
-		rockchip,grf = <&grf>;
 		iommus = <&rkvdec_mmu>;
-		allocator = <1>;
 		power-domains = <&power RK3328_PD_VIDEO>;
+		rockchip,srv = <&rkvdec_srv>;
 		operating-points-v2 = <&rkvdec_opp_table>;
 		#cooling-cells = <2>;
 		devfreq = <&dmc>;
 		status = "disabled";
 
-		vcodec_power_model: vcodec_power_model {
+		vcodec_power_model: vcodec-power-model {
 			compatible = "vcodec_power_model";
 			dynamic-power-coefficient = <120>;
 			static-power-coefficient = <200>;
@@ -885,13 +883,11 @@
 		clock-names = "aclk", "hclk";
 		power-domains = <&power RK3328_PD_VIDEO>;
 		#iommu-cells = <0>;
+		status = "disabled";
 	};
 
 	h265e: h265e@ff330000 {
-		compatible = "rockchip,h265e";
-		rockchip,grf = <&grf>;
-		iommu_enabled = <1>;
-		iommus = <&h265e_mmu>;
+		compatible = "rockchip,hevc-encoder-v1";
 		reg = <0x0 0xff330000 0 0x200>;
 		interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&cru ACLK_H265>, <&cru PCLK_H265>,
@@ -899,11 +895,9 @@
 			<&cru ACLK_RKVENC>, <&cru ACLK_AXISRAM>;
 		clock-names = "aclk_h265", "pclk_h265", "clk_core",
 			"clk_dsp", "aclk_venc", "aclk_axi2sram";
+		iommus = <&h265e_mmu>;
 		rockchip,srv = <&venc_srv>;
-		mode_bit = <11>;
-		mode_ctrl = <0x40c>;
-		name = "h265e";
-		allocator = <1>;
+		syscon = <&grf 0x040c 0x8000800 0x80000>;
 		power-domains = <&power RK3328_PD_HEVC>;
 		status = "disabled";
 	};
@@ -920,10 +914,7 @@
 	};
 
 	vepu: vepu@ff340000 {
-		compatible = "rockchip,rk3328-vepu", "rockchip,vepu";
-		rockchip,grf = <&grf>;
-		iommu_enabled = <1>;
-		iommus = <&vepu_mmu>;
+		compatible = "rockchip,vpu-encoder-v2";
 		reg = <0x0 0xff340000 0x0 0x400>;
 		interrupts = <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
 		clocks = <&cru ACLK_H264>, <&cru HCLK_H264>,
@@ -933,11 +924,9 @@
 		resets = <&cru SRST_RKVENC_H264_H>,
 			<&cru SRST_RKVENC_H264_A>;
 		reset-names = "video_h", "video_a";
+		iommus = <&vepu_mmu>;
 		rockchip,srv = <&venc_srv>;
-		mode_bit = <11>;
-		mode_ctrl = <0x40c>;
-		name = "vepu";
-		allocator = <1>;
+		syscon = <&grf 0x040c 0x8000800 0x80000>;
 		power-domains = <&power RK3328_PD_HEVC>;
 		status = "disabled";
 	};
@@ -953,8 +942,9 @@
 		#iommu-cells = <0>;
 	};
 
-	venc_srv: venc_srv {
-		compatible = "rockchip,mpp_service";
+	venc_srv: venc-srv {
+		compatible = "rockchip,mpp-service";
+		status = "disabled";
 	};
 
 	vop: vop@ff370000 {

From 8e8cec62ef4d5b063db19797f0a316572438b123 Mon Sep 17 00:00:00 2001
From: Randy Li <randy.li@rock-chips.com>
Date: Wed, 29 Nov 2017 11:33:32 +0800
Subject: [PATCH] ARM64: dts: rockchip: use the new video driver for rk3328 evb

Change-Id: I7b8397175fe65ad5b18a95c85b1f36d2c19c5507
Signed-off-by: Randy Li <randy.li@rock-chips.com>
---
 arch/arm64/boot/dts/rockchip/rk3328-evb-android.dts | 16 ++++++++++++++++
 arch/arm64/boot/dts/rockchip/rk3328-evb.dts         | 16 ++++++++++++++++
 2 files changed, 32 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3328-evb-android.dts b/arch/arm64/boot/dts/rockchip/rk3328-evb-android.dts
index 9541778bc17b..f5281579d875 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-evb-android.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-evb-android.dts
@@ -553,6 +553,14 @@
 	vcodec-supply = <&vdd_logic>;
 };
 
+&rkvdec_mmu {
+	status = "okay";
+};
+
+&rkvdec_srv {
+	status = "okay";
+};
+
 &rockchip_suspend {
 	status = "okay";
 	rockchip,virtual-poweroff = <1>;
@@ -681,6 +689,14 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
+&vpu_mmu {
+	status = "okay";
+};
+
 &vpu_service {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-evb.dts b/arch/arm64/boot/dts/rockchip/rk3328-evb.dts
index a71b6cc116bb..ddf653cccf72 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-evb.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-evb.dts
@@ -545,6 +545,14 @@
 	status = "okay";
 };
 
+&rkvdec_mmu {
+	status = "okay";
+};
+
+&rkvdec_srv {
+	status = "okay";
+};
+
 &sdio {
 	bus-width = <4>;
 	cap-sd-highspeed;
@@ -642,6 +650,14 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
+&vpu_mmu {
+	status = "okay";
+};
+
 &vpu_service {
 	status = "okay";
 };

From 9ac1e27046a4774f5fc3b61849f6cc688f48a17d Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Fri, 15 Dec 2017 00:21:12 +0800
Subject: [PATCH] ARM64: dts: rockchip: enable new video driver for rock64

Change-Id: I15f632f12ca875331574ae5eefb031ed31c7c5e5
Signed-off-by: ayaka <ayaka@soulik.info>
---
 arch/arm64/boot/dts/rockchip/rk3328-rock64.dts | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
index dcac0d5ff1a6..11258c78205d 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-rock64.dts
@@ -491,6 +491,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &sdmmc {
 	bus-width = <4>;
 	cap-mmc-highspeed;
@@ -609,6 +613,10 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
 &vop {
 	status = "okay";
 };

From 0c6172f2c266bed9b9b6f8f370c67e00dc38d177 Mon Sep 17 00:00:00 2001
From: ayaka <ayaka@soulik.info>
Date: Sun, 3 Jun 2018 15:02:21 +0800
Subject: [PATCH] ARM64: dts: rockchip: enable new video driver on rockpro64

Signed-off-by: ayaka <ayaka@soulik.info>
---
 arch/arm64/boot/dts/rockchip/rk3399-rockpro64.dts | 14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-rockpro64.dts b/arch/arm64/boot/dts/rockchip/rk3399-rockpro64.dts
index 02b8ba7dcc94..d2423c875c8a 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399-rockpro64.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3399-rockpro64.dts
@@ -1085,6 +1085,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &rockchip_suspend {
 	status = "okay";
 	rockchip,sleep-debug-en = <0>;
@@ -1118,7 +1122,15 @@
 	status = "okay";
 };
 
-&vpu {
+&vdpu {
+	status = "okay";
+};
+
+&vepu {
+	status = "okay";
+};
+
+&vpu_service {
 	status = "okay";
 };
 

From d16f2ddb8ebad4e1eaf9cbe1d3edf4c5d40eba0c Mon Sep 17 00:00:00 2001
From: Jonas Karlman <jonas@kwiboo.se>
Date: Tue, 3 Jul 2018 23:13:17 +0200
Subject: [PATCH] ARM64: dts: rockchip: enable new video driver for rk3328
 devices

---
 arch/arm64/boot/dts/rockchip/rk3328-box-trn9.dts | 8 ++++++++
 arch/arm64/boot/dts/rockchip/rk3328-box-z28.dts  | 8 ++++++++
 arch/arm64/boot/dts/rockchip/rk3328-box.dts      | 8 ++++++++
 arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts   | 8 ++++++++
 arch/arm64/boot/dts/rockchip/rk3328-rockbox.dts  | 8 ++++++++
 5 files changed, 40 insertions(+)

diff --git a/arch/arm64/boot/dts/rockchip/rk3328-box-trn9.dts b/arch/arm64/boot/dts/rockchip/rk3328-box-trn9.dts
index da823ee47b6a..b9c474f641d9 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-box-trn9.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-box-trn9.dts
@@ -555,6 +555,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &sdmmc_ext {
 	bus-width = <4>;
 	cap-sd-highspeed;
@@ -665,6 +669,10 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
 &vop {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-box-z28.dts b/arch/arm64/boot/dts/rockchip/rk3328-box-z28.dts
index f94526f6f190..ca8f16d7da25 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-box-z28.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-box-z28.dts
@@ -469,6 +469,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &sdmmc {
 	bus-width = <4>;
 	cap-mmc-highspeed;
@@ -568,6 +572,10 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
 &vop {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-box.dts b/arch/arm64/boot/dts/rockchip/rk3328-box.dts
index 3587126087e5..401759f3e543 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-box.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-box.dts
@@ -497,6 +497,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &sdio {
 	bus-width = <4>;
 	cap-sd-highspeed;
@@ -613,6 +617,10 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
 &vop {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts b/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts
index d0db35366b68..5381d073d98e 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-roc-cc.dts
@@ -477,6 +477,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &sdmmc {
 	bus-width = <4>;
 	cap-mmc-highspeed;
@@ -563,6 +567,10 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
 &vop {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/rockchip/rk3328-rockbox.dts b/arch/arm64/boot/dts/rockchip/rk3328-rockbox.dts
index 75f890e548e5..2fd55e595b11 100644
--- a/arch/arm64/boot/dts/rockchip/rk3328-rockbox.dts
+++ b/arch/arm64/boot/dts/rockchip/rk3328-rockbox.dts
@@ -443,6 +443,10 @@
 	status = "okay";
 };
 
+&rkvdec_srv {
+	status = "okay";
+};
+
 &sdio {
 	bus-width = <4>;
 	cap-sd-highspeed;
@@ -553,6 +557,10 @@
 	status = "okay";
 };
 
+&vdpu {
+	status = "okay";
+};
+
 &vop {
 	status = "okay";
 };
