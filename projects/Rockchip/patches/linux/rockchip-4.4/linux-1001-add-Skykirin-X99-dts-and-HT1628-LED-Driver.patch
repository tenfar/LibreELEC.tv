From 0e7d43a550273addcc95e20f4a80b8e1bbbb9834 Mon Sep 17 00:00:00 2001
From: Tenfar Lin <tenfar@gmail.com>
Date: Sat, 26 May 2018 19:54:42 +0800
Subject: [PATCH] add Skykirin X99 dts and HT1628 LED Driver

---
 .../arm64/boot/dts/rockchip/rk3399-skykirinx99.dts | 1093 ++++++++++++++++++++
 arch/arm64/boot/dts/rockchip/rk3399.dtsi           |    9 +-
 drivers/Kconfig                                    |    1 +
 drivers/Makefile                                   |    1 +
 drivers/skykirin/Kconfig                           |   14 +
 drivers/skykirin/Makefile                          |    7 +
 drivers/skykirin/skykirin-ht1628.c                 |  430 ++++++++
 include/linux/skykirin-ht1628.h                    |  179 ++++
 8 files changed, 1730 insertions(+), 4 deletions(-)
 create mode 100644 arch/arm64/boot/dts/rockchip/rk3399-skykirinx99.dts
 create mode 100644 drivers/skykirin/Kconfig
 create mode 100644 drivers/skykirin/Makefile
 create mode 100644 drivers/skykirin/skykirin-ht1628.c
 create mode 100644 include/linux/skykirin-ht1628.h

diff --git a/arch/arm64/boot/dts/rockchip/rk3399-skykirinx99.dts b/arch/arm64/boot/dts/rockchip/rk3399-skykirinx99.dts
new file mode 100644
index 0000000..6139158
--- /dev/null
+++ b/arch/arm64/boot/dts/rockchip/rk3399-skykirinx99.dts
@@ -0,0 +1,1093 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include <dt-bindings/pwm/pwm.h>
+#include <dt-bindings/input/input.h>
+#include "rk3399.dtsi"
+#include "rk3399-linux.dtsi"
+#include "rk3399-opp.dtsi"
+
+
+/ {
+	model = "SkyKirin X99 TV BOX";
+	compatible = "skykirin,x99","rockchip,rk3399";
+
+	skykirin_led {
+		compatible = "skykirin-ht1628";
+		spi_clk = <&gpio1 RK_PB1 GPIO_ACTIVE_HIGH>;
+		spi_cs = <&gpio1 RK_PB2 GPIO_ACTIVE_HIGH>;
+		spi_data = <&gpio1 RK_PB0 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+	
+	gpio-leds {
+		compatible = "gpio-leds";
+
+		led@1 {
+			gpios = <&gpio4 RK_PC2 GPIO_ACTIVE_HIGH>;
+			label = "power-green";
+			default-state = "off";  
+			retain-state-suspended;
+		};
+	};
+
+	vcc1v8_s0: vcc1v8-s0 {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc1v8_s0";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+	};
+
+	vcc_sys: vcc-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_sys";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	vcc_phy: vcc-phy-regulator {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc_phy";
+		regulator-always-on;
+		regulator-boot-on;
+	};
+
+	vcc3v3_sys: vcc3v3-sys {
+		compatible = "regulator-fixed";
+		regulator-name = "vcc3v3_sys";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		vin-supply = <&vcc_sys>;
+	};
+
+	vcc5v0_host: vcc5v0-host-regulator {
+		compatible = "regulator-fixed";
+		enable-active-high;
+		gpio = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&host_vbus_drv>;
+		regulator-name = "vcc5v0_host";
+		regulator-always-on;
+	};
+
+	vdd_log: vdd-log {
+		compatible = "pwm-regulator";
+		pwms = <&pwm2 0 25000 1>;
+		regulator-name = "vdd_log";
+		regulator-min-microvolt = <800000>;
+		regulator-max-microvolt = <1400000>;
+		regulator-always-on;
+		regulator-boot-on;
+
+		/* for rockchip boot on */
+		rockchip,pwm_id= <2>;
+		rockchip,pwm_voltage = <900000>;
+
+		vin-supply = <&vcc_sys>;
+	};
+
+	clkin_gmac: external-gmac-clock {
+		compatible = "fixed-clock";
+		clock-frequency = <125000000>;
+		clock-output-names = "clkin_gmac";
+		#clock-cells = <0>;
+	};
+
+	hdmi-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,format = "i2s";
+		simple-audio-card,mclk-fs = <128>;
+		simple-audio-card,name = "HDMI";
+		simple-audio-card,cpu {
+			sound-dai = <&i2s2>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&hdmi>;
+		};
+	};
+
+	spdif-sound {
+		compatible = "simple-audio-card";
+		simple-audio-card,name = "ROCKCHIP,SPDIF";
+                status = "okay";
+		simple-audio-card,cpu {
+			sound-dai = <&spdif>;
+		};
+		simple-audio-card,codec {
+			sound-dai = <&spdif_out>;
+		};
+	};
+
+	spdif_out: spdif-out {
+		compatible = "linux,spdif-dit";
+		#sound-dai-cells = <0>;
+		status = "okay";
+	};
+
+	sdio_pwrseq: sdio-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		pinctrl-names = "default";
+		pinctrl-0 = <&wifi_enable_h>;
+
+
+		/*
+		 * On the module itself this is one of these (depending
+		 * on the actual card populated):
+		 * - SDIO_RESET_L_WL_REG_ON
+		 * - PDN (power down when low)
+		 */
+		reset-gpios = <&gpio0 10 GPIO_ACTIVE_LOW>;
+	};
+
+	wireless-wlan {
+		compatible = "wlan-platdata";
+		rockchip,grf = <&grf>;
+		wifi_chip_type = "ap6354";
+		sdio_vref = <1800>;
+		WIFI,host_wake_irq = <&gpio0 3 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless-bluetooth {
+		compatible = "bluetooth-platdata";
+		clocks = <&rk808 1>;
+		clock-names = "ext_clock";
+		/* wifi-bt-power-toggle; */
+		uart_rts_gpios = <&gpio2 19 GPIO_ACTIVE_LOW>;
+		pinctrl-names = "default", "rts_gpio";
+		pinctrl-0 = <&uart0_rts>;
+		pinctrl-1 = <&uart0_gpios>;
+		/* BT,power_gpio  = <&gpio3 19 GPIO_ACTIVE_HIGH>; */
+		BT,reset_gpio    = <&gpio0 9 GPIO_ACTIVE_HIGH>;
+		BT,wake_gpio     = <&gpio2 26 GPIO_ACTIVE_HIGH>;
+		BT,wake_host_irq = <&gpio0 4 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	test-power {
+		status = "okay";
+	};
+	
+		rockchip-key {
+		compatible = "rockchip,key";
+		io-channels = <&saradc 0x1>;
+		status = "okay";
+
+		back-key {
+			label = "back";
+			linux,code = <0x9e>;
+			rockchip,adc_value = <0x230>;
+		};
+
+		camera-key {
+			label = "camera";
+			linux,code = <0xd4>;
+			rockchip,adc_value = <0x1c2>;
+		};
+
+		home-key {
+			label = "home";
+			linux,code = <0x66>;
+			rockchip,adc_value = <0x163>;
+		};
+
+		menu-key {
+			label = "menu";
+			linux,code = <0x3b>;
+			rockchip,adc_value = <0x2ea>;
+		};
+
+		power-key {
+			gpio-key,wakeup;
+			gpios = <&gpio0 0x5 0x1>;
+			label = "power";
+			linux,code = <0x74>;
+		};
+
+		vol-down-key {
+			label = "volume down";
+			linux,code = <0x72>;
+			rockchip,adc_value = <0xaa>;
+		};
+
+		vol-up-key {
+			label = "volume up";
+			linux,code = <0x73>;
+			rockchip,adc_value = <0x1>;
+		};
+	};
+};
+
+&hdmi {
+	#address-cells = <1>;
+	#size-cells = <0>;
+	#sound-dai-cells = <0>;
+	status = "okay";
+};
+
+&sdmmc {
+	clock-frequency = <100000000>;
+	clock-freq-min-max = <100000 100000000>;
+	supports-sd;
+	bus-width = <4>;
+	cap-mmc-highspeed;
+	cap-sd-highspeed;
+	disable-wp;
+	num-slots = <1>;
+	//sd-uhs-sdr104;
+	vqmmc-supply = <&vcc_sd>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdmmc_clk &sdmmc_cmd &sdmmc_cd &sdmmc_bus4>;
+	card-detect-delay = <800>;
+	status = "okay";
+};
+
+&sdio0 {
+	clock-frequency = <100000000>;
+	clock-freq-min-max = <200000 100000000>;
+	supports-sdio;
+	bus-width = <4>;
+	disable-wp;
+	cap-sd-highspeed;
+	cap-sdio-irq;
+	keep-power-in-suspend;
+	mmc-pwrseq = <&sdio_pwrseq>;
+	non-removable;
+	num-slots = <1>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&sdio0_bus4 &sdio0_cmd &sdio0_clk>;
+	sd-uhs-sdr104;
+	status = "okay";
+};
+
+&emmc_phy {
+	status = "okay";
+};
+
+&sdhci {
+	bus-width = <8>;
+	mmc-hs400-1_8v;
+	supports-emmc;
+	non-removable;
+	mmc-hs400-enhanced-strobe;
+	status = "okay";
+};
+
+&i2s0 {
+	status = "okay";
+	rockchip,i2s-broken-burst-len;
+	rockchip,playback-channels = <8>;
+	rockchip,capture-channels = <8>;
+	#sound-dai-cells = <0>;
+};
+
+&i2s2 {
+	#sound-dai-cells = <0>;
+	rockchip,bclk-fs = <128>;
+	status = "okay";
+};
+
+&spdif {
+	pinctrl-0 = <&spdif_bus_1>;
+	status = "okay";
+	#sound-dai-cells = <0>;
+};
+
+&i2c0 {
+	status = "okay";
+	i2c-scl-rising-time-ns = <168>;
+	i2c-scl-falling-time-ns = <4>;
+	clock-frequency = <400000>;
+
+	vdd_cpu_b: syr827@40 {
+		compatible = "silergy,syr827";
+		reg = <0x40>;
+		regulator-compatible = "fan53555-reg";
+		pinctrl-0 = <&vsel1_gpio>;
+		vsel-gpios = <&gpio1 17 GPIO_ACTIVE_HIGH>;
+		regulator-name = "vdd_cpu_b";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vcc_sys>;
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	vdd_gpu: syr828@41 {
+		compatible = "silergy,syr828";
+		reg = <0x41>;
+		regulator-compatible = "fan53555-reg";
+		pinctrl-0 = <&vsel2_gpio>;
+		vsel-gpios = <&gpio1 14 GPIO_ACTIVE_HIGH>;
+		regulator-name = "vdd_gpu";
+		regulator-min-microvolt = <712500>;
+		regulator-max-microvolt = <1500000>;
+		regulator-ramp-delay = <1000>;
+		fcs,suspend-voltage-selector = <1>;
+		regulator-always-on;
+		regulator-boot-on;
+		vin-supply = <&vcc_sys>;
+		regulator-initial-mode = <1>; /* 1:force PWM 2:auto */
+		regulator-state-mem {
+			regulator-off-in-suspend;
+		};
+	};
+
+	rk808: pmic@1b {
+		compatible = "rockchip,rk808";
+		reg = <0x1b>;
+		interrupt-parent = <&gpio1>;
+		interrupts = <21 IRQ_TYPE_LEVEL_LOW>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&pmic_int_l>;
+		rockchip,system-power-controller;
+		wakeup-source;
+		#clock-cells = <1>;
+		clock-output-names = "xin32k", "rk808-clkout2";
+
+		vcc1-supply = <&vcc_sys>;
+		vcc2-supply = <&vcc_sys>;
+		vcc3-supply = <&vcc_sys>;
+		vcc4-supply = <&vcc_sys>;
+		vcc6-supply = <&vcc_sys>;
+		vcc7-supply = <&vcc_sys>;
+		vcc8-supply = <&vcc3v3_sys>;
+		vcc9-supply = <&vcc_sys>;
+		vcc10-supply = <&vcc_sys>;
+		vcc11-supply = <&vcc_sys>;
+		vcc12-supply = <&vcc3v3_sys>;
+		vddio-supply = <&vcc_1v8>;
+
+		regulators {
+			vdd_center: DCDC_REG1 {
+				regulator-name = "vdd_center";
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vdd_cpu_l: DCDC_REG2 {
+				regulator-name = "vdd_cpu_l";
+				regulator-min-microvolt = <750000>;
+				regulator-max-microvolt = <1350000>;
+				regulator-ramp-delay = <6001>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-off-in-suspend;
+				};
+			};
+
+			vcc_ddr: DCDC_REG3 {
+				regulator-name = "vcc_ddr";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc_1v8: DCDC_REG4 {
+				regulator-name = "vcc_1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc1v8_dvp: LDO_REG1 {
+				regulator-name = "vcc1v8_dvp";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcca1v8_hdmi: LDO_REG2 {
+				regulator-name = "vcca1v8_hdmi";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcca_1v8: LDO_REG3 {
+				regulator-name = "vcca_1v8";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1800000>;
+				};
+			};
+
+			vcc_sd: LDO_REG4 {
+				regulator-name = "vcc_sd";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3300000>;
+				};
+			};
+
+			vcc3v0_sd: LDO_REG5 {
+				regulator-name = "vcc3v0_sd";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc_1v5: LDO_REG6 {
+				regulator-name = "vcc_1v5";
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <1500000>;
+				};
+			};
+
+			vcca0v9_hdmi: LDO_REG7 {
+				regulator-name = "vcca0v9_hdmi";
+				regulator-min-microvolt = <900000>;
+				regulator-max-microvolt = <900000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <900000>;
+				};
+			};
+
+			vcc_3v0: LDO_REG8 {
+				regulator-name = "vcc_3v0";
+				regulator-min-microvolt = <3000000>;
+				regulator-max-microvolt = <3000000>;
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+					regulator-suspend-microvolt = <3000000>;
+				};
+			};
+
+			vcc3v3_s3: SWITCH_REG1 {
+				regulator-name = "vcc3v3_s3";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+
+			vcc3v3_s0: SWITCH_REG2 {
+				regulator-name = "vcc3v3_s0";
+				regulator-always-on;
+				regulator-boot-on;
+				regulator-state-mem {
+					regulator-on-in-suspend;
+				};
+			};
+		};
+	};
+};
+
+&i2c1 {
+	status = "okay";
+};
+
+&i2c7 {
+	status = "okay";
+};
+
+&i2c4 {
+	status = "okay";
+	fusb0: fusb30x@22 {
+		compatible = "fairchild,fusb302";
+		reg = <0x22>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&fusb0_int>;
+		vbus-5v-gpios = <&gpio1 3 GPIO_ACTIVE_LOW>;
+		int-n-gpios = <&gpio1 2 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+};
+
+&i2c2 {
+	status = "okay";
+	camera0: camera-module@10 {
+		status = "disabled";
+		compatible = "omnivision,ov13850-v4l2-i2c-subdev";
+		reg = < 0x10 >;
+		device_type = "v4l2-i2c-subdev";
+		clocks = <&cru SCLK_CIF_OUT>;
+		clock-names = "clk_cif_out";
+		pinctrl-names = "rockchip,camera_default",
+				"rockchip,camera_sleep";
+		pinctrl-0 = <&cam0_default_pins>;
+		pinctrl-1 = <&cam0_sleep_pins>;
+		//rockchip,pd-gpio = <&gpio4 4 GPIO_ACTIVE_LOW>;
+		rockchip,pwr-gpio = <&gpio4 4 GPIO_ACTIVE_HIGH>;
+		rockchip,rst-gpio = <&gpio3 29 GPIO_ACTIVE_LOW>;
+		rockchip,camera-module-mclk-name = "clk_cif_out";
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "cmk-cb0695-fv1";
+		rockchip,camera-module-len-name = "lg9569a2";
+		rockchip,camera-module-fov-h = "66.0";
+		rockchip,camera-module-fov-v = "50.1";
+		rockchip,camera-module-orientation = <0>;
+		rockchip,camera-module-iq-flip = <0>;
+		rockchip,camera-module-iq-mirror = <0>;
+		rockchip,camera-module-flip = <1>;
+		rockchip,camera-module-mirror = <0>;
+
+		rockchip,camera-module-defrect0 = <2112 1568 0 0 2112 1568>;
+		rockchip,camera-module-defrect1 = <4224 3136 0 0 4224 3136>;
+		rockchip,camera-module-defrect3 = <3264 2448 0 0 3264 2448>;
+		rockchip,camera-module-flash-support = <1>;
+		rockchip,camera-module-mipi-dphy-index = <0>;
+	};
+
+	camera1: camera-module@36 {
+		status = "disabled";
+		compatible = "omnivision,ov4690-v4l2-i2c-subdev";
+		reg = <0x36>;
+		device_type = "v4l2-i2c-subdev";
+		clocks = <&cru SCLK_CIF_OUT>;
+		clock-names = "clk_cif_out";
+		pinctrl-names = "rockchip,camera_default",
+				"rockchip,camera_sleep";
+		pinctrl-0 = <&cam0_default_pins>;
+		pinctrl-1 = <&cam0_sleep_pins>;
+		rockchip,pd-gpio = <&gpio3 4 GPIO_ACTIVE_LOW>;
+		//rockchip,pwr-gpio = <&gpio3 13 0>;
+		rockchip,rst-gpio = <&gpio2 10 GPIO_ACTIVE_LOW>;
+		rockchip,camera-module-mclk-name = "clk_cif_out";
+		rockchip,camera-module-facing = "back";
+		rockchip,camera-module-name = "LA6111PA";
+		rockchip,camera-module-len-name = "YM6011P";
+		rockchip,camera-module-fov-h = "116";
+		rockchip,camera-module-fov-v = "61";
+		rockchip,camera-module-orientation = <0>;
+		rockchip,camera-module-iq-flip = <0>;
+		rockchip,camera-module-iq-mirror = <0>;
+		rockchip,camera-module-flip = <0>;
+		rockchip,camera-module-mirror = <1>;
+
+		rockchip,camera-module-defrect0 = <2688 1520 0 0 2688 1520>;
+		rockchip,camera-module-flash-support = <0>;
+		rockchip,camera-module-mipi-dphy-index = <0>;
+	};
+
+};
+
+&i2c7 {
+	status = "okay";
+};
+
+&cpu_l0 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l1 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l2 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_l3 {
+	cpu-supply = <&vdd_cpu_l>;
+};
+
+&cpu_b0 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&cpu_b1 {
+	cpu-supply = <&vdd_cpu_b>;
+};
+
+&gpu {
+	status = "okay";
+	mali-supply = <&vdd_gpu>;
+};
+
+&threshold {
+	temperature = <85000>;
+};
+
+&target {
+	temperature = <100000>;
+};
+
+&soc_crit {
+	temperature = <105000>;
+};
+
+&tcphy0 {
+	extcon = <&fusb0>;
+	status = "okay";
+};
+
+&tcphy1 {
+	status = "okay";
+};
+
+&tsadc {
+	/* tshut mode 0:CRU 1:GPIO */
+	rockchip,hw-tshut-mode = <1>;
+	/* tshut polarity 0:LOW 1:HIGH */
+	rockchip,hw-tshut-polarity = <1>;
+	rockchip,hw-tshut-temp = <110000>;
+	status = "okay";
+};
+
+&u2phy0 {
+	status = "okay";
+	extcon = <&fusb0>;
+
+	u2phy0_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy0_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&u2phy1 {
+	status = "okay";
+
+	u2phy1_otg: otg-port {
+		status = "okay";
+	};
+
+	u2phy1_host: host-port {
+		phy-supply = <&vcc5v0_host>;
+		status = "okay";
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_xfer &uart0_cts>;
+	status = "okay";
+};
+
+&uart2 {
+	status = "okay";
+};
+
+&usb_host0_ehci {
+	status = "okay";
+};
+
+&usb_host0_ohci {
+	status = "okay";
+};
+
+&usb_host1_ehci {
+	status = "okay";
+};
+
+&usb_host1_ohci {
+	status = "okay";
+};
+
+&usbdrd3_0 {
+	extcon = <&fusb0>;
+	status = "okay";
+};
+
+&usbdrd_dwc3_0 {
+	dr_mode = "otg";
+	status = "okay";
+};
+
+&usbdrd3_1 {
+	status = "okay";
+};
+
+&usbdrd_dwc3_1 {
+	dr_mode = "host";
+	status = "okay";
+};
+
+&pwm2 {
+	status = "okay";
+};
+
+&gmac {
+	phy-supply = <&vcc_phy>;
+	phy-mode = "rgmii";
+	clock_in_out = "input";
+	snps,reset-gpio = <&gpio3 15 GPIO_ACTIVE_LOW>;
+	snps,reset-active-low;
+	snps,reset-delays-us = <0 10000 50000>;
+	assigned-clocks = <&cru SCLK_RMII_SRC>;
+	assigned-clock-parents = <&clkin_gmac>;
+	pinctrl-names = "default", "sleep";
+	pinctrl-0 = <&rgmii_pins>;
+	pinctrl-1 = <&rgmii_sleep_pins>;
+	tx_delay = <0x28>;
+	rx_delay = <0x11>;
+	status = "okay";
+};
+
+&saradc {
+	status = "okay";
+};
+
+&io_domains {
+	status = "okay";
+
+	bt656-supply = <&vcc1v8_s0>; /* bt656_gpio2ab_ms */
+	audio-supply = <&vcc1v8_s0>; /* audio_gpio3d4a_ms */
+	sdmmc-supply = <&vcc_sd>; /* sdmmc_gpio4b_ms */
+	gpio1830-supply = <&vcc_3v0>; /* gpio1833_gpio4cd_ms */
+};
+
+
+&pinctrl {
+
+	sdio0 {
+		sdio0_bus1: sdio0-bus1 {
+			rockchip,pins =
+				<2 20 RK_FUNC_1 &pcfg_pull_up_20ma>;
+		};
+
+		sdio0_bus4: sdio0-bus4 {
+			rockchip,pins =
+				<2 20 RK_FUNC_1 &pcfg_pull_up_20ma>,
+				<2 21 RK_FUNC_1 &pcfg_pull_up_20ma>,
+				<2 22 RK_FUNC_1 &pcfg_pull_up_20ma>,
+				<2 23 RK_FUNC_1 &pcfg_pull_up_20ma>;
+		};
+
+		sdio0_cmd: sdio0-cmd {
+			rockchip,pins =
+				<2 24 RK_FUNC_1 &pcfg_pull_up_20ma>;
+		};
+
+		sdio0_clk: sdio0-clk {
+			rockchip,pins =
+				<2 25 RK_FUNC_1 &pcfg_pull_none_20ma>;
+		};
+	};
+
+	sdmmc {
+		sdmmc_bus1: sdmmc-bus1 {
+			rockchip,pins =
+				<4 8 RK_FUNC_1 &pcfg_pull_up_8ma>;
+		};
+
+		sdmmc_bus4: sdmmc-bus4 {
+			rockchip,pins =
+				<4 8 RK_FUNC_1 &pcfg_pull_up_8ma>,
+				<4 9 RK_FUNC_1 &pcfg_pull_up_8ma>,
+				<4 10 RK_FUNC_1 &pcfg_pull_up_8ma>,
+				<4 11 RK_FUNC_1 &pcfg_pull_up_8ma>;
+		};
+
+		sdmmc_clk: sdmmc-clk {
+			rockchip,pins =
+				<4 12 RK_FUNC_1 &pcfg_pull_none_18ma>;
+		};
+
+		sdmmc_cmd: sdmmc-cmd {
+			rockchip,pins =
+				<4 13 RK_FUNC_1 &pcfg_pull_up_8ma>;
+		};
+	};
+
+	sdio-pwrseq {
+		wifi_enable_h: wifi-enable-h {
+			rockchip,pins =
+				<0 10 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	wireless-bluetooth {
+		uart0_gpios: uart0-gpios {
+			rockchip,pins =
+				<2 19 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+	usb2 {
+		host_vbus_drv: host-vbus-drv {
+			rockchip,pins =
+				<4 25 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+
+
+	pmic {
+		pmic_int_l: pmic-int-l {
+			rockchip,pins =
+				<1 21 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		vsel1_gpio: vsel1-gpio {
+			rockchip,pins =
+				<1 17 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+
+		vsel2_gpio: vsel2-gpio {
+			rockchip,pins =
+				<1 14 RK_FUNC_GPIO &pcfg_pull_down>;
+		};
+	};
+
+	gmac {
+		rgmii_sleep_pins: rgmii-sleep-pins {
+			rockchip,pins =
+				<3 15 RK_FUNC_GPIO &pcfg_output_low>;
+		};
+	};
+
+	fusb30x {
+		fusb0_int: fusb0-int {
+			rockchip,pins =
+				<1 2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+	};
+	pwm0 {
+			pwm0_pin: pwm0-pin {
+				rockchip,pins =
+					<4 18 RK_FUNC_1 &pcfg_pull_none>;
+			};
+
+			vop0_pwm_pin: vop0-pwm-pin {
+				rockchip,pins =
+					<4 18 RK_FUNC_2 &pcfg_pull_none>;
+			};
+
+
+		};
+
+	pwm1 {
+			pwm1_pin: pwm1-pin {
+				rockchip,pins =
+					<4 22 RK_FUNC_1 &pcfg_pull_none>;
+			};
+			vop1_pwm_pin: vop1-pwm-pin {
+				rockchip,pins =
+					<4 18 RK_FUNC_3 &pcfg_pull_none>;
+			};
+		};
+};
+
+&pvtm {
+	status = "okay";
+};
+
+&pmu_pvtm {
+	status = "okay";
+};
+
+&pmu_io_domains {
+	status = "okay";
+	pmu1830-supply = <&vcc_1v8>;
+};
+
+&rockchip_suspend {
+	status = "okay";
+	rockchip,sleep-debug-en = <0>;
+	rockchip,sleep-mode-config = <
+		(0
+		| RKPM_SLP_ARMPD
+		| RKPM_SLP_PERILPPD
+		| RKPM_SLP_DDR_RET
+		| RKPM_SLP_PLLPD
+		| RKPM_SLP_CENTER_PD
+		| RKPM_SLP_AP_PWROFF
+		)
+	>;
+	rockchip,wakeup-config = <
+		(0
+		| RKPM_GPIO_WKUP_EN
+		| RKPM_PWM_WKUP_EN
+		)
+	>;
+	rockchip,pwm-regulator-config = <
+		(0
+		| PWM2_REGULATOR_EN
+		)
+	>;
+	rockchip,power-ctrl =
+		<&gpio1 17 GPIO_ACTIVE_HIGH>,
+		<&gpio1 14 GPIO_ACTIVE_HIGH>;
+};
+
+&vopb {
+	status = "okay";
+};
+
+
+&vopl {
+    status = "okay";
+};
+
+
+&vopl_mmu {
+    status = "okay";
+};
+
+&vopb_mmu {
+	status = "okay";
+};
+
+&cif_isp0 {
+	rockchip,camera-modules-attached = <&camera0>;
+	status = "okay";
+};
+
+&isp0_mmu {
+	status = "okay";
+};
+
+&cif_isp1 {
+	rockchip,camera-modules-attached = <&camera1>;
+	status = "disabled";
+};
+
+&isp1_mmu {
+	status = "okay";
+};
+
+&vpu {
+	status = "okay";
+	/* 0 means ion, 1 means drm */
+	//allocator = <0>;
+};
+
+&rkvdec {
+	status = "okay";
+	/* 0 means ion, 1 means drm */
+	//allocator = <0>;
+};
+
+&display_subsystem {
+	status = "okay";
+};
+	
+&pwm3 {
+		compatible = "rockchip,remotectl-pwm";
+		handle_cpu_id = <0x1>;
+		interrupts = <GIC_SPI 0x3d IRQ_TYPE_LEVEL_HIGH 0>;
+		pinctrl-0 = <&pwm3a_pin>;
+		pinctrl-names = "active";
+		reg = <0x0 0xff420030 0x0 0x10>;
+		remote_pwm_id = <0x3>;
+		remote_support_psci = <0x1>;
+		status = "okay";
+
+		ir_key1 {
+			rockchip,key_table = <0xf2 0xe8 0xba 0x9e 0xf4 0x67 0xf1 0x6c 0xef 0x69 0xee 0x6a 0xbd 0x66 0xea 0x73 0xe3 0x72 0xe2 0xd9 0xb2 0x74 0xbc 0x71 0xec 0x8b 0xbf 0x190 0xe0 0x191 0xe1 0x192 0xe9 0xb7 0xe6 0xf8 0xe8 0xb9 0xe7 0xba 0xf0 0x184 0xbe 0x175>;
+			rockchip,usercode = <0x4040>;
+		};
+		ir_key12 {
+			rockchip,key_table = <0xec 0xe8 0xd8 0x9e 0xc7 0x67 0xbf 0x6c 0xc8 0x69 0xc6 0x6a 0x8c 0x66 0x78 0x73 0x76 0x72 0x7e 0x74 0xed 0x74 0x7c 0x8b 0xb7 0x184>;
+			rockchip,usercode = <0x7f80>;
+		};
+		ir_key13 {
+			rockchip,key_table = <0x7e 0x74>;
+			rockchip,usercode = <0x807f>;
+		};
+		ir_key2 {
+			rockchip,key_table = <0xf9 0x66 0xbf 0x9e 0xfb 0x8b 0xaa 0xe8 0xb9 0x67 0xe9 0x6c 0xb8 0x69 0xea 0x6a 0xeb 0x72 0xef 0x73 0xf7 0x71 0xe7 0x74 0xfc 0x74 0xa9 0x72 0xa8 0x72 0xe0 0x72 0xa5 0x72 0xab 0xb7 0xb7 0x184 0xe8 0x184 0xf8 0xb8 0xaf 0xb9 0xed 0x72 0xee 0xba 0xb3 0x72 0xf1 0x72 0xf2 0x72 0xf3 0xd9 0xb4 0x72 0xbe 0xd9>;
+			rockchip,usercode = <0xff00>;
+		};
+		ir_key3 {
+			rockchip,key_table = <0xee 0xe8 0xf0 0x9e 0xf8 0x67 0xbb 0x6c 0xef 0x69 0xed 0x6a 0xfc 0x66 0xf1 0x73 0xfd 0x72 0xb7 0xd9 0xff 0x74 0xf3 0x71 0xbf 0x8b 0xf9 0x191 0xf5 0x192 0xb3 0x184 0xbe 0x2 0xba 0x3 0xb2 0x4 0xbd 0x5 0xf9 0x6 0xb1 0x7 0xfc 0x8 0xf8 0x9 0xb0 0xa 0xb6 0xb 0xb5 0xe>;
+			rockchip,usercode = <0x1dcc>;
+		};
+		ir_key6 {
+			rockchip,key_table = <0xec 0xe8 0xe6 0x9e 0xe9 0x67 0xe5 0x6c 0xae 0x69 0xaf 0x6a 0xee 0x66 0xe7 0x73 0xef 0x72 0xbf 0x74 0xbe 0x71 0xb3 0x8b 0xff 0x184 0xb1 0x2 0xf2 0x3 0xf3 0x4 0xb5 0x5 0xf6 0x6 0xf7 0x7 0xb9 0x8 0xfa 0x9 0xfb 0xa 0xfe 0xb 0xbd 0xe 0xbc 0xb7 0xf0 0xb8>;
+			rockchip,usercode = <0xfe01>;
+		};
+	};
diff --git a/arch/arm64/boot/dts/rockchip/rk3399.dtsi b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
index 124a911..16abf9d 100644
--- a/arch/arm64/boot/dts/rockchip/rk3399.dtsi
+++ b/arch/arm64/boot/dts/rockchip/rk3399.dtsi
@@ -2809,10 +2809,7 @@
 					<4 18 RK_FUNC_2 &pcfg_pull_none>;
 			};
 
-			vop1_pwm_pin: vop1-pwm-pin {
-				rockchip,pins =
-					<4 18 RK_FUNC_3 &pcfg_pull_none>;
-			};
+
 		};
 
 		pwm1 {
@@ -2825,6 +2822,10 @@
 				rockchip,pins =
 					<4 22 RK_FUNC_1 &pcfg_pull_down>;
 			};
+			vop1_pwm_pin: vop1-pwm-pin {
+				rockchip,pins =
+					<4 18 RK_FUNC_3 &pcfg_pull_none>;
+			};
 		};
 
 		pwm2 {
diff --git a/drivers/Kconfig b/drivers/Kconfig
index 4f5b623..5220ecc 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -206,4 +206,5 @@ source "drivers/rk_nand/Kconfig"
 
 source "drivers/headset_observe/Kconfig"
 
+source "drivers/skykirin/Kconfig"
 endmenu
diff --git a/drivers/Makefile b/drivers/Makefile
index 02834d4..bc3f813 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -178,3 +178,4 @@ obj-$(CONFIG_RK_NAND)		+= rk_nand/
 obj-$(CONFIG_RK_HEADSET)	+= headset_observe/
 obj-$(CONFIG_RK_FLASH)          += rkflash/
 obj-y                           += rk_nand/
+obj-$(CONFIG_SKYKIRIN)          += skykirin/
diff --git a/drivers/skykirin/Kconfig b/drivers/skykirin/Kconfig
new file mode 100644
index 0000000..2f8b70d
--- /dev/null
+++ b/drivers/skykirin/Kconfig
@@ -0,0 +1,14 @@
+menuconfig SKYKIRIN
+	bool "Skykirin Support"
+	help
+	  This option enable Skykirin HT1628
+
+if SKYKIRIN
+
+config SKYKIRIN_HT1628
+	bool "SKYKIRIN HT1628 LED Support"
+	default y
+	help
+	  SkyKirin HT1628 LED Controller Support.
+
+endif
diff --git a/drivers/skykirin/Makefile b/drivers/skykirin/Makefile
new file mode 100644
index 0000000..68d64a3
--- /dev/null
+++ b/drivers/skykirin/Makefile
@@ -0,0 +1,7 @@
+#
+# Makefile for SkyKirin HT1628 drivers.
+#
+
+obj-$(CONFIG_SKYKIRIN_HT1628) += skykirin-ht1628.o
+
+
diff --git a/drivers/skykirin/skykirin-ht1628.c b/drivers/skykirin/skykirin-ht1628.c
new file mode 100644
index 0000000..0a33915
--- /dev/null
+++ b/drivers/skykirin/skykirin-ht1628.c
@@ -0,0 +1,430 @@
+/*
+ * Skykirin HT1628 LED Controller Driver
+ *
+ * Copyright (C) 2017,2018 Tenfar Lin
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/gpio/machine.h>
+#include <linux/skykirin-ht1628.h>
+
+#ifndef DRIVER_NAME
+#define DRIVER_NAME	"skykirin-ht1628"
+
+#endif
+
+static struct file_operations skykirin_ht1628_fops = {
+	.unlocked_ioctl = skykirin_ht1628_ioctl,
+	.compat_ioctl = skykirin_ht1628_ioctl,
+	.open  = skykirin_ht1628_open,
+	.release = skykirin_ht1628_release,
+	
+	
+};
+
+struct skykirin_ht1628_priv *ht1628_priv;
+
+static const struct of_device_id skykirin_ht1628_dt_ids[] = {
+	{ .compatible = "skykirin-ht1628" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, skykirin_ht1628_dt_ids);
+
+static int skykirin_ht1628_probe_dt(struct platform_device *pdev)
+{
+	int ret;
+	u32 tmp;
+	struct skykirin_ht1628_platform_data	*pdata;
+	struct device_node *np = pdev->dev.of_node;
+	const struct of_device_id *of_id =
+			of_match_device(skykirin_ht1628_dt_ids, &pdev->dev);
+
+
+    struct gpio_desc *data,*clk,*cs;
+	if (!of_id)
+		return 0;
+
+	pdata = devm_kzalloc(&pdev->dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+
+	ht1628_priv = devm_kzalloc(&pdev->dev, sizeof(*ht1628_priv), GFP_KERNEL);
+
+	ret = of_get_named_gpio(np, "spi_clk", 0);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "spi_clk property not found\n");
+		goto error_free;
+	}
+	pdata->clk = ret;
+	ht1628_priv->clk = pdata->clk;
+	gpio_request(pdata->clk,"spi_clk_gpio");
+	
+	clk = gpio_to_desc(pdata->clk);
+	gpiod_direction_output_raw(clk,0);
+	gpiod_direction_output_raw(clk,1);
+	ret = of_get_named_gpio(np, "spi_cs", 0);
+	if (ret < 0) {
+		dev_info(&pdev->dev, "spi_cs property not found, switching to no-rx mode\n");
+		pdata->cs = 0;
+	} else
+		pdata->cs = ret;
+		ht1628_priv->cs = pdata->cs;
+	cs = gpio_to_desc(pdata->cs);
+	gpio_request(pdata->cs,"spi_cs_gpio");
+	gpiod_direction_output_raw(cs,0);
+	gpiod_direction_output_raw(cs,1);
+	ret = of_get_named_gpio(np, "spi_data", 0);
+	if (ret < 0) {
+		dev_info(&pdev->dev, "spi_data property not found, switching to no-tx mode\n");
+		pdata->data = 0;
+	} else
+		pdata->data = ret;
+		ht1628_priv->data = pdata->data;
+		ht1628_priv->sign = 0;
+	gpio_request(pdata->data,"spi_data_gpio");
+	data = gpio_to_desc(pdata->data);
+	gpiod_direction_output_raw(data,0);
+	gpiod_direction_output_raw(data,1);
+	pdev->dev.platform_data = pdata;
+	
+	platform_device_add_data(pdev,pdata,sizeof(*pdata));
+
+
+	return 0;
+
+error_free:
+	devm_kfree(&pdev->dev, pdata);
+	devm_kfree(&pdev->dev,ht1628_priv);
+	return ret;
+}
+
+
+void skykirin_ht1628_send_8bit(uint8_t dat)
+{
+  uint8_t i;
+  struct gpio_desc *clk, *data;
+  clk = gpio_to_desc(ht1628_priv->clk);
+  data = gpio_to_desc(ht1628_priv->data);
+  for (i = 0; i < 8; i++)
+  { __const_udelay(42950);
+    gpiod_set_raw_value(clk, 0);
+    if (dat & 0x01) gpiod_set_raw_value(data, 1);
+    else gpiod_set_raw_value(data, 0);
+    
+    __const_udelay(42950);
+    dat = dat >> 1;
+    gpiod_set_raw_value(clk, 1);
+
+
+  };
+  __const_udelay(42950);
+  
+}
+
+void skykirin_ht1628_command(uint8_t com)
+{
+	  struct gpio_desc *data,*clk,*cs;
+      data  = gpio_to_desc(ht1628_priv->data);
+      cs  = gpio_to_desc(ht1628_priv->cs);
+      clk  = gpio_to_desc(ht1628_priv->clk);
+	
+  gpiod_set_raw_value(cs, 1);
+  __const_udelay(42950);
+  gpiod_set_raw_value(cs, 0);
+
+  skykirin_ht1628_send_8bit(com);
+}
+
+static int device_major_number = 0 ;
+static int skykirin_ht1628_probe(struct platform_device *pdev)
+{
+    //struct skykirin_ht1628_priv *skykirin_ht1628;
+    int status,i;
+    struct skykirin_ht1628_platform_data	*pdata;
+    struct class *dev_class;
+    dev_t dev;
+    //parse gpio from kernel device tree.
+    status = skykirin_ht1628_probe_dt(pdev);
+    //get driver platform data
+    pdata = dev_get_platdata(&pdev->dev);
+    
+    dev_info(&pdev->dev, "skykirin_ht1628_probe\n");
+    // register a char device named skykirin-ht1628
+    status = register_chrdev(0, "skykirin-ht1628", &skykirin_ht1628_fops);
+    if (status < 0 ){
+		printk("cannot register char device skykirin-ht1628");
+		return status;
+	}
+	device_major_number = status;
+    // create a device class
+    dev_class = class_create(THIS_MODULE,"skykirin-ht1628");
+    // store the class to platform data
+    pdata->skykirin_ht1628_class = dev_class;
+    // make a dev node in /dev
+    dev = MKDEV(device_major_number,0);
+    // create the device
+    device_create(dev_class,NULL,dev,NULL,"skykirin-ht1628");
+    
+    i = 8;
+
+	skykirin_ht1628_command(0x3u);  //set mode to 3
+	skykirin_ht1628_command(0x40u); //set address inc
+	skykirin_ht1628_command(0xC0u); //set address 0
+	do //clear ram
+	{
+		skykirin_ht1628_send_8bit(0);//clear ram
+		skykirin_ht1628_send_8bit(0);
+		--i;
+	}
+	while ( i );
+	skykirin_ht1628_command(0x44u); //set address fixed
+	skykirin_ht1628_command(0x8Fu); //set display on
+	skykirin_ht1628_command(0xC0u); //select first led
+	skykirin_ht1628_send_8bit(0x38u);//L 
+	skykirin_ht1628_command(0xC2u);  //select second led
+	skykirin_ht1628_send_8bit(0x3Fu);//O
+	skykirin_ht1628_command(0xC4u); //select third led
+	skykirin_ht1628_send_8bit(0x77u);//A
+	skykirin_ht1628_command(0xC6u); //select 4th led
+	skykirin_ht1628_send_8bit(0x5Eu);//d
+	skykirin_ht1628_command(0xC8u);  //set address 0xC8 maybe this is the power on sign?
+    uint8_t data = ht1628_priv->sign | 0x4u ;
+    ht1628_priv->sign = data;
+	skykirin_ht1628_send_8bit(data);
+
+    dev_info(&pdev->dev, "skykirin_ht1628_probe end\n");
+    return 0;
+}
+
+
+static int skykirin_ht1628_suspend(struct platform_device *pdev)
+{
+  struct skykirin_ht1628_platform_data	*pdata;
+  pdata = dev_get_platdata(&pdev->dev);
+  skykirin_ht1628_command(0xC0u);
+  skykirin_ht1628_send_8bit(7u);//8
+  skykirin_ht1628_command(0xC2u);
+  skykirin_ht1628_send_8bit(7u);//8
+  skykirin_ht1628_command(0xC4u);
+  skykirin_ht1628_send_8bit(7u);//8
+  skykirin_ht1628_command(0xC6u);
+  skykirin_ht1628_send_8bit(7u);//8	
+  printk("=====================suspend==================");
+  return 0;
+}
+
+static int skykirin_ht1628_resume(struct platform_device *pdev)
+{
+  struct skykirin_ht1628_platform_data	*pdata;
+  pdata = dev_get_platdata(&pdev->dev);
+  skykirin_ht1628_command(0xC0u);
+  skykirin_ht1628_send_8bit(7u);//8
+  skykirin_ht1628_command(0xC2u);
+  skykirin_ht1628_send_8bit(7u);//8
+  skykirin_ht1628_command(0xC4u);
+  skykirin_ht1628_send_8bit(7u);//8
+  skykirin_ht1628_command(0xC6u);
+  skykirin_ht1628_send_8bit(7u);//8	
+  printk("=====================resume==================");
+  return 0;
+}
+
+
+static int skykirin_ht1628_remove(struct platform_device *pdev)
+{
+  struct skykirin_ht1628_platform_data	*pdata;
+  pdata = dev_get_platdata(&pdev->dev);
+  skykirin_ht1628_command(0xC0u); //set address 0
+  int i=8;
+  do //clear ram
+  {
+    skykirin_ht1628_send_8bit(0);//clear ram
+    skykirin_ht1628_send_8bit(0);
+    --i;
+  }
+  while ( i );
+
+  skykirin_ht1628_command(0xC0u);
+  skykirin_ht1628_command(0x44u); //set address fixed
+  skykirin_ht1628_command(0x87u); //set display off
+  unregister_chrdev(device_major_number,"skykirin-ht1628");
+ 
+ return 0;
+}
+
+
+static int skykirin_ht1628_ioctl(struct file *file,unsigned int cmd, unsigned long arg)
+{
+	uint8_t command;
+	uint8_t data = ht1628_priv->sign;
+	uint8_t update_flag;
+	uint8_t num_display;
+	char   buff[256];
+
+	switch (cmd) {
+		case HT1628_DISP_SET_TIME:
+		    if (arg){
+			copy_from_user(&buff,(char*)arg,strlen((char*)arg));
+				
+			}
+			num_display=0;
+			break;
+		case HT1628_DISP_SET_UNKNOWN:
+			command = 0xC8;
+			break;
+		case HT1628_DISP_DOT_ON:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign | 0x90; // bit7 to 1 and bit4 to 1 1001 0000 //set dot on
+		    goto send_data;
+			break;
+		case HT1628_DISP_POWER_ON:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign | 0x4; // 00000100 the bit2 set to 1 0000 0100
+		    goto send_data;
+			break;
+		case HT1628_DISP_SET_LAN_ON:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign | 0x9;  // 00001000 the bit3 set to 1 0000 1000 //set lan on
+		    goto send_data;
+			break;
+		case HT1628_DISP_SET_LAN_OFF:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign & 0xF7; // the bit3 to 0 0000 0000 
+		    goto send_data;
+			break;
+		case HT1628_DISP_WIFI_ON_L4:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign & 0x7F; // the bit7 to 0 0000 0000 
+		    goto send_data;
+			break;
+		case HT1628_DISP_WIFI_ON_HALF:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign & 0xDF | 0x40; // the bit6 to 1 and bit5 to 0 0100 0000 //wifi 1 level1 on
+		    goto send_data;
+			break;
+		case HT1628_DISP_WIFI_OFF:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign & 0x9F; // the bit6 to 0 and bit5 to 0 0000 0000  //wifi off
+		    goto send_data;
+			break;
+		case HT1628_DISP_WIFI_ON_FULL:
+			command = 0xC8;
+		    skykirin_ht1628_command(command);
+		    data = ht1628_priv->sign | 0x60; // the bit6 to 1 and bit5 to 1 0110 0000 //wifi level 2 on
+	send_data:
+			ht1628_priv->sign = data;
+			skykirin_ht1628_send_8bit(data);
+			return 0;
+		case HT1628_DISP_ON:
+			command = 0x8F;
+			goto send_cmd;
+			break;
+		case HT1628_DISP_OFF:
+			command = 0x87;				
+    send_cmd:
+			skykirin_ht1628_command(command);
+			return 0;
+			break;
+		default:
+			printk("ERROR:ioctl not found %d\n",cmd);
+			return 0;
+		
+	}
+	do {
+		uint8_t tmp = buff[num_display];
+		skykirin_ht1628_command(HT1628_DIG_REG[num_display]);
+		uint8_t num_n = tmp -0x30;
+		if (num_n > 9 ){
+			 uint8_t alphabet = (tmp -0x41);
+			 if ( alphabet > 0x19 ){
+				uint8_t lower_num = tmp - 0x61;
+				if (lower_num > 0x19 ){
+					goto skip;
+				}else{
+					skykirin_ht1628_send_8bit(display_letter[lower_num]);
+				}
+			 }else {
+				skykirin_ht1628_send_8bit(display_letter[alphabet]);
+			 }
+		}else {
+			skykirin_ht1628_send_8bit(display_num[num_n]); 
+		}
+	skip: 
+		++num_display;
+	}while(num_display < 4);
+		
+	return 0;
+}
+static int skykirin_ht1628_release(void)
+{
+	
+	return 0;
+}
+
+static int skykirin_ht1628_open(struct inode *inode,struct file *file)
+{
+	int result;
+	result = nonseekable_open(inode,file);
+	
+	return 0;
+}
+
+static struct platform_driver skykirin_ht1628_driver = {
+	.driver = {
+		.name	= DRIVER_NAME,
+		.of_match_table = of_match_ptr(skykirin_ht1628_dt_ids),
+	},
+	.probe		= skykirin_ht1628_probe,
+	.remove		= skykirin_ht1628_remove,
+	.suspend    = skykirin_ht1628_suspend,
+	.resume     = skykirin_ht1628_resume,
+};
+
+static int __init skykirin_ht1628_init(void)
+{
+    int ret;
+
+	ret = platform_driver_register(&skykirin_ht1628_driver);
+	if (ret)
+		platform_driver_unregister(&skykirin_ht1628_driver);
+	return ret;
+}
+static void __exit skykirin_ht1628_exit(void)
+{
+	platform_driver_unregister(&skykirin_ht1628_driver);
+}
+
+subsys_initcall(skykirin_ht1628_init);
+module_exit(skykirin_ht1628_exit);
+
+MODULE_ALIAS("platform:" DRIVER_NAME);
+MODULE_AUTHOR("Tenfar Lin <tenfar@gmail.com>");
+MODULE_DESCRIPTION("SkyKirin HT1628 LED Controller Driver");
+MODULE_LICENSE("GPL v2");
+
+
+
+
diff --git a/include/linux/skykirin-ht1628.h b/include/linux/skykirin-ht1628.h
new file mode 100644
index 0000000..18ce0f1
--- /dev/null
+++ b/include/linux/skykirin-ht1628.h
@@ -0,0 +1,179 @@
+#ifndef SKYKIRIN_HT1628_H
+#define SKYKIRIN_HT1628_H
+#include <linux/delay.h>
+#include <linux/gpio.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/ioctl.h>
+#include <linux/uaccess.h>
+
+//
+//       A
+//      ____
+//    |      |
+//  F |   G  |  B
+//     ______
+//    |      |
+//  E |      |  C
+//      ____
+//        D
+
+
+
+#define S7_A    0x001 
+#define S7_B    0x002
+#define S7_C    0x004
+#define S7_D    0x008 
+#define S7_E    0x010
+#define S7_F    0x020
+#define S7_G    0x040
+
+//Mask for blending out and setting 7 segments digits
+#define MASK_7S_ALL = (S7_A | S7_B | S7_C | S7_D | S7_E | S7_F | S7_G}
+
+#define C7_MIN  (S7_G)
+
+//48 0x30 digits
+#define C7_0    (S7_A | S7_B | S7_C | S7_D | S7_E | S7_F)
+#define C7_1    (S7_B | S7_C)
+#define C7_2    (S7_A | S7_B | S7_D | S7_E | S7_G)
+#define C7_3    (S7_A | S7_B | S7_C | S7_D | S7_G)
+#define C7_4    (S7_B | S7_C | S7_F | S7_G)
+#define C7_5    (S7_A | S7_C | S7_D | S7_F | S7_G)
+#define C7_6    (S7_A | S7_C | S7_D | S7_E | S7_F | S7_G)
+#define C7_7    (S7_A | S7_B | S7_C)
+#define C7_8    (S7_A | S7_B | S7_C | S7_D | S7_E | S7_F | S7_G)
+#define C7_9    (S7_A | S7_B | S7_C | S7_D | S7_F | S7_G)
+//64 0x40
+#define C7_A    (S7_A | S7_B | S7_C | S7_E | S7_F | S7_G )  // Upper case alphabet
+#define C7_B    (S7_C | S7_D | S7_E | S7_F | S7_G)
+#define C7_C    (S7_A | S7_D | S7_E | S7_F)
+#define C7_D    (S7_B | S7_C | S7_D | S7_E | S7_G)
+#define C7_E    (S7_A | S7_D | S7_E | S7_F | S7_G)
+#define C7_F    (S7_A | S7_E | S7_F | S7_G)
+#define C7_G    (S7_A | S7_B | S7_C | S7_F | S7_G)
+#define C7_H    (S7_B | S7_C | S7_E | S7_F | S7_G)
+#define C7_I    (S7_B | S7_C)
+#define C7_J    (S7_B | S7_C | S7_D)
+#define C7_K    (S7_E | S7_F | S7_G)
+#define C7_L    (S7_D | S7_E | S7_F)
+#define C7_M    (S7_C | S7_E | S7_G)
+#define C7_N    (S7_C | S7_E | S7_G)
+#define C7_O    (S7_A | S7_B | S7_C | S7_D | S7_E | S7_F)
+#define C7_P    (S7_A | S7_B | S7_E | S7_F | S7_G)
+#define C7_Q    (S7_A | S7_B | S7_C | S7_F | S7_G)
+#define C7_R    (S7_E | S7_G)
+#define C7_S    (S7_A | S7_C | S7_D | S7_F | S7_G)
+#define C7_T    (S7_D | S7_E | S7_F | S7_G)
+#define C7_U    (S7_B | S7_C | S7_D | S7_E | S7_F)
+#define C7_Y    (S7_B | S7_C | S7_D | S7_F | S7_G)
+#define C7_Z    (S7_A | S7_B | S7_D | S7_E | S7_G)
+
+//97 0x61  Lower case alphabet
+#define C7_a     C7_A
+#define C7_b     C7_B
+#define C7_c     C7_C
+#define C7_d     C7_D
+#define C7_e     C7_E
+#define C7_f     C7_H
+#define C7_g     C7_G
+#define C7_h     C7_H
+#define C7_i     C7_I
+#define C7_j     C7_J
+#define C7_k     C7_K
+#define C7_l     C7_L
+#define C7_m     C7_M
+#define C7_n     C7_N
+#define C7_o     C7_O
+#define C7_p     C7_P
+#define C7_q     C7_Q
+#define C7_r     C7_R
+#define C7_s     C7_S
+#define C7_t     C7_T
+#define C7_u     C7_U
+#define C7_y     C7_Y
+#define C7_z     C7_Z
+
+
+
+const uint8_t HT1628_DIG_REG[8] = {0xC0,0xC2,0xC4,0xC6,0xC8,0x0,0x0,0x0};
+//                                 0   1   2     3    4    5    6    7   8    9    A   B   C   D   E  F
+const uint8_t display_num[16] = {0x3F,0x6,0x5B,0x4F,0x66,0x6D,0x7D,0x7,0x7F,0x6F,C7_A,C7_B,C7_C,C7_D,C7_E,C7_F};
+
+//                                    A   B   C   D     E     F    G    T   L
+const uint8_t display_letter[26] = {C7_A,C7_B,C7_C,C7_D,C7_E,C7_F,C7_G,C7_H,C7_I,C7_J,C7_K,C7_L,C7_M,C7_N,C7_O,C7_P,C7_Q,C7_R,C7_S,C7_T,C7_U,0x0,0x0,0x0,C7_Y,C7_Z};
+
+
+#define IOCTL_MAGIC 'k'
+
+#define DISPLAY_SET_UNKNOWN 0
+#define DISPLAY_SET_TIME 1
+#define DISPLAY_DOT_ON 2
+#define DISPLAY_WIFI_ON_1 3 
+#define DISPLAY_WIFI_ON_2 4
+#define DISPLAY_WIFI_ON_3 5 
+#define DISPLAY_WIFI_ON_4 6
+#define DISPLAY_LAN_ON 7 
+#define DISPLAY_LAN_OFF 8
+#define DISPLAY_ON 9
+#define DISPLAY_OFF 10
+#define DISPLAY_WIFI_ON_HALF 11
+#define DISPLAY_WIFI_ON_FULL 12
+#define DISPLAY_WIFI_OFF 13
+#define DISPLAY_POWER_ON 14
+
+
+//the ioctl use in ioctl function
+#define HT1628_DISP_ON     _IO(IOCTL_MAGIC,DISPLAY_ON)
+#define HT1628_DISP_OFF    _IO(IOCTL_MAGIC,DISPLAY_OFF)
+#define HT1628_DISP_SET_LAN_ON _IO(IOCTL_MAGIC,DISPLAY_LAN_ON)
+#define HT1628_DISP_SET_LAN_OFF _IO(IOCTL_MAGIC,DISPLAY_LAN_OFF)
+#define HT1628_DISP_WIFI_ON_L3 _IO(IOCTL_MAGIC,DISPLAY_WIFI_ON_3)
+#define HT1628_DISP_WIFI_ON_L4 _IO(IOCTL_MAGIC,DISPLAY_WIFI_ON_4)
+#define HT1628_DISP_DOT_ON     _IO(IOCTL_MAGIC,DISPLAY_DOT_ON)
+#define HT1628_DISP_SET_TIME   _IOW(IOCTL_MAGIC,DISPLAY_SET_TIME,unsigned long)
+#define HT1628_DISP_SET_UNKNOWN _IOW(IOCTL_MAGIC,DISPLAY_SET_UNKNOWN,unsigned long)
+#define HT1628_DISP_WIFI_ON_FULL _IO(IOCTL_MAGIC,DISPLAY_WIFI_ON_FULL)
+#define HT1628_DISP_WIFI_ON_HALF _IO(IOCTL_MAGIC,DISPLAY_WIFI_ON_HALF)
+#define HT1628_DISP_WIFI_OFF     _IO(IOCTL_MAGIC,DISPLAY_WIFI_OFF)
+#define HT1628_DISP_POWER_ON	_IO(IOCTL_MAGIC,DISPLAY_POWER_ON)
+
+struct skykirin_ht1628_priv {
+	unsigned long data;
+	unsigned clk;
+	unsigned long cs;
+	uint8_t sign;
+};
+
+struct skykirin_ht1628_platform_data {
+	unsigned long data;
+	unsigned  clk;
+	unsigned long cs;
+	struct class *skykirin_ht1628_class;
+	uint8_t brightness;
+};
+
+#define ON 0xff
+#define OFF 0x0
+
+struct skykirin_ht1628_operations {
+	int (*open)(void);
+	int (*release)(void);
+	int (*ioctl)(void);
+};
+
+static int skykirin_ht1628_suspend(struct platform_device *pdev);
+static int skykirin_ht1628_resume(struct platform_device *pdev);
+static int skykirin_ht1628_remove(struct platform_device *pdev);
+static int skykirin_ht1628_ioctl(struct file *file,unsigned int cmd,unsigned long arg);
+static int skykirin_ht1628_release(void);
+static int skykirin_ht1628_open(struct inode *inode,struct file *file);
+static int __init skykirin_ht1628_init(void);
+static void __exit skykirin_ht1628_exit(void);
+static int skykirin_ht1628_probe_dt(struct platform_device *pdev);
+void skykirin_ht1628_send_8bit(uint8_t dat);
+void skykirin_ht1628_command(uint8_t com);
+static int skykirin_ht1628_probe(struct platform_device *pdev);
+static int skykirin_ht1628_remove(struct platform_device *pdev);
+
+#endif
-- 
2.7.4

